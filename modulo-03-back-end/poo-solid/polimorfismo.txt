# POLIMORFISMO  = Polimorfismo vem do grego muitas formas, e nos remete √†s v√°rias formas que um mesmo m√©todo pode possuir.

Existe mais de uma forma de polimorfismo (seria isso polipolimorfismo? ü§£), mas vamos nos concentrar na mais comum: sobrescrita de m√©todos.

Nesta situa√ß√£o, o polimorfismo ocorre quando um m√©todo implementado em uma superclasse √© reimplementado numa subclasse, comportando-se de forma diferente.

Como exemplo pr√°tico em classes TypeScript podemos criar uma classe ‚Äòpai‚Äô de nome Animals e ter√≠amos em seguidas os tipos de Animals que possuem caracter√≠sticas particulares, mas mant√©m comportamentos diferenciados.

Para ilustrar, no exemplo de c√≥digo a seguir temos a representa√ß√£o TypeScript da classe Animal, a qual cont√©m o m√©todo makeSound que representa o comportamento de emitir um som e atributo turns , o qual contabiliza a quantidade de vezes que o som foi emitido (quantas vezes o m√©todo makeSound foi executado):

EX:

class Animals {
  declare turns: number;
  public makeSound(sound: string) {
      console.log('Som emitido:' + sound);
  }
}

class Dogs extends Animals {
  numberTurn(turns: number) {
      return turns;
  }

  makeSound( sound: string): void {
    const times = this.numberTurn(5);
    console.log(`Som emitido: ${sound}, ${times} vezes`);
  }
}

class Birds extends Animals {
  declare specie: string;

  makeSound (sound: string) {
    this.specie = 'p√°ssaro';
      console.log(`O som emitido pelo ${this.specie} √© ${sound}`);
  }
}

const dogs = new Dogs();
dogs.makeSound("au au au");

const birds = new Birds();
birds.makeSound("fiu fiu fiu fiu fiu");

* A resposta ao executar o comando tsc index.ts && node index.js no terminal seria:

EX:

    Som emitido: au au au, 5 vezes
    O som emitido pelo p√°ssaro √© fiu fiu fiu fiu fiu

Podemos observar que ocorreu a sobrescrita do m√©todo mudando o seu comportamento e resultado final.

* Sobrescrita de m√©todo

Considere o seguinte exemplo:

EX:

class Animal {
  constructor(public name: string) { }
  move() { console.log(`${this.name} est√° se movendo.`); }
}
class Bird extends Animal {
  move() { console.log(`${this.name} est√° voando.`); }
}
class Mammal extends Animal {
  move() { console.log(`${this.name} est√° andando.`); }
}

const a = new Animal('Tubar√£o');
const b = new Bird('Papagaio');
const m = new Mammal('Tatu');

const myMove = (animal: Animal) => {
  animal.move();
}
myMove(a);
myMove(b);
myMove(m);

/*
Sa√≠da:
Tubar√£o est√° se movendo.
Papagaio est√° voando.
Tatu est√° andando.
*/

Observe que myMove recebe como par√¢metro um animal da classe Animal e chama o m√©todo move.

Conforme voc√™ viu na aula passada, sabe que podemos passar uma subclasse quando uma superclasse √© esperada, visto que ela possui todos os m√©todos que a superclasse possui.

Neste caso em espec√≠fico, as classes Ave e Mam√≠fero sobrescrevem o m√©todo move da classe Animal, e quando passamos um objeto de uma dessas classes, uma implementa√ß√£o diferente do m√©todo move √© utilizado.

* Uso do super

Ontem voc√™ viu como utilizar o super para chamar o construtor da superclasse dentro da subclasse.

Uma outra coisa que voc√™ pode fazer √©, ao sobrescrever um m√©todo qualquer, chamar a implementa√ß√£o dele na superclasse por meio do super.

EX:

class Animal {
  constructor(public name: string) { }
  move() { console.log(`${this.name} est√° se movendo.`); }
}
class Bird extends Animal {
  move() {
    super.move();
    console.log(`${this.name} est√° voando.`);
  }
}
class Mammal extends Animal {
  move() { console.log(`${this.name} est√° andando.`); }
}

const a = new Animal('Tubar√£o');
const b = new Bird('Papagaio');
const m = new Mammal('Tatu');

const myMove = (animal: Animal) => {
  animal.move();
}
myMove(a);
myMove(b);
myMove(m);

/*
Sa√≠da:
Tubar√£o est√° se movendo.
Papagaio est√° se movendo.
Papagaio est√° voando.
Tatu est√° andando.
*/

Observe a chamada super.move() dentro de move, na classe Ave.

√â importante salientar que voc√™ pode chamar outros m√©todos da superclasse (caso existam), e n√£o s√≥ o mesmo no qual voc√™ est√° na subclasse. Por exemplo, se a classe Animal tivesse, al√©m do m√©todo move, um m√©todo sleep, dentro do m√©todo move na classe Ave voc√™ pode chamar o m√©todo sleep da classe Animal digitando super.sleep().

* classes, m√©todos e atributos abstratos

Por vezes, criamos classes que devem possuir m√©todos pensados para serem implementados em subclasses.

A ideia √© que a superclasse, mais gen√©rica, n√£o deve fazer ideia de como esse m√©todo deve funcionar, apenas saber que ele existe.

Isso √© o mesmo que quando h√° uma implementa√ß√£o de interface, com a diferen√ßa na interface nenhum m√©todo √© implementado, e aqui queremos selecionar alguns m√©todos para que n√£o sejam implementados.

Para isso, utilizamos classes abstratas, e estas possuem m√©todos abstratos.

As classes abstratas n√£o podem ser instanciadas, ou seja, voc√™ n√£o pode criar um objeto a partir de uma classe abstrata.

M√©todos abstratos s√≥ podem existir em classes abstratas, e eles devem ser implementados na subclasse.

* No exemplo abaixo temos uma classe abstrata Employee que possui um atributo abstrato(MIN_SALARY) e um m√©todo abstrato (work()) que se aplica a seus subtipos. No caso da Trybe, temos pessoa instrutora, pessoa especialista e pessoa facilitadora. Portanto, ao criar as classes de cada subtipo, estendemos a partir da classe abstrata Employee e implementamos o atributo e o m√©todo de acordo com suas particularidades.

EX:

/*
Dicion√°rio en-pt:
- employee: pessoa empregada/funcion√°ria
*/

abstract class Employee {
  constructor(public name: string) { }

  /* Aqui temos um atributo abstrato que implica √†s classes
  filhas atribu√≠rem, de maneira obrigat√≥ria, um valor do tipo 'number' */
  abstract MIN_SALARY: number

  /* J√° aqui temos um m√©todo abstrato que implica √†s classes filhas 
  implement√°-la, de maneira obrigat√≥ria, de acordo com a utilidade da classe filha  */
  abstract work(): void
}

class Instructor extends Employee {
  constructor(public name: string) {
    super(name); 
  }
  MIN_SALARY = 10000;
  work() { console.log(`${this.name} est√° auxiliando as pessoas estudantes em mentorias.`); }
}

class Specialist extends Employee {
  constructor(public name: string) {
    super(name); 
  }
  MIN_SALARY = 20000;
  work() { console.log(`${this.name} est√° ministrando uma aula ao vivo.`); }
}

class Facilitator extends Employee {
  constructor(public name: string) {
    super(name); 
  }
  MIN_SALARY = 50000;
  work() { console.log(`${this.name} est√° conduzindo um 1:1.`); }
}

const instructor = new Instructor('Victor');
const specialist = new Specialist('Gus');
const facilitator = new Facilitator('Silvinha');

instructor.work(); // Victor est√° auxiliando as pessoas estudantes em mentorias.
specialist.work(); // Gus est√° ministrando uma Aula Ao Vivo.
facilitator.work(); // Silvinha est√° conduzindo um 1:1.

* m√©todos e atributos est√°ticos

Uma outra funcionalidade interessante √© o que chamamos de m√©todo est√°tico.

Um m√©todo est√°tico nada mais √© do que uma fun√ß√£o que n√£o precisa acessar nenhum atributo do objeto.

A diferen√ßa sem√¢ntica de um m√©todo est√°tico para uma fun√ß√£o √© que o m√©todo est√°tico tem a ver com a classe. Isso significa que fica um pouco ‚Äúsem sentido‚Äù voc√™ disponibilizar um m√©todo sozinho, pois, por mais que ele n√£o precise manipular uma inst√¢ncia, ele est√° muito ligado √† classe.

Al√©m de m√©todos, podemos ter atributos est√°ticos, que s√£o acessados manipulando a classe, n√£o a inst√¢ncia.

Agora vamos ver outro exemplo com uma classe Employee que possui um atributo est√°tico chamado employeeCount, respons√°vel por armazenar a quantidade total de pessoas funcion√°rias, e um m√©todo est√°tico chamado de addEmployee(), respons√°vel por incrementar a contagem de pessoas funcion√°rias. Com esse exemplo √© poss√≠vel notar que a cada instancia√ß√£o de Employee o atributo employeeCount √© incrementado:

EX:

/*
Dicion√°rio en-pt:
- static: est√°tico
*/

class Employee {
/* Atributo est√°tico, que pertence a classe */
private static employeeCount = 0

  /* Aqui temos o exemplo de um atributo comum que, em contraste com o atributo est√°tico,
  √© utilizado pelas inst√¢ncias e n√£o pela classe */
  private employeeName: string;

  constructor(name: string) {
    /* Pelo fato do o m√©todo addEmployee() ser est√°tico, ou seja, acess√≠vel 
    apenas a partir da pr√≥pria classe e n√£o de suas inst√¢ncias, √© que a
    chamamos a partir de Employee e n√£o do 'this' */
    Employee.addEmployee();

    // Nesse caso, o 'this' se refere √† inst√¢ncia dessa classe, que est√° sendo constru√≠da
    this.employeeName = name;
  }

  // Esse √© um m√©todo exclusivo da classe, por isso est√°tico 
  private static addEmployee() {
    /* Nesse caso, como o atributo √© est√°tico, melhor forma de acessar
    o atributo √© a partir do nome da classe.  */
    Employee.employeeCount += 1;
    console.log(`Total de pessoas funcion√°rias: ${Employee.employeeCount}`)
  }

  /* Aqui temos o exemplo de m√©todo comum que, em contraste com o m√©todo est√°tico,
  √© utilizado pelas inst√¢ncias e n√£o pela classe */
  public getName(): string { 
    // Novamente, o 'this' se referindo √† inst√¢ncia
    return this.employeeName
  }
}

const employee1 = new Employee('Kissyla'); // Total de pessoas funcion√°rias: 1
const employee2 = new Employee('Cala√ßa'); // Total de pessoas funcion√°rias: 2
const employee3 = new Employee('Setinha'); // Total de pessoas funcion√°rias: 3

classe com m√©todo est√°tico

Observe que usamos o nome da classe para acessar o atributo employeeCount dentro do m√©todo addEmployee() da classe Employee. Poder√≠amos utilizar o this para acess√°-lo, mas como boa pr√°tica, mantemos o nome da classe para acessar atributos e m√©todos est√°ticos em qualquer ponto do c√≥digo. Isso acontece para deixar n√≠tido, para outras pessoas desenvolvedoras, que aquele atributo ou m√©todo √© est√°tico.

Resumindo:

Os m√©todos e atributos est√°ticos pertencem a classe e n√£o aos objetos da classe.
Se um atributo est√°tico tiver seu valor alterado em algum objeto da classe, a altera√ß√£o se aplicar√° a todos os objetos j√° instanciados e os que ser√£o instanciados.

Entretanto, √© importante salientar que na maioria das vezes √© prefer√≠vel criar uma fun√ß√£o normal, no mesmo m√≥dulo que a classe est√° sendo criada, exportando-as de forma separada. Isso facilita a vida de quem vai usar.

* Polimorfismo com interfaces

O polimorfismo com interfaces se d√° da mesma forma que o com heran√ßa.

Duas classes diferentes implementam a mesma interface, implementando tamb√©m os m√©todos obrigat√≥rios que a interface estipula.

Por exemplo, podemos enviar a uma fun√ß√£o um par√¢metro com o tipo da interface e passar em seu lugar um objeto de uma classe que implementa tal interface.

H√° uma garantia de que tudo o que a interface estipula est√° implementado na classe e, consequentemente, no objeto.

* Classes diferentes ir√£o implementar determinados m√©todos de formas diferentes. No exemplo abaixo, o m√©todo showIdentification √© implementado de forma diferente nas classes PessoaF√≠sica e PessoaJur√≠dica.

EX:

interface Person {
  id: number;
  name: string;
  showIdentification(): void;
}

class PhysicalPerson implements Person {
  private static lastId = 0;
  private _name;
  private _id;
  private _cpf;

  constructor(name: string, cpf: string) {
    this._id = PhysicalPerson.newId();
    this._name = name;
    this._cpf = cpf;
  }

  private static newId() { return this.lastId++; }
  get id() { return this._id; }
  get name() { return this._name; }
  get cpf() { return this._cpf; }
  showIdentification() { console.log(this.id, this._cpf); }
}

class LegalPerson implements Person {
  private static lastId = 0;
  private _name;
  private _id;
  private _cnpj;

  constructor(name: string, cnpj: string) {
    this._id = LegalPerson.newId();
    this._name = name;
    this._cnpj = cnpj;
  }

  private static newId() { return this.lastId++; }
  get id() { return this._id; }
  get name() { return this._name; }
  get cnpj() { return this._cnpj; }
  showIdentification() { console.log(this.id, this._cnpj); }
}

const pp0 = new PhysicalPerson('John', '123456789');
const pp1 = new PhysicalPerson('Jenny', '987654321');
const lp = new LegalPerson('International Sales SA', '834729384723');

const showIdentification = (person: Person) => {
  person.showIdentification();
}
showIdentification(pp0);
showIdentification(pp1);
showIdentification(lp);

/*
Sa√≠da:
0 123456789
1 987654321
0 834729384723
*/

* Garantia de tipo com generics

Agora imagine que voc√™ queira agora criar uma classe Contrato, que vai possuir uma pessoa corretora, que pode ser tanto uma pessoa f√≠sica quanto uma pessoa jur√≠dica.

Ao passar simplesmente Pessoa como tipo da pessoa corretora, voc√™ perde a capacidade de acessar elementos espec√≠ficos das classes PessoaF√≠sica e PessoaJur√≠dica.

EX:

class Contract {
  static _number = 0;
  constructor(public broker: Person){}
  static get number() { return this._number; }
}

const c1 = new Contract(pp0);
console.log(c1.broker.cpf); // Erro, pois n√£o existe cpf em Person
Para garantir o tipo utilizado, podemos utilizar generics.

√â bem simples:

* Escolhemos uma letra para representar o elemento e a colocamos entre sinais de menor e maior que (<>) ap√≥s o nome da classe
Utilizamos esta letra no lugar do tipo Pessoa

EX:

class Contract<T> { // Agora a classe recebe o gen√©rico T
  static _number = 0;
  constructor(public broker: T) { } // T no lugar de Person
  static get number() { return this._number; }
}

// Tipo inferido (n√£o expl√≠cito)
const c1 = new Contract(pp0); // TypeScript "advinha" que pp0 √© pessoa f√≠sica
console.log(c1.broker.cpf); // Okay

// Tipagem expl√≠cita
const c2: Contract<LegalPerson> = new Contract(lp); // Deixo expl√≠cito que lp √© pessoa jur√≠dica
console.log(c2.broker.cnpj); // Okay

/*
Sa√≠da:
123456789
834729384723
*/

