# HERAN√áA E COMPOSI√á√ÉO POO

* Classe representa algo gen√©rico, uma estrutura.
* Objeto √© um elemento gerado nos moldes de uma classe.
* Atributo √© uma vari√°vel no contexto de uma classe.
* M√©todo √© uma fun√ß√£o no contexto de uma classe.
* Abstra√ß√£o √© a n√£o exibi√ß√£o do funcionamento interno da classe, de forma a simplificar a sua utiliza√ß√£o.
* Encapsulamento √© a disponibiliza√ß√£o apenas dos atributos e m√©todos que s√£o necess√°rios para o bom uso da classe.

# HERAN√áA E COMPOSI√á√ÉO  = heran√ßa que √© a capacidade de especializar classes, de forma a atender objetivos mais espec√≠ficos, e composi√ß√£o que √© o uso de outras classes, delegando a elas atribui√ß√µes espec√≠ficas delas.

* heran√ßa  = O pilar heran√ßa permite que classes herdeiras de outras sejam criadas, de forma a herdar tamb√©m seus m√©todos e atributos. Pense na classe Pessoa, com os atributos nome e altura e com o m√©todo sonhar. A partir dessa classe Pessoa, √© poss√≠vel criar uma classe herdeira dela, chamada PessoaCantora, que por herdar de Pessoa, ter√° automaticamente os atributos nome e altura e o m√©todo sonhar, mas poder√° ter um m√©todo somente dela: cantar.

√© importante salientar que heran√ßa √© uma caracter√≠stica da classe e n√£o do objeto. Ou seja, criamos uma classe que herda de outra e n√£o um objeto que herda de outro.

A heran√ßa permite que classes mais espec√≠ficas sejam criadas a partir de classes mais gen√©ricas. Com isso podemos criar uma classe com o comportamento base, e estender os comportamentos de uma classe existente sem precisar modific√°-la.

A classe base √© denominada classe m√£e ou superclasse, e a classe que estende dela √© denominada classe filha ou subclasse.

Algo muito interessante √© que, em todo lugar onde um objeto da superclasse √© esperado, um objeto da subclasse pode ser passado, pois ele apresenta todos os atributos e m√©todos de um objeto da superclasse.

Um exemplo visual de Heran√ßa entre classes. Note que o metodoA da classe Mae √© acess√≠vel tanto na classe Filha quanto na classe Neta. Isso ocorre, pois a classe Neta herda o metodoA da classe Filha que por sua vez, herda o metodoA da classe Mae;

EX:

class Animal {
  /*
    Ao inv√©s de declarar os atributos antes do construtor, receber par√¢metros
    no construtor e coloc√°-los nos atributos da classe, se n√£o formos
    validar, podemos utilizar uma forma simplificada de escrita, simplesmente
    colocando o modificador de visibilidade na frente
    do nome do par√¢metro no construtor

    Exemplo
    O seguinte c√≥digo:

    public x: number
    constructor(x: number) { this.x = x }

    Pode ser substitu√≠do por:

    constructor(public x: number) { }
    
    Obs: Usando essa sintaxe √© necess√°rio indicar explicitamente 
    logo antes do nome do atributo se ele √© public, private, protected ou readonly
  */
  constructor(public name: string, private birthDate: Date) { }

  get age() {
    /*Para operar com datas, vamos operar somente com milissegundos. Uma data
    √© o n√∫mero de milissegundos desde o dia 01/01/1970 (era Unix).*/
    const timeDiff = Math.abs(
      Date.now() -
      new Date(this.birthDate).getTime()
    );

    /*Convertendo de volta para o n√∫mero de anos inteiros, considerando anos bissextos.
    Tente entender a l√≥gica abaixo: como converter de milissegundos para anos?*/
    return Math.floor(timeDiff / (1000 * 3600 * 24) / 365.25);
  }
}

class Mammal extends Animal {
  walk() {
    console.log(`${this.name} est√° andando!`);
  }
}

const tiger = new Mammal(
  'Tigre',
  new Date(Date.parse('May 03, 2020')),
);

const main = (animal: Animal) => {
  console.log(animal.age);
}

main(tiger);
tiger.walk();

/*
Sa√≠da (c√≥digo rodado em Mar/2022):
1
Tigre est√° andando!
*/

A sintaxe para criar uma classe que herda outra √© bem simples, basta utilizar a palavra reservada extends.

Observe que a fun√ß√£o main espera receber um par√¢metro do tipo Animal. Por√©m, o objeto passado para a fun√ß√£o √© o objeto tiger, que √© do tipo Mammal. Isso ocorre pois todo Mammal √© tamb√©m um Animal, ent√£o qualquer par√¢metro do tipo Animal pode receber um objeto de classes filhas. Essa √© a grande vantagem do polimorfismo por subtipagem (ou heran√ßa).

A fun√ß√£o main, por√©m, s√≥ entende um objeto do tipo Animal. Por isso ela n√£o consegue acessar nada restrito ao subtipo Mammal (tamb√©m conhecida como classe filha ou subclasse)! Voc√™ vai obter um erro que diz ‚Äúa propriedade ‚Äòwalk‚Äô n√£o existe no tipo Animal‚Äú.

* Atributos protegidos

Observe que temos, na classe Animal, um atributo privado birthDate (data de nascimento). Voc√™ n√£o pode acessar ou alterar este atributo fora da classe Animal.

EX:

class Animal {
  constructor(private birthDate: Date) { } // Repare no private

}

class Bird extends Animal {
  showBirthDate() {
    console.log(this.birthDate); // ERRO! birthDate √© privado e n√£o √© vis√≠vel pra subclasse Bird.
  }
}

Entretanto, √†s vezes precisamos manter alguns atributos e m√©todos privados do mundo externo, mas poss√≠veis de serem modificados dentro de subclasses. √â a√≠ que entra o protected.

EX:

class Animal {
  constructor(protected birthDate: Date) { } // Protected: classe filha pode ler e escrever, mas acessos externos n√£o
}

class Bird extends Animal {
  showBirthDate() {
    console.log(this.birthDate); // Okay!
  }
}

* Super

Sempre que voc√™, na subclasse, queira referenciar a superclasse, poder√° utilizar a palavra reservada super. Super bacana, n√©? ü§£

vamos a um exemplo que n√£o funciona:

EX:

class Animal {
  constructor(protected birthDate: Date) { }
}

class Bird extends Animal {
  constructor(public name: string) { } // ERRO: constructor deve respeitar o contrato da superclasse
}

Em TypeScript, o m√©todo construtor de uma subclasse deve ser o mesmo da superclasse (os exemplos anteriores funcionaram pois n√£o tinham o construtor), ou deve chamar o da superclasse.

* Agora vamos a um exemplo que funciona:

EX:

class Animal {
  constructor(protected birthDate: Date) { }
}
class Bird extends Animal {
  constructor(public name: string) {
    super(new Date());
  }
}

O super √© basicamente uma refer√™ncia √† superclasse. Ao ser invocado como uma fun√ß√£o, est√° invocando o construtor da superclasse.

* interfaces  = Interface √© um molde de uma Classe, em outras palavras, uma declara√ß√£o de atributos e/ou m√©todos que uma Classe deve possuir. Ela serve para nomear e parametrizar atributos e m√©todos de uma Classe, por√©m n√£o define seus valores ou implementa√ß√µes. Interfaces s√£o uma forma eficiente de definir um ‚Äúcontrato de c√≥digo‚Äù, ou seja, aquilo que voc√™ espera que seja implementado dentro do seu c√≥digo.

EX:

interface Animal {
  name: string;
  age: number;

  getBirthDate(): Date;
}

class Bird implements Animal {
  constructor(
    public name: string,
    private birthDate: Date) {}

  get age() {
    var timeDiff = Math.abs(Date.now() - new Date(this.birthDate).getTime());
    return Math.floor(timeDiff / (1000 * 3600 * 24) / 365.25);
  }

  getBirthDate() { return this.birthDate; }

  fly() { console.log(`${this.name} est√° voando!`); }
}

const parrot = new Bird(
  'Papagaio',
  new Date(Date.parse('Aug 16, 2015')),
);

console.log(parrot.age);
parrot.fly();

/*
Sa√≠da (c√≥digo executado em Mar/2022):
6
Papagaio est√° voando!
*/

Quando utilizamos interfaces, queremos garantir que alguns atributos e m√©todos existam, sem se importar com o que fazem. √â mais um ‚Äúme arranja alguma entidade que tenha o m√©todo x, pois eu vou precisar chamar x, e se ele n√£o existir vai dar erro‚Äù.

J√° quando utilizamos a heran√ßa, disponibilizamos n√£o s√≥ um contrato, mas uma base j√° implementada de c√≥digo que funciona, de forma que apenas vamos especializar esta base de c√≥digo adicionando novas funcionalidades.

Existe uma forma de criar classes que precisam obrigatoriamente implementar alguns m√©todos em espec√≠fico, as chamadas classes abstratas, que voc√™ conhecer√° na pr√≥xima aula üòâ.

Resumindo, quando a classe A implementa a interface I, ela deve implementar todos os m√©todos declarados em I e possuir todos os atributos de I. Quando a classe A herda da classe B, ela j√° herda todos os m√©todos e atributos p√∫blicos ou protegidos implementados na classe B.

Perceba a diferen√ßa entre interfaces e classes, quando a classe Student implementa a interface IPerson, ela deve implementar e possuir todos os m√©todos e atributos dessa interface. Quando as classes Teacher e Player herdam da classe Person, elas j√° herdam todos os m√©todos e atributos p√∫blicos ou protegidos implementados na classe Person.

* type alias x interface 

Type Aliases: facilitando a refer√™ncia a tipos complexos
Type Aliases s√£o uma forma de criar um tipo personalizado em Typescript. Com eles, voc√™ pode dar um nome novo para um tipo existente, facilitando a sua vida na hora de lidar com tipos complexos. Pensa naquele tipo que √© um verdadeiro bicho de sete cabe√ßas e que voc√™ precisa usar o tempo todo‚Ä¶ Com o Type Alias, voc√™ pode dar um nome mais amig√°vel e usar ele sem dor de cabe√ßa.

Exemplo
* Imagine que voc√™ est√° criando um jogo de RPG e precisa definir um tipo para os personagens. Para isso, voc√™ pode usar o Type Alias. Por exemplo:

EX:

type Personagem = {
  nome: string;
  nivel: number;
  classe: string;
};

Nesse exemplo, criamos um tipo chamado Personagem que possui tr√™s propriedades: nome (do tipo string), nivel (do tipo number) e classe (tamb√©m do tipo string).

* Com esse Type Alias, voc√™ pode tipar vari√°veis ou par√¢metros de fun√ß√£o do tipo Personagem de forma mais simples, sem precisar digitar toda a defini√ß√£o do tipo sempre que for us√°-lo.

Por exemplo:

EX:

function mostrarPersonagem(personagem: Personagem) {
  console.log(`Nome: ${personagem.nome}, N√≠vel: ${personagem.nivel}, Classe: ${personagem.classe}`);
}

const meuPersonagem: Personagem = {
  nome: 'Aragorn',
  nivel: 10,
  classe: 'Guerreiro'
};

mostrarPersonagem(meuPersonagem); // "Nome: Aragorn, N√≠vel: 10, Classe: Guerreiro"

Nesse exemplo, criamos uma fun√ß√£o chamada mostrarPersonagem que recebe um par√¢metro do tipo Personagem. Em seguida, criamos uma vari√°vel meuPersonagem do tipo Personagem com algumas propriedades.

Ao chamar a fun√ß√£o mostrarPersonagem passando a vari√°vel meuPersonagem como par√¢metro, a fun√ß√£o imprime na tela as informa√ß√µes do personagem de forma organizada.

Com o uso do Type Alias, √© poss√≠vel simplificar a defini√ß√£o de tipos complexos e tornar o c√≥digo mais leg√≠vel e f√°cil de entender.

Mas e se quisermos adicionar um m√©todo para o nosso personagem, como atacar? N√£o d√° para adicionar esse tipo de defini√ß√£o em um Type Alias.

A√≠ √© que entra a interface! Atrav√©s dela, podemos definir n√£o s√≥ propriedades, mas tamb√©m m√©todos que o personagem deve possuir.

As Interfaces s√£o como contratos que os objetos e classes devem seguir. Com elas, voc√™ pode definir m√©todos e propriedades que precisam ser implementados obrigatoriamente. √â como se voc√™ estivesse dizendo: ‚ÄúEi, objeto ou classe, voc√™ precisa ter isso aqui, sen√£o n√£o vai rolar‚Äù.

* Voltando no exemplo anterior, vimos que a solu√ß√£o para o nosso Personagem ter defini√ß√µes de m√©todos √© migrarmos de Type Alias para interface. √â como se fosse a roupa nova dele, mas em vez de ficar mais estiloso, o nosso c√≥digo fica mais organizado e bem estruturado. N√£o d√° para negar que √© um upgrade bem importante, n√©?

Vamos ao exemplo:

EX:

interface Personagem {
  nome: string;
  nivel: number;
  classe: string;
  atacar(): void;
  defender(): void;
}

Nesse exemplo, definimos uma interface chamada Personagem com algumas propriedades e m√©todos que um personagem deve ter. Al√©m do que j√° existia na vers√£o Type Alias, ele deve implementar dois m√©todos: atacar e defender. Tamb√©m perceba que a sintaxe mudou um pouco entre as duas vers√µes.

* Agora, vamos supor que queremos criar uma classe Guerreiro que implemente essa interface. Para isso, basta fazer o seguinte:

EX:

class Guerreiro implements Personagem {
  nome = 'Kratos';
  nivel = 99;
  classe = 'Guerreiro da Justi√ßa';
  
  atacar() {
    console.log('Kratos usou a L√¢mina do Caos! Inimigo derrotado!');
  }
  
  defender() {
    console.log('Kratos levantou o escudo e bloqueou o ataque!');
  }
}

Nessa classe, implementamos todos os m√©todos e propriedades da interface Personagem. Ou seja, ela segue o contrato definido pela interface.

* Agora, podemos criar um objeto do tipo Guerreiro e utilizar os m√©todos definidos na interface:

EX:

const meuGuerreiro: Personagem = new Guerreiro();
meuGuerreiro.atacar(); // "Kratos usou a L√¢mina do Caos! Inimigo derrotado!"
meuGuerreiro.defender(); // "Kratos levantou o escudo e bloqueou o ataque!"

* Composi√ß√£o

Para compreender a composi√ß√£o precisamos pensar no relacionamento entre objetos/classes. Por exemplo, na rede social uma conta tem perfil, tem foto e tem texto. Veja abaixo como ficaria em um diagrama.

diagrama-composicao

Na imagem acima, √© poss√≠vel notar que perfil, foto e texto est√£o contidos em conta da rede social, ou seja, estabelece-se uma rela√ß√£o de depend√™ncia que se voc√™ remover a classe principal (conta) a classe secund√°ria (perfil) deixar√° de fazer sentido, pois √© necess√°rio que seu perfil esteja vinculado a uma conta.

Portanto, o segredo para entender se existe rela√ß√£o entre duas classes √© se perguntar:

‚ÄúA classe Secund√°ria (perfil) est√° contida na classe Principal (conta)?‚Äù.

Se a resposta for sim, voc√™ tem uma composi√ß√£o. üéâ

Anota a√≠ üñä: A composi√ß√£o de objetos/classes √© uma forma de combinar objetos ou tipos de dados para construir sua estrutura.

Agora voc√™ deve estar se perguntando:

ü§î Qual a diferen√ßa entre composi√ß√£o e heran√ßa?

A heran√ßa tem por caracter√≠stica obter todas as propriedades da classe principal. Com isso, voc√™ obt√©m todos os atributos e m√©todos, deixando a classe secund√°ria mais especializada e espec√≠fica. Isso quer dizer que se voc√™ precisar alterar algo na classe principal voc√™ vai refletir isso na sua classe secund√°ria.

* Por outro lado, a composi√ß√£o permite que voc√™ realize altera√ß√µes na classe principal sem afetar as demais envolvidas ou correr o risco de comprometer algum comportamento.

Veja um exemplo no c√≥digo abaixo e acompanhe a explica√ß√£o.

EX:

class Profile {
  private name: string;
  private email: string;

  public setName(name: string) {
    this.name = name;
  }

  public setEmail(email: string) {
    this.email = email;
  }

  public toString(): string {
    return `name - [${this.name}] - email - [${this.email}]`;
  }
}

class SocialMediaAccount {
  // Cria nossa composi√ß√£o com o perfil
  private profile = new Profile();

  public editProfile(name: string, email: string) {
    this.profile.setName(name);
    this.profile.setEmail(email);
  }

  public printProfile() {
    console.log(this.profile.toString());
  }
}

const socialMediaAccount = new SocialMediaAccount();
socialMediaAccount.editProfile('Manuella', 'manu@trybe.com');
socialMediaAccount.printProfile();

No c√≥digo acima, voc√™ possui a classe Profile que possui os m√©todos respons√°veis por atualizar o nome e email do perfil. Em seguida, temos uma classe SocialMediaAccount que vai instanciar a classe Profile e ser utilizada no m√©todo editProfile para voc√™ editar o nome e email na respectiva conta da rede social. A a√ß√£o de utilizarmos a classe do perfil (Profile) para compor a classe de conta da rede social (SocialMediaAccount) √© conhecida por composi√ß√£o.

Dessa forma, voc√™ tem a liberdade de realizar as altera√ß√µes necess√°rias na classe principal(SocialMediaAccount) que n√£o vai afetar diretamente a classe secund√°ria (Profile). Al√©m disso, note que se voc√™ remover a classe SocialMediaAccount o perfil da pessoa vai perder o sentido, pois um perfil obrigatoriamente precisa estar vinculado a uma conta. Conclu√≠mos assim que Profile tem depend√™ncia da exist√™ncia de uma conta na rede social.

* Agrega√ß√£o

Na agrega√ß√£o precisamos pensar no relacionamento entre objetos/classes, assim como na composi√ß√£o. No entanto √© um relacionamento que far√° parte e n√£o obrigatoriamente depender√° de outro objeto/classe para continuar existindo.

Veja esse conceito sendo aplicado no c√≥digo abaixo:

EX:

class Friend {
  private nickname: string;

  public getNickname(): string {
    return this.nickname;
  }

  public setNickname(nickname: string) {
    this.nickname = nickname;
  }
}

class SocialMediaAccount {
  private friends = new Array<Friend>();

  public addFriend(friend: Friend) {
    this.friends.push(friend);
  }

  public printFriends() {
    this.friends.map((friend) => console.log(friend));
  }
}

const socialMediaAccount = new SocialMediaAccount();

const friendCarol = new Friend();
friendCarol.setNickname('Carol');

const friendFernando = new Friend();
friendFernando.setNickname('Fernando');

socialMediaAccount.addFriend(friendCarol);
socialMediaAccount.addFriend(friendFernando);
socialMediaAccount.printFriends();

No c√≥digo acima, voc√™ possui a classe Friend que possui os m√©todos respons√°veis por atualizar o nickname de uma pessoa amiga. Em seguida, voc√™ tem uma classe SocialMediaAccount que possui um array de pessoas amigas e possui o m√©todo addFriend para adicionar novas pessoas amigas na respectiva conta da rede social. Por fim, voc√™ inst√¢ncia a classe SocialMediaAccount para representar uma conta e a classe Friend realizando a atualiza√ß√£o de cada nickname para representar as duas pessoas amigas que voc√™ gostaria de adicionar na conta.

Agora, note que se voc√™ remover a classe SocialMediaAccount a classe Friend vai continuar fazendo sentido, pois se voc√™ deletar uma conta da pessoa usu√°ria ainda ser√° poss√≠vel atualizar pessoas amigas ou essas pessoas amigas serem adicionadas em contas de outras pessoas usu√°rias.

Portanto, na agrega√ß√£o os objetos podem existir sem depender do outro objeto, por outro lado, na composi√ß√£o os objetos dependem da exist√™ncia do outro objeto.

* desafio final:

Voc√™ precisa, de forma eficiente, criar entidades que representem pessoas f√≠sicas e pessoas jur√≠dicas, compartilhando alguns elementos em comum, tais como nome e endere√ßo, mas com elementos espec√≠ficos de cada uma delas, como CPF e CNPJ.

Al√©m disso, voc√™ precisa criar uma interface para contratos, que devem possuir cl√°usulas e devem poder ser assinados por pessoas diversas.

O c√≥digo para a resolu√ß√£o do problema est√° logo abaixo, mas antes, confira o motivo de usarmos interface e/ou classe (heran√ßa):

Interface Contract:

Ser√° o nosso contrato, algo que nos guiar√° em rela√ß√£o √†s regras de neg√≥cio;
√â importante ser utilizada quando sabemos quais atributos e/ou m√©todos devem ser utilizados e s√£o imprescind√≠veis para a implementa√ß√£o da nossa classe;
As interfaces n√£o necessariamente cont√™m todos os elementos que precisam ser implementados em uma classe. Contudo, elas funcionam como um guia para o cumprimento das regras de neg√≥cio. Ainda √© poss√≠vel definir m√©todos e atributos adicionais, ou ainda criar v√°rias interfaces, cada uma relacionada a regras espec√≠ficas, e implement√°-las em uma mesma classe;
No exemplo abordado, os atributos subject, clause, signatories e o m√©todo describe s√£o importantes para a regra em quest√£o e est√£o sendo implementados na classe SalesContract. Entretanto, al√©m desses elementos, outros m√©todos tamb√©m s√£o implementados. O que nos mostra, que por mais que venhamos a definir um contrato com elementos espec√≠ficos, ainda temos a flexibilidade de fazer ajustes e implementa√ß√µes.
Heran√ßa - classe Person:

Permite a reutiliza√ß√£o do c√≥digo, visto que todas as declara√ß√µes da classe m√£e (superclasse), com exce√ß√£o de elementos privados, s√£o herdadas;
Aumenta o acoplamento do c√≥digo, pois altera√ß√µes na implementa√ß√£o em uma superclasse podem afetar as suas subclasses. Por exemplo, a adi√ß√£o, remo√ß√£o ou altera√ß√£o de m√©todos e propriedades pode provocar bugs caso n√£o sejam planejadas com cautela;
No exemplo abordado, as classes NaturalPerson e LegalPerson herdam de Person. Observe que ambas as classes filhas mant√™m o padr√£o de receberem par√¢metro name e de reutilizar o m√©todo getter name. Este √© um exemplo reduzido, mas que nos mostra o quanto a heran√ßa pode ser √∫til.

EX:

interface Contract {
  subject: string;
  clauses: string[];
  signatories: Person[];
  describe(): void;
}

class Person {
  private _name;
  constructor(name: string) {
    this._name = name;
  }
  get name() { return this._name; }
}

class NaturalPerson extends Person {
  private _cpf;
  constructor(name: string, cpf: string) {
    super(name);
    this._cpf = cpf;
  }
  get cpf() { return this._cpf; }
}

class LegalPerson extends Person {
  private _cnpj;
  constructor(name: string, cnpj: string) {
    super(name);
    this._cnpj = cnpj;
  }
}

class SalesContract implements Contract {
  private _signatories: Person[];
  private _clauses: string[];

  constructor() {
    this._signatories = [];
    this._clauses = [];
  }

  get signatories() { return [...this._signatories]; }
  get clauses() { return [...this._clauses]; }
  get subject() { return "Sales"; }

  sign(signatory: Person) { this._signatories.push(signatory); }
  addClause(clause: string) {
    if (this._signatories.length > 0) return;
    this._clauses.push(clause);
  }

  describe() {
    console.log('--------------------');
    console.log(`Contrato: ${this.subject}`);
    this.clauses.forEach((clause) => { console.log(`Cl√°usula: ${clause}`) });
    this.signatories.forEach((signatory) => { console.log(`Assinado por: ${signatory.name}`) });
    console.log('--------------------\n');
  }
}

const s1 = new SalesContract();
const pp1 = new NaturalPerson('Tony', '123456789');
const pp2 = new NaturalPerson('Lilly', '987654321');
const lp = new LegalPerson('International Sales SA', '23961237162378');

s1.describe();
s1.addClause('Foo');
s1.addClause('Bar');
s1.describe();
s1.sign(pp1);
s1.sign(pp2);
s1.describe();
s1.addClause('Baz');
s1.sign(lp);
s1.describe();

/*
Sa√≠da:
--------------------
Contrato: Sales
--------------------

--------------------
Contrato: Sales
Cl√°usula: Foo
Cl√°usula: Bar
--------------------

--------------------
Contrato: Sales
Cl√°usula: Foo
Cl√°usula: Bar
Assinado por: Tony
Assinado por: Lilly
--------------------

--------------------
Contrato: Sales
Cl√°usula: Foo
Cl√°usula: Bar
Assinado por: Tony
Assinado por: Lilly
Assinado por: International Sales SA
--------------------
 */
 
Existem muitas valida√ß√µes que n√£o foram feitas, visto que √© s√≥ um exemplo, mas j√° d√° pra ter uma ideia de como os conceitos de heran√ßa e interfaces facilitam a vida, n√£o √©?





