# PROGRAMA√á√ÉO ORIENTADA A OBJETOS.

* classe  = Classe √© o primeiro dos conceitos. Ela √© utilizada para determinar algo gen√©rico. Na programa√ß√£o orientada a objetos, toda classe tem como finalidade modelar com precis√£o a representa√ß√£o de uma entidade do mundo real. Um exemplo de uma classe √© o conceito Pessoa. Existem v√°rias pessoas no mundo, sendo voc√™ e eu duas delas, e por mais que sejamos pessoas diferentes, pertencemos a mesma classe Pessoa. Agora repare que eu mencionei que somos pessoas diferentes. Isto quer dizer que somos objetos diferentes de uma mesma classe. Objeto (ou inst√¢ncia da classe) √© algo espec√≠fico. (OBS: IMAGEM DETALHANDO COMO EXEMPLO "classes-vs-objetos.png"). 

Complementando as defini√ß√µes da mesma p√°gina citada anteriormente: Uma classe √© uma estrutura que abstrai um conjunto de objetos com caracter√≠sticas similares, e um objeto √© uma inst√¢ncia (ou seja, um exemplar) de uma classe. Uma classe define o comportamento de seus objetos - atrav√©s de m√©todos - e os estados poss√≠veis destes objetos - atrav√©s de atributos.

* atributos e m√©todos  = Dentro das classes e dos objetos existem atributos e m√©todos. Exemplos de atributos de uma Pessoa s√£o: a altura e a massa da Pessoa. Observe que a defini√ß√£o dos atributos √© feita na classe, mas os valores s√£o do objeto. Todas as pessoas possuem uma altura e uma massa, portanto a defini√ß√£o fica na classe, mas minha altura √© diferente da sua, e minha massa √© diferente da sua, portanto os valores s√£o de cada objeto.

Se um atributo representa um valor, como a altura de algu√©m, um m√©todo (ou mensagem) retrata uma a√ß√£o. Por exemplo, uma pessoa pode dormir ou acordar. Observe que, da mesma forma que o atributo, o m√©todo √© algo que existe para a classe, mas cada objeto pode realiz√°-lo de forma diferente, √∫nica. Todas as pessoas dormem, mas eu posso dormir de lado e voc√™ de bru√ßos, por exemplo.

Trazendo para programa√ß√£o: um atributo √© uma vari√°vel criada numa classe, e um m√©todo √© uma fun√ß√£o criada numa classe. Um m√©todo que merece destaque √© o m√©todo construtor. Ele √© rodado automaticamente na cria√ß√£o de um objeto, e serve para inicializar alguns atributos e chamar alguns m√©todos. Por exemplo, no nascimento de uma pessoa, os atributos altura e massa s√£o definidos, e o m√©todo chorar √© chamado.

# pilares da programa√ß√£o orientada a objetos:

* Abstra√ß√£o:

O pilar abstra√ß√£o indica que voc√™ n√£o necessariamente precisa saber os detalhes de como algo funciona. Pense por exemplo em uma c√¢mera (como a do seu celular). Voc√™ provavelmente n√£o sabe todos os detalhes de como ela funciona, mas para operar, voc√™ apenas precisa apontar, conferir no visor e apertar o bot√£o. Uma atualiza√ß√£o pode mudar detalhes do funcionamento da c√¢mera, mas sua opera√ß√£o vai continuar essencialmente a mesma.

* Encapsulamento:

O pilar encapsulamento faz com que alguns atributos s√≥ possam ser acessados e/ou modificados dentro da classe. Pense, por exemplo, na sua massa. Voc√™ n√£o pode, diretamente, mudar sua massa. N√£o √© poss√≠vel voc√™ pensar ‚Äúvou ter x quilos‚Äù e instantaneamente passar a ter essa massa. Entretanto, algumas interfaces para alterar essa massa s√£o expostas. Voc√™ pode comer para aumentar a massa, e dentro de voc√™, sem que possa ditar como seu corpo ir√° se comportar, ele vai absorver as calorias do alimento. Ou seja, n√£o √© poss√≠vel mudar diretamente a sua massa, pois ela √© um atributo privado da classe Pessoa, mas existem m√©todos na classe Pessoa que permitem que a massa seja alterada de forma interna, como o m√©todo comer.

* Heran√ßa:

O pilar heran√ßa permite que classes filhas, que herdam m√©todos e atributos de outra classe (super classe), sejam criadas. Pense em uma classe Pessoa, com os atributos nome e altura e com o m√©todo sonhar. A partir dessa classe Pessoa, eu posso criar uma outra classe, chamada PessoaCantora , que herda de Pessoa. Ou seja, j√° vir√° automaticamente com os atributos nome e altura e com o m√©todo sonhar, mas poder√° ter outro m√©todo exclusivo dela, como cantar.

* Polimorfismo:

O pilar polimorfismo permite que coisas diferentes aconte√ßam ao chamarmos objetos de classes filhas distintas de uma mesma super classe. Por exemplo, pense que existe a classe Pessoa, que possui um m√©todo dormir, s√≥ que esse m√©todo n√£o √© implementado (n√£o possui nenhum c√≥digo). Ent√£o s√£o criadas duas outras classes: PessoaQueDormeDeBrucos e PessoaQueDormeDeLado, e ambas implementam o m√©todo dormir conforme seus nomes. Se em algum lugar do c√≥digo eu espero um objeto da classe Pessoa, eu posso perfeitamente passar um objeto de uma classe filha (j√° que ele herda tudo que tem na classe Pessoa), ou seja, eu posso passar tanto um objeto da classe PessoaQueDormeDeBrucos quanto da classe PessoaQueDormeDeLado. Como o c√≥digo esperava um objeto da classe Pessoa, qualquer um dos dois servem, mas se o m√©todo dormir for chamado, ele ir√° se comportar de forma diferente.

* Exemplo de uma classe, com atributos e m√©todo em typescript:

class Person {
  name: string;
  height: number;
  weight?: number; // o caractere "?" indica um atributo opcional

  constructor(n: string, h: number, w?: number) {
    console.log(`Creating person ${n}`);
    this.name = n;
    this.height = h;
    this.weight = w;
  }

  sleep() {
    console.log(`${this.name}: zzzzzzz`);
  }
}

const p1 = new Person('Maria', 171, 58);
// aqui estamos passando somente dois par√¢metros, atente-se ao valor do atributo p2.weight
const p2 = new Person('Jo√£o', 175);
console.log(p1.name, p1.height, p1.weight);
console.log(p2.name, p2.height, p2.weight);
p1.sleep();
p2.sleep();

/*
Sa√≠da:
Creating person Maria
Creating person Jo√£o
Maria 171 58
Jo√£o 175 undefined
Maria: zzzzzzz
Jo√£o: zzzzzzz
*/

Para criar uma classe, basta utilizar a palavra reservada class, seguida do nome da classe e um par de chaves.

Dentro das chaves podemos criar atributos: digitando o nome do atributo e seu tipo.

Ainda entre as chaves da classe podemos criar m√©todos: digitando seu nome, os par√™nteses com os par√¢metros e as chaves com o corpo, assim como uma fun√ß√£o normal, s√≥ que sem precisar do function.

Observe que com a classe Person, podemos criar dois (ou mais) objetos (duas pessoas) diferentes, p1 e p2.

O m√©todo construtor (constructor) √© chamado assim que utilizamos a sintaxe de cria√ß√£o de um objeto com a palavra reservada new. O construtor recebe os par√¢metros n, h e w, que est√£o abreviados apenas para deixar expl√≠cito que o nome dos par√¢metros n√£o √© diretamente relacionado ao nome dos atributos que eles populam. Normalmente, eles teriam o mesmo nome (ou seja, n seria name, etc).

Um ponto muito importante √© o uso da palavra reservada this. Lembra que voc√™ aprendeu que pode criar duas pessoas diferentes?

Ou seja, elas s√£o dois objetos de uma mesma classe e ambas compartilham dos mesmos atributos, mas com valores diferentes.

O this serve justamente para representar o objeto em si. Quando, no construtor, escrevemos this.name = n, estamos dizendo que o atributo name do objeto que chamou o m√©todo ir√° possuir o valor n.

Quando p1 √© criada, this se refere a p1, logo, n e name passam a ser ‚ÄúMaria‚Äù.

E quando p2 √© criada, this se refere a p2, logo, n e name passam a ser ‚ÄúJo√£o‚Äù. Do lado de fora usamos a sintaxe objeto.atributo, mas como do lado de dentro n√£o temos como saber qual √© o objeto, precisamos utilizar a sintaxe this.atributo.

O mesmo se aplica aos m√©todos, como √© poss√≠vel observar com o sleep: ao chamarmos, no final do arquivo, p1.sleep(), o m√©todo sleep sabe que o this se refere a p1, portanto this.name √© ‚ÄúMaria‚Äù.

Ao chamarmos p2.sleep(), o this se refere a p2, e p2.name √© ‚ÄúJo√£o‚Äù.

* encapsulamento  = A ideia √© garantir que os processos internos da classe possam ocorrer sem que a pessoa que a utiliza altere atributos de forma indevida, o que poderia ocasionar em problemas no funcionamento. Para isso existem os modificadores de visibilidade do atributo, sendo os principais o public, o private, o protected e o readonly. O protected vai ser apresentado juntamente com heran√ßa.

Os atributos criados sem modificadores de visibilidade s√£o p√∫blicos por padr√£o, e podem ser acessados e alterados tanto dentro quanto fora da classe. Se quisermos deixar expl√≠cito que n√£o esquecemos de colocar a visibilidade adequada, podemos utilizar a palavra reservada public na frente do atributo.

J√° os atributos criados com o modificador private s√≥ podem ser lidos e modificados dentro da classe. Isso significa que se voc√™ tentar utilizar a nota√ß√£o objeto.atributo do lado de fora das chaves que delimitam a cria√ß√£o da classe, voc√™ ter√° um erro do compilador.

Por fim, os atributos criados com o modificador readonly podem ser lidos em qualquer lugar, mas s√≥ podem ser inicializados uma vez, no construtor. Apesar desse modificador n√£o estar exatamente ligado a Orienta√ß√£o a Objetos, √© importante entender seu funcionamento üòâ.

Para alterar atributos privados fora de uma classe, utilizamos os m√©todos. Eles validam as leituras e altera√ß√µes, de forma a n√£o comprometer o funcionamento da classe. Por exemplo, voc√™ pode ter uma classe Pessoa com o atributo dataDeNascimento privado, e possuir um m√©todo para mudar esta data de nascimento de forma a validar se √© digitada uma data v√°lida. Para ler os valores dos atributos, podemos criar os m√©todos getters, e para modificar, os m√©todos setters. √â importante salientar que atributos privados n√£o s√£o obrigados a ter getters e setters. Eles s√≥ precisam destes m√©todos caso seja necess√°rio alter√°-los diretamente, podendo garantir uma valida√ß√£o do dado que foi passado. Veremos mais sobre isso na parte de sintaxe.

EX:

class Person {
  name: string;
  private _weight: number;
  private _age: number;
  readonly height: number;

  constructor(name: string, height: number, weight: number, age: number) {
    this.name = name;
    this._weight = weight;
    this._age = age;
    this.height = height;
  }

// esta sintaxe permite acessar o valor retornado via person.getWeight()
  getWeight() {
    return this._weight;
  }

// esta sintaxe permite acessar o valor retornado via person.age (como se fosse um atributo normal)
  get age() {
    return this._age;
  }

// do mesmo modo, esta sintaxe permite modificar o valor com uma simples atribui√ß√£o: person.age = 42
// mesmo que esteja ocorrendo uma valida√ß√£o internamente
  set age(newValue: number) {
    if (newValue >= 0 && newValue < 200) {
      this._age = newValue;
    }
  }

  birthday() {
    this._age += 1;
  }

}

const p1 = new Person('Maria', 171, 58, 19);
const p2 = new Person('Jo√£o', 175, 66, 18);

* Vamos agora a um exemplo de sintaxes que s√£o v√°lidas neste contexto:

EX:

// Altera√ß√£o direta de vari√°vel p√∫blica
p1.name = 'Mariah';
// Acesso direto a vari√°vel p√∫blica
console.log(p1.name);
// Acesso a m√©todo p√∫blico que manipula atributo privado
console.log(p1.getWeight());
// Acesso a m√©todo com getter para manipular atributo privado como se fosse p√∫blico
console.log(p2.age);
// Acesso a m√©todo p√∫blico que manipula atributo privado
p2.birthday();
console.log(p2.age);
// Acesso a m√©todo com setter para manipular atributo privado como se fosse p√∫blico
p2.age = 17;
console.log(p2.age);
// Leitura de atributo readonly
console.log(p1.height);

/*
Sa√≠da:
Mariah
58
18
19
17
171
*/

* Observe que h√° uma valida√ß√£o de dados no set age. √â para este tipo de coisa que utilizamos atributos privados: para validar altera√ß√µes nos dados. Considere, ap√≥s o c√≥digo anterior, rodar o seguinte c√≥digo

EX:

p2.age = 300;
console.log(p2.age);
// Sa√≠da: 17

A idade da pessoa p2 continua 17, pois a valida√ß√£o no set age impede que existam pessoas com 300 anos de idade. Esse √© o poder do encapsulamento.

* Agora um exemplo de sintaxes que s√£o inv√°lidas neste contexto:

EX:

// Acesso externo √† classe a atributo privado
p1._weight;
p1._weight = 1;
// Acesso a atributo inexistente
p1.weight;
p1.weight = 1;
// Escrita em atributo readonly
p1.height = 1;

* Agora que voc√™ sabe os fundamentos de POO, vamos ver uma poss√≠vel solu√ß√£o para o problema inicial?

* Primeiramente vamos criar a classe Email. Ela ser√° respons√°vel por guardar os dados do e-mail na forma de atributos. Al√©m disso, Email possui alguns m√©todos, sendo o mais importante deles o get content, que retorna uma string formatada com todo o corpo do e-mail.

EX:

class Email {
  private _from: string;
  private _to: string;
  private _message: string;
  private _subject: string;

  constructor(
    from: string,
    to: string,
    subject: string,
    message: string,
  ) {
    this._from = from;
    this._to = to;
    this._message = message;
    this._subject = subject;
  }

  set subject(newSubject: string) {
    if (newSubject.length <= 40) this._subject = newSubject;
  }

  get subject(): string {
    return this._subject;
  }

  get from(): string { return this._from; }

  get to(): string { return this._to; }

  get content(): string {
    return `
    From ${this._from} to ${this._to}
    ${this.subject}

    ${this._message}`;
  }
}

√â interessante observar o uso do encapsulamento na manipula√ß√£o dos atributos, com destaque para a valida√ß√£o do comprimento do campo assunto.

* Em seguida vem a cria√ß√£o da classe MailList, que representa uma lista de e-mails. Esta √© uma classe muito interessante, pois nos permite manter todos os e-mails correlacionados em um √∫nico objeto. Al√©m disso, nos permite filtrar os e-mails da lista de forma simplificada, utilizando abstra√ß√£o.

Uma modelagem de representa√ß√£o gen√©rica de um email

Todo e-mail criado deve possuir os campos:

Endere√ßo de e-mail da pessoa remetente

Endere√ßo de e-mail da pessoa destinat√°ria

Assunto da mensagem, que n√£o pode ter mais de 20 caracteres

Mensagem

Todo e-mail criado deve ter sua representa√ß√£o textual, que combina todos os dados em uma string √∫nica

Uma representa√ß√£o gen√©rica de uma lista de e-mails (mailList)

A lista de e-mails deve ser capaz de retornar e-mails filtrados por pessoa remetente, destinat√°ria ou por assunto.

EX:

class MailList {
  // Essa sintaxe no construtor √© chamada `Parameter Properties`
  // √â um atalho para declarar e automaticamente atribuir o valor que ser√° recebido via par√¢metro ao atributo privado `mailList`
  constructor(private mailList: Email[] = []) { }

  get all(): Email[] { return this.mailList; }

  getEmailsBySender(mailAddress: string): Email[] {
    return this.mailList.filter((mail) => mail.from === mailAddress);
  }

  getEmailsTo(mailAddress: string): Email[] {
    return this.mailList.filter((mail) => mail.to === mailAddress);
  }

  getEmailsBySubject(searchString: string): Email[] {
    return this.mailList
      .filter((mail) => mail.subject.indexOf(searchString) !== -1);
  }

  addEmail(newMail: Email): void { this.mailList.push(newMail); }

  removeEmail(mailToRemove: Email): void {
    // note que como essa √© uma compara√ß√£o de objetos, esse filter s√≥ funcionar√° se a refer√™ncia de `mail` e `mailToRemove` for a mesma
    this.mailList = this.mailList.filter((mail) => mail !== mailToRemove);
  }
}

Com isso conseguimos criar listas de e-mails diferentes, cada uma possuindo e-mails diferentes. Essas listas j√° s√£o criadas com a possibilidade de filtrarmos os e-mails, o que √© muito √∫til.





