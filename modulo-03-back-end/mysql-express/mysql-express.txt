# INTEGRAR O EXPRESS COM O MYSQL ATRAV√âS DO DOCKER:

* primeiro criar as pastas, instalar o node no projeto, criar arquivo "server.js" que vai iniciar o express, instalar o nodemon e definir os scripts no arquivo package.json.

EX:
mkdir trybecash-api
cd trybecash-api
npm init -y
npm i nodemon@2.0.15 --save-dev --save-exact
mkdir src   = nessa pasta criar o arquivo server.js.
mkdir tests

* depois no diret√≥rio trybecash-api criar o arquivo "docker-compose.yml" para subir no docker a imagem mysql e dentro dela escrever o c√≥digo para subir a imagem no constainer.

EX:

version: '3'
services:
  database:
    image: mysql:8.0.29
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: trybecashdb
    ports:
      - "33060:3306"
      
* No arquivo docker-compose.yaml criado, foi definido um servi√ßo chamado database. Esse servi√ßo inicializar√° um container Docker com a imagem do Servidor MySQL vers√£o 8.0.29.

* O par√¢metro restart define a pol√≠tica de rein√≠cio do container como always. Assim, o container sempre ser√° reiniciado automaticamente em caso de parada. Na se√ß√£o environment foi definido o valor de duas vari√°veis dentro do container:
MYSQL_ROOT_PASSWORD: Essa vari√°vel define a senha do usu√°rio root do MySQL (ser√° a senha que utilizaremos para acessar o MySQL);
MYSQL_DATABASE: Essa vari√°vel define o nome do banco de dados que ser√° criado ao iniciar MySQL, caso ele n√£o exista.

* J√° a se√ß√£o ports est√° vinculando uma porta do seu computador local (a porta 33060) a uma porta dentro do container (a porta 3306).

* Para iniciar nossos containers, precisaremos criar um arquivo chamado "Dockerfile" na raiz do projeto, com o seguinte conte√∫do:

EX:

FROM node:16

# o expose serve apenas para sinalizar em qual porta rodaremos o container
# a defini√ß√£o da porta se d√° no arquivo docker-compose.yaml
EXPOSE 3000

WORKDIR /

# aqui copiamos apenas o package.json e o package-lock.json, pois assim
# garantimos que quando as depend√™ncias forem instaladas, suas vers√µes n√£o v√£o ser alteradas.
COPY package*.json ./

RUN npm install

COPY . .

CMD [ "npm", "start" ]

* Ap√≥s a cria√ß√£o do Dockerfile, devemos configurar um container para rodar nossa aplica√ß√£o Node.js em nosso arquivo docker-compose.yaml. Dessa forma, garantimos que ambos os ambientes funcionar√£o corretamente. Feito isso vamos adicionar mais informa√ß√µes no arquivo "docker-compose.yml" que vai ficar assim:

EX:

version: '3'
services:
  node:
    # Faz o docker construir (build) de uma imagem personalizada
    # baseada no arquivo Dockerfile
    build: 
      dockerfile: ./Dockerfile
      context: .
    # Nome do container para facilitar execu√ß√£o
    container_name: trybecash_api
    # Restarta a imagem caso algo a fa√ßa parar
    restart: always
    # Diret√≥rio padr√£o de execu√ß√£o
    working_dir: /app
    # Lista de volumes (diret√≥rios) mapeados de fora para dentro do container
    volumes:
      # Monta o diret√≥rio atual, com todos os dados da aplica√ß√£o, dentro do diret√≥rio /app
      - ./:/app
    ports:
      # Exp√µe a porta padr√£o da aplica√ß√£o: altere aqui caso use outra porta
      # na nota√ß√£o porta_de_fora:porta_de_dentro
      - 3000:3000
    # Informa ao docker, para que o container node seja iniciado ap√≥s o container database
    depends_on:
      - "database"

  database:
    image: mysql:8.0.29
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: trybecashdb
    ports:
      - "33060:3306"
      
* Ap√≥s a cria√ß√£o dos arquivos com o conte√∫do apresentado. Comece inicializando o container em segundo plano com o uso do seguinte comando:

EX:

docker-compose up -d ou docker compose up -d

* depois disso abrir o mysql workbanch e adicionar a rede com o mesmo nome, porta e senha. Com isso precisamos criar os dados para o banco de dados e tem 2 formas para fazer isso, pegando o c√≥digo e colocando em uma query na workbanch ou criando um arquivo na pasta raiz do diret√≥rio "trybecash" e inicializando junto com o "docker-compose.yml".

EX: 

1 - primeira forma colocando o c√≥digo direto em uma query na workbench.

USE trybecashdb;

CREATE TABLE people (
    id INT NOT NULL AUTO_INCREMENT,
    first_name VARCHAR(45) NOT NULL,
    last_name VARCHAR(45) NOT NULL,
    email VARCHAR(60) NOT NULL,
    phone VARCHAR(20),
    PRIMARY KEY(id),
    UNIQUE(email)
);

CREATE TABLE transactions(
    id INT NOT NULL AUTO_INCREMENT,
    name VARCHAR(60) NOT NULL,
    description VARCHAR(100),
    price DECIMAL(10,2) NOT NULL,
    type INT NOT NULL,
    person_id INT NOT NULL,
    PRIMARY KEY(id),
    CONSTRAINT fk_transaction_person_id FOREIGN KEY (person_id)
    REFERENCES people(id)
);

CREATE TABLE logs(
    id INT NOT NULL AUTO_INCREMENT,
    event VARCHAR(100) NOT NULL,
    timestamp BIGINT NOT NULL,
    person_id INT NOT NULL,
    PRIMARY KEY(id),
    CONSTRAINT fk_logs_person_id FOREIGN KEY (person_id)
    REFERENCES people(id)
);

EX:

2 - criando um arquivo "trybecash_script.sql" na pasta raiz, colocando o mesmo c√≥digo para criar as tabelas dentro desse arquivo e anexando para iniciar junto ao docker-compose.yml. (adiciona s√≥ a parte volumes)

# version: '3'
# services:
#   database:
#     image: mysql:8.0.29
#     restart: always
#     environment:
#       MYSQL_ROOT_PASSWORD: root
#       MYSQL_DATABASE: trybecashdb
#     ports:
#       - "33060:3306"
    volumes:
      - ./trybecash_script.sql:/docker-entrypoint-initdb.d/trybecash_script.sql
      
* Pronto! Agora podemos subir nosso banco com as tabelas j√° criadas toda vez que inicializarmos o container! Para isso utilize o comando abaixo para derrubar e subir o container com a imagem MySQL novamente.

EX:

docker compose down && docker-compose up -d

* depois disso instalar os pacotes node do express e do mysql no projeto.

EX:

npm i express@4.17.1 mysql2@2.3.3 --save-exact

* criar um pasta no diret√≥rio "src" para o banco de dados chamado "db" e dentro dele o arquivo "connection.js" para fazer a conex√£o com o mysql utilizando a biblioteca mysql12. dentro do arquivo "connection.js" colocar os seguintes c√≥digos:

EX:

// src/db/connection.js

const mysql = require('mysql2/promise');

const connection = mysql.createPool({
  host: 'localhost',
  port: 33060,
  user: 'root',
  password: 'root',
  database: 'trybecashdb',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
});

module.exports = connection;

No trecho de c√≥digo acima estamos importando a biblioteca mysql2 com o recurso de promises. Isso permitir√° utilizar o MySQL de forma ass√≠ncrona com async/await. Em seguida, criamos uma constante connection que recebe um pool de conex√µes criado com a fun√ß√£o createPool.

Um pool de conex√µes √© um reposit√≥rio que cont√©m um conjunto de conex√µes estabelecidas previamente com o banco de dados. Essas conex√µes ser√£o reutilizadas durante a execu√ß√£o da aplica√ß√£o conforme a necessidade. Em outras palavras, quando uma opera√ß√£o no banco de dados for necess√°ria nossa aplica√ß√£o ir√°:

Requisitar uma conex√£o no pool de conex√µes;
Utilizar essa conex√£o para enviar uma opera√ß√£o SQL ao servidor MySQL;
Devolver a conex√£o para o pool de conex√µes ao final da opera√ß√£o com o MySQL;
Tornar a conex√£o dispon√≠vel para ser utilizada em requisi√ß√µes futuras.

host:  = O endere√ßo IP do MySQL	Como temos um container docker sendo executado em nossa m√°quina local, o valor ser√° localhost ou 127.0.0.1 (ambos s√£o equivalentes)

user:  =	O nome de usu√°rio que nossa aplica√ß√£o utilizar√° para acessar o MySQL, estamos utilizando o usu√°rio root do MySQL

port:  =	O n√∫mero da porta que nossa aplica√ß√£o utilizar√° para acessar o MySQL, estamos utilizando a porta 33060 (a porta do computador local que vinculamos com o container no docker compose)

password:  =	A senha do usu√°rio que nossa aplica√ß√£o utilizar√° para acessar o MySQL, estamos utilizando a senha root que foi definida na vari√°vel de ambiente MYSQL_ROOT_PASSWORD no docker compose criado anteriormente

database:  =	O nome do banco de dados MySQL, o qual queremos que nossa aplica√ß√£o realize uma conex√£o, estamos utilizando o nome do banco que foi definido na vari√°vel de ambiente MYSQL_DATABASE no docker compose

waitForConnections:  =  Determina qual ser√° a a√ß√£o da pool de conex√µes quando nenhuma conex√£o estiver dispon√≠vel na pool e quando o limite de cria√ß√£o de novas conex√µes tiver sido alcan√ßado, se o valor for true, ser√° criada uma fila de espera por conex√µes, caso contr√°rio a pool retornar√° uma callback com um erro. Caso este par√¢metro seja omitido, o valor padr√£o ser√° true

connectionLimit:  =  O n√∫mero m√°ximo de requisi√ß√µes de conex√£o que a pool criar√° de uma vez, caso este par√¢metro seja omitido, o valor padr√£o ser√° 10

queueLimit:  =  O n√∫mero m√°ximo de requisi√ß√µes de conex√£o que a pool ir√° enfileirar antes de retornar um erro, se o valor deste par√¢metro for igual a 0 significa que n√£o existe limite. Caso este par√¢metro seja omitido, o valor padr√£o ser√° 0

depois disso vamos criar os arquivos express para funcionar junto com o mysql, primeiro criamos o arquivo "app.js" e colocamos o seguinte c√≥digo.

EX:

// src/app.js

const express = require('express');

const app = express();

app.use(express.json());

module.exports = app;

* o arquivo "express.js" j√° est√° criado s√≥ vamos colocar o mesmo c√≥digo para iniciar o express, mas agora com uma parte a mais que √© para iniciar o a conex√£o com o mysql tamb√©m.

EX:

// src/server.js
const app = require('./app');
const connection = require('./db/connection');

const PORT = 3001;

app.listen(PORT, async () => {
  console.log(`API TrybeCash est√° sendo executada na porta ${PORT}`);

  // O c√≥digo abaixo √© para testarmos a comunica√ß√£o com o MySQL
  const [result] = await connection.execute('SELECT 1');
  if (result) {
    console.log('MySQL connection OK');
  }
});

Dentro da fun√ß√£o app.listen() foi adicionado um trecho de c√≥digo que executa a fun√ß√£o connection.execute(), que recebe como par√¢metro uma consulta SQL SELECT 1. Essa fun√ß√£o realiza uma conex√£o com o MySQL, executa o SQL passado como par√¢metro e recebe uma resposta que √© armazenada na constante result (note que o processo de desestrutura√ß√£o de vari√°veis est√° sendo utilizado! üòé).

Depois √© verificado com um if se o objeto result cont√©m alguma coisa e, em caso de positivo, √© impresso no console a mensagem MySQL connection OK.

* antes de avan√ßarmos, vamos refatorar nosso arquivo src/server.js para retirar o c√≥digo que utilizamos para testar se a comunica√ß√£o com o MySQL estava ocorrendo, pois esse c√≥digo n√£o ser√° mais √∫til para n√≥s de agora em diante. O arquivo dever√° estar assim:

EX:

// src/server.js

const app = require('./app');

const PORT = 3001;

app.listen(PORT, () => {
  console.log(`API TrybeCash est√° sendo executada na porta ${PORT}`);
});

* esse projeto vai ser feito pelo TDD ou seja orientado a testes. Ent√£o j√° vamos instalar o mocha, chai, chai-http e sinon.

EX:

npm i mocha@10.0.0 chai@4.3.6 sinon@14.0.0 chai-http@4.3.0 -D

* Que tal come√ßarmos criando uma pessoa no banco de dados? Ent√£o antes de escrever o teste e, consequentemente, nosso c√≥digo, vamos entender o fluxo de cadastro de pessoas que iremos implementar.

O fluxo se dar√° da seguinte maneira:

1 - Primeiramente receberemos uma requisi√ß√£o para o endpoint POST /people. Essa requisi√ß√£o ter√° no seu corpo um JSON com os dados a serem cadastrados no banco de dados similar ao seguinte:

{
  "firstName": "Luke",
  "lastName": "Skywalker",
  "email": "luke.skywalker@trybe.com",
  "phone": "851 678 4453"
}

2 - Em seguida, o express passar√° o JSON recebido na requisi√ß√£o para um componente de software (o qual iremos desenvolver üòâ) que ir√° enviar uma declara√ß√£o SQL INSERT para o MySQL;

3 - Ap√≥s o envio do comando SQL inser√ß√£o da pessoa no MySQL, receberemos uma resposta do MySQL sobre a opera√ß√£o;

4 - Enviamos a resposta para a requisi√ß√£o com o c√≥digo de estado 201 se a opera√ß√£o ocorreu com sucesso, ou o c√≥digo de estado 500 caso algum erro ocorrer durante o processo de cadastro da pessoa no MySQL.

(na pasta se encontra um gif de como funciona as requisi√ß√µes.)

* agora vamos criar a pasta "testes" no src e dentro dela a pasta "integration" para colocar os testes de integra√ß√£o.

* dentro da pasta "integration" criar o arquivo de teste "people.test.js" e dentro dele colocar o seguinte c√≥digo de teste.

EX:

//  tests/integration/people.test.js

const chai = require('chai');
const chaiHttp = require('chai-http');
const sinon = require('sinon');

const app = require('../../src/app');
const connection = require('../../src/db/connection');

const { expect, use } = chai;

use(chaiHttp);

describe('Testando os endpoints de people', function () {
  it('Testando o cadastro de uma pessoa ', async function () {
    sinon.stub(connection, 'execute').resolves([{ insertId: 42 }]);

    const response = await chai
      .request(app)
      .post('/people')
      .send(
        {
          firstName: 'Luke',
          lastName: 'Skywalker',
          email: 'luke.skywalker@trybe.com',
          phone: '851 678 4453',
        },
      );

    expect(response.status).to.equal(201);
    expect(response.body).to.
      deep.equal({ message: 'Pessoa cadastrada com sucesso com o id 42' });
  });

  afterEach(sinon.restore);
});

Com esse c√≥digo, fazemos as importa√ß√µes necess√°rias para realizar os testes de integra√ß√£o.

Em seguida s√£o criadas as vari√°veis app e connection que fazem refer√™ncia aos m√≥dulos src/app.js e src/db/connection.js. Teremos apenas um describe que agrupar√° os testes relacionados ao endpoint people.

Dentro do describe criado, temos um caso de teste (declara√ß√£o it) que realiza duas tarefas:

Cria um stub com o sinon na fun√ß√£o execute de connection, de maneira que quando essa fun√ß√£o for chamada no teste, ela retornar√° um array contendo um objeto com a chave insertId com o valor 42.

Uma requisi√ß√£o ao endpoint POST /people passando um JSON com os dados da pessoa a ser cadastrada no corpo da requisi√ß√£o.

‚ö†Ô∏è Aten√ß√£o: o fato de estarmos colocando um objeto dentro de um array nos testes de integra√ß√£o √© para garantir que o retorno do stub tenha o mesmo formato do retorno das fun√ß√µes do mysql2.

Tamb√©m foi adicionado um afterEach ap√≥s a declara√ß√£o it, que desfaz o stub criado, fazendo com que o m√©todo execute de connection se comporte conforme nossa implementa√ß√£o.

Voc√™ deve estar se perguntando o seguinte: por que estamos criando um stub no m√©todo execute de connection? ü§î

N√≥s temos acesso ao m√©todo execute atrav√©s da biblioteca mysql2, que possui seus testes de integra√ß√£o e testes unit√°rios. Como a biblioteca mysql2 realiza os testes nas fun√ß√µes que ela disponibiliza, podemos assumir em nossos testes que, da chamada da fun√ß√£o connection.execute() em diante, tudo est√° sendo testado!

üëÄ De olho na dica: caso tenha curiosidade em saber como s√£o os testes da biblioteca mysql2, acesse a pasta tests do github da biblioteca.

Em resumo: s√≥ precisamos testar o comportamento da nossa aplica√ß√£o at√© a chamada da fun√ß√£o connection.execute() (que criamos o mock), que retornar√° um resultado conhecido e, de posse desse resultado, verificar√° se a aplica√ß√£o gera a resposta apropriada.

‚ö†Ô∏è Aten√ß√£o: essa premissa √© v√°lida para qualquer biblioteca que estivermos utilizando em nossa aplica√ß√£o e n√£o apenas para mysql2. Teste de software √© uma boa pr√°tica de desenvolvimento, principalmente em bibliotecas escritas pela comunidade. Logo, n√£o precisamos testar o que j√° est√° testado!

* agora configurar o script no package.json o script de test.

EX:

  "scripts": {
    ...
    "test": "mocha tests/**/*$NAME*.test.js --exit"
  },

* depois disso vamos executar o teste "npm test" para ver o resultado.

* ap√≥s isso vamos come√ßar a criar os endpoints, para isso criar no "src" a pasta "routes" para os endpoints e dentro dessa pasta o arquivo "peopleRoutes.js" e nela colocar o seguinte c√≥digo.

EX:

// src/routes/peopleRoutes.js

const express = require('express');

const router = express.Router();

router.use(express.json());

router.post('/', (req, res) => {
  const person = req.body;
  res.status(201).json(person);
});

module.exports = router;

* no arquivo "app.js" adicionamos a rota people que vai ficar desse jeito.

EX:

// src/app.js

// const express = require('express');
const peopleRoutes = require('./routes/peopleRoutes');

// const app = express();

// app.use(express.json());

app.use('/people', peopleRoutes);

// module.exports = app;

* Vamos criar arquivo src/db/peopleDB.js, que tem como responsabilidade agrupar todas as opera√ß√µes SQL relacionadas a tabela people. Inicialmente vamos escrever o c√≥digo necess√°rio para inserir uma pessoa no banco de dados, mas ao longo do dia adicionaremos c√≥digo referente a outras opera√ß√µes.

EX:

// src/db/peopleDB.js

const conn = require('./connection');

const insert = (person) => conn.execute(
    `INSERT INTO people 
      (first_name, last_name, email, phone) VALUES (?, ?, ?, ?)`,
    [person.firstName, person.lastName, person.email, person.phone],
  );

module.exports = {
  insert,
};

Inicialmente importamos a conex√£o com o MySQL do nosso outro m√≥dulo e, em seguida, editamos a fun√ß√£o insert para receber como par√¢metro um objeto person. Nela escrevemos o c√≥digo referente a um INSERT no banco de dados. Ent√£o, chamamos a fun√ß√£o conn.execute(), a qual recebe dois par√¢metros:

Uma string que cont√©m um INSERT de dados na tabela people. Note que a string foi definida utilizando-se crase para possibilitar a quebra de linhas, mas pode-se utilizar as aspas simples ou duplas;
Um array de valores que s√£o extra√≠dos do objeto person;
Vale destacar que no final da string que cont√©m o SQL INSERT, existem quatro sinais de interroga√ß√£o. Voc√™ pode estar se perguntando: ‚ÄúEsse SQL n√£o est√° escrito errado?‚Äù ü§î

Esses s√≠mbolos de interroga√ß√£o s√£o chamados de placeholders (ou marcadores, em portugu√™s). Sua fun√ß√£o √© de justamente marcar os locais que ser√£o substitu√≠das pelos valores dentro da consulta SQL.

E quais s√£o esses valores que substituir√£o os sinais de interroga√ß√£o? ü§î

S√£o justamente os valores do array que passamos como segundo par√¢metro da fun√ß√£o conn.execute()! A chamada da fun√ß√£o conn.execute() com os dois par√¢metros citados √© o que caracteriza uma prepared statement no mysql2.

Podemos pensar nas Prepared Statements como um template ou um molde para consultas SQL que uma aplica√ß√£o deseja executar, e que pode ser customizado utilizando vari√°veis de par√¢metros (os placeholders ou marcadores). Isso nos oferece dois grandes benef√≠cios:

As consultas SQL s√≥ necessitam ser preparadas uma √∫nica vez, entretanto podem ser executadas m√∫ltiplas vezes com os mesmos par√¢metros ou com par√¢metros diferentes. Quando uma consulta √© preparada, o banco de dados ir√° analisar, compilar e otimizar a execu√ß√£o da consulta;
Os par√¢metros das prepared statements n√£o devem ser vinculadas diretamente na consulta SQL (utilizando concatena√ß√£o de string, por exemplo). O recurso das prepared statements identifica os par√¢metros para o banco de dados, evitando que ele erroneamente interprete strings como parte da consulta. Se uma aplica√ß√£o utiliza prepared statements em todas as opera√ß√µes que realiza com o banco de dados, essas opera√ß√µes est√£o seguras contra o ataque do tipo SQL injection.
‚ö†Ô∏è Aten√ß√£o: SQL injection √© um tipo de ataque malicioso que uma aplica√ß√£o Web pode sofrer atrav√©s de inje√ß√£o de c√≥digo SQL em entradas que n√£o tratam os dados de forma adequada (e.g. formul√°rios, APIs REST, etc). O relat√≥rio anual de 2021 da Open Web Application Security Project (OWASP) apontou os ataques de inje√ß√£o (categoria do SQL injection) como o terceiro maior vetor de ataques maliciosos contra aplica√ß√µes Web. üò®

Na execu√ß√£o dessa prepared statement, os placeholders ser√£o substitu√≠dos pelos valores do array seguindo a mesma ordem nos quais eles foram declarados, ou seja, o primeiro placeholder ser√° substitu√≠do pelo primeiro valor do array; o segundo placeholder ser√° substitu√≠do pelo valor do segundo valor do array e assim sucessivamente at√© o √∫ltimo. Dessa forma, podemos reutilizar esse INSERT apenas passando valores diferentes para o array!

* ap√≥s isso vamos mudat o nosso arquivo people com o endpoint post.

EX:

// src/routes/peopleRoutes.js

// const express = require('express');
const peopleDB = require('../db/peopleDB');

// const router = express.Router();

router.post('/', async (req, res) => {
  const person = req.body;
  try {
    const [result] = await peopleDB.insert(person);
    res.status(201).json({
      message: `Pessoa cadastrada com sucesso com o id ${result.insertId}` });
  } catch (err) {
    console.log(err);
    res.status(500).json({ message: 'Ocorreu um erro ao cadastrar uma pessoa' });
  }
});
// module.exports = router;

* agora vamos adicionar mais 2 casos de teste.

EX:

// src/tests/integration/people.test.js

// const chai = require('chai');
// ...

const peopleList = [
  {
    id: 1,
    firstName: 'Luke',
    lastName: 'Skywalker',
    email: 'luke.skywalker@trybe.com',
    phone: '851 678 4453',
  },
  {
    id: 2,
    firstName: 'Dart',
    lastName: 'Vader',
    email: 'dart.vader@trybe.com',
    phone: '851 678 5665',
  },
];

// describe('Testando os endpoints de people', function () {
  
//  ...

  it('Testando a listagem de todas as pessoas', async function () {
    sinon.stub(connection, 'execute').resolves([peopleList]);
    const response = await chai
      .request(app)
      .get('/people');

    expect(response.status).to.equal(200);
    expect(response.body).to.deep.equal(peopleList);
  });

  it('Testando a listagem da pessoa com id 1', async function () {
    sinon.stub(connection, 'execute').resolves([[peopleList[0]]]);
    const response = await chai
      .request(app)
      .get('/people/1');

    expect(response.status).to.equal(200);
    expect(response.body).to.deep.equal(peopleList[0]);
  });

  // afterEach(sinon.restore);
// });

Aqui, criamos a constante peopleList com um array de pessoas. Em seguida, adicionamos dois casos de testes:

Um stub para a fun√ß√£o connection.execute(), que retornar√° um array que cont√©m outro array de pessoas armazenadas em peopleList e um caso de teste respons√°vel por listar todas as pessoas do banco de dados a partir do endpoint GET /people, no qual √© esperado retornar uma lista de pessoas no formato JSON;

Outro stub para a fun√ß√£o connection.execute(), que retornar√° um array que cont√©m outro array com a primeira pessoa de peopleList e outro caso de teste para listar uma pessoa a partir do seu id atrav√©s do endpoint GET /people/:id, onde :id √© um par√¢metro de rota que indica o id da pessoa no banco de dados.

‚ö†Ô∏è Aten√ß√£o: o fato de estarmos colocando um array dentro de um array ou um objeto dentro de um array nos testes de integra√ß√£o, √© para garantir que o retorno do stub tenha o mesmo formato do retorno das fun√ß√µes do mysql2. üòâ

* para os testes passar precisamos fazer as fun√ß√µes no arquivo que faz a requisi√ß√£o para o banco de dados, que √© o arquivo "peopleDB.js".

EX:

// const conn = require('./connection');
// ...

const findAll = () => conn.execute('SELECT * FROM people');

const findById = (id) => conn.execute('SELECT * FROM people WHERE id = ?', [id]);

// module.exports = {
//   insert,
  findAll,
  findById,
// };

Foram adicionadas as constantes findAll e findById onde:

A fun√ß√£o findAll realiza uma consulta no banco de dados, que retorna todas as pessoas cadastradas;
A fun√ß√£o findById realiza uma consulta no banco de dados, que retorna uma pessoa tendo como crit√©rio o valor do seu id.

* agora adicionar os endpoints no arquivo "peopleRoute.js" para fazer a requisi√ß√£o.

EX:

// src/routes/peopleRoutes.js

// const express = require('express');
// const peopleDB = require('../db/peopleDB');

// ...

router.get('/', async (_req, res) => {
  try {
    const [result] = await peopleDB.findAll();
    res.status(200).json(result);
  } catch (err) {
    console.log(err);
    res.status(500).json({ message: err.sqlMessage });
  }
});

router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const [[result]] = await peopleDB.findById(id);
    if (result) {
      res.status(200).json(result);
    } else {
      res.status(404).json({ message: 'Pessoa n√£o encontrada' });
    }
  } catch (err) {
    console.log(err);
    res.status(500).json({ message: err.sqlMessage });
  }
});

// module.exports = router;

O c√≥digo acima adiciona dois novos endpoints GET / e GET /:id. O novo endpoint GET / cont√©m um bloco try/catch, que √© respons√°vel por responder a requisi√ß√£o. Dentro do bloco try temos uma chamada para a fun√ß√£o findAll (ainda n√£o foi implementada no arquivo src/db/peopleDB.js, mas o faremos em breve), que retorna uma Promise (por isso temos um await aqui) e realiza a desconstru√ß√£o da resposta, armazenando na constante result.

A constante result cont√©m a lista de pessoas e a mesma √© retornada como resposta. Caso ocorra algum erro durante a requisi√ß√£o, o bloco catch responder√° com um c√≥digo de estado 500 e a mensagem de erro do mysql2.

J√° o endpoint GET /:id tamb√©m cont√©m um bloco try/catch, que √© respons√°vel por responder a requisi√ß√£o tamb√©m! Dentro do bloco try temos uma chamada para a fun√ß√£o findById (ainda n√£o foi implementada no arquivo src/db/peopleDB.js, mas o faremos em breve), que recebe o par√¢metro de requisi√ß√£o id (obtido da desestrutura√ß√£o de req.params) e retorna uma Promise (por isso temos tamb√©m um await aqui), realizando a desestrutura√ß√£o da resposta e armazenando na constante result.

A constante result cont√©m um array de pessoas. Por√©m, nesse endpoint essa lista pode ter nenhum objeto (situa√ß√£o na qual n√£o existe uma pessoa no banco de dados com o id passado como par√¢metro) ou um objeto. Por essa raz√£o temos um bloco if/else para avaliar se o tamanho do array result √© maior que zero.

Se o tamanho do array result for maior que zero, uma pessoa foi encontrada no banco de dados e √© retornada como resposta da requisi√ß√£o com c√≥digo de estado 200. Caso contr√°rio, ser√° retornada como resposta da requisi√ß√£o uma mensagem com status 404 indicando que uma pessoa n√£o foi encontrada.

Se executarmos os nossos testes com o comando npm test novamente, eles ir√£o falhar e apresentar uma mensagem de erro indicando que findAll e findById n√£o s√£o fun√ß√µes. O motivo desse erro √© que realizamos a chamada dessas fun√ß√µes no arquivo src/routes/peopleRoutes.js, mas n√£o as criamos no arquivo src/db/peopleDB.js (lembre-se do esp√≠rito do TDD üòé).

* agora adicionar aos testes a verifica√ß√£o da edi√ß√£o de algum pessoa no banco de dados e na retirada de algu√©m no banco de dados.

EX:

// src/tests/integration/people.test.js

// ...

// describe('Testando os endpoints de people', function () {
// ...

  it('Testando a altera√ß√£o de uma pessoa com o id 1', async function () {
    sinon.stub(connection, 'execute').resolves([{ affectedRows: 1 }]);
    const response = await chai
      .request(app)
      .put('/people/1')
      .send(
        {
          firstName: 'Luc√£o',
          lastName: 'Andarilho dos c√©us',
          email: 'lucao.andarilho@trybe.com',
          phone: '851 678 4453',
        },
      );

    expect(response.status).to.equal(200);
    expect(response.body).to
      .deep.equal({ message: 'Pessoa de id 1 atualizada com sucesso' });
  });

  it('Testando a exclus√£o da pessoa com id 1', async function () {
    sinon.stub(connection, 'execute').resolves([{ affectedRows: 1 }]);
    const response = await chai
      .request(app)
      .delete('/people/1');

    expect(response.status).to.equal(200);
    expect(response.body).to
      .deep.equal({ message: 'Pessoa de id 1 exclu√≠da com sucesso' });
  });

  // afterEach(sinon.restore);
// });

Com isso, foram adicionados dois casos de teste:

Um caso de teste respons√°vel por atualizar os dados de uma pessoa no banco de dados a partir do endpoint PUT /people/:id: esse teste espera o retorno de um objeto com uma mensagem de sucesso da opera√ß√£o com c√≥digo de estado 200. Al√©m disso, possui um stub para a fun√ß√£o connection.execute(), que retornar√° um array contendo um objeto com a chave affectedRows com o valor 1;

Um caso de teste respons√°vel por excluir uma pessoa do banco de dados a partir do endpoint DELETE /people/:id: esse teste espera o retorno de um objeto com uma mensagem de sucesso da opera√ß√£o com c√≥digo de estado 200. Al√©m disso, tamb√©m possui um stub para a fun√ß√£o connection.execute(), que retornar√° um array contendo tamb√©m um objeto com a chave affectedRows com o valor 1.

* no arquivo "peopleRoutes.js" adicionamos os dois endpoints de editar e excluir.

EX:

router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const person = req.body;
    const [result] = await peopleDB.update(person, id);
    if (result.affectedRows > 0) {
      res.status(200).json({ message: `Pessoa de id ${id} atualizada com sucesso` });
    } else {
      res.status(404).json({ message: 'Pessoa n√£o encontrada' });
    }
  } catch (err) {
    res.status(500).json({ message: err.sqlMessage });
  }
});

router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const [result] = await peopleDB.remove(id);
    if (result.affectedRows > 0) {
      res.status(200).json({ message: `Pessoa de id ${id} exclu√≠da com sucesso` });
    } else {
      res.status(404).json({ message: 'Pessoa n√£o encontrada' });
    }
  } catch (err) {
    res.status(500).json({ message: err.sqlMessage });
  }
});

Nesse c√≥digo adicionamos dois novos endpoints que mapeiam PUT /:id e DELETE /:id. O endpoint mapeado com o m√©todo HTTP PUT, recebe o id da pessoa como par√¢metro de rota e tamb√©m um objeto com os dados da pessoa (com o mesmo formato do objeto utilizado anteriormente no cadastro de pessoa). Em seguida √© executada a fun√ß√£o peopleDB.update(), a qual recebe os dados da pessoa e o id da pessoa a ser alterada. Essa opera√ß√£o retornar√° uma Promise, que ser√° esperada e desconstru√≠da para obter o result.

√â realizada uma verifica√ß√£o na qual √© avaliado se a quantidade de linhas afetadas com a opera√ß√£o update √© maior do que zero por meio da propriedade affectedRows do objeto result:

Caso a condi√ß√£o seja verdadeira, ser√° enviada uma resposta com o status 200 e uma mensagem de sucesso.
Se a condi√ß√£o for falsa, ser√° enviada uma resposta com o status 404 e uma mensagem de erro. Em caso de erro durante a requisi√ß√£o, ser√° enviada uma resposta com o status 500 e uma mensagem de erro.
O endpoint mapeado com o m√©todo HTTP DELETE possui a mesma estrutura do endpoint mapeado com o m√©todo HTTP PUT, exceto pelo fato de que n√£o recebe nenhum JSON no corpo da requisi√ß√£o, apenas recebe o id da pessoa como par√¢metro de rota.

* para completar vamos adicionar as fun√ß√µes de liga√ß√£o com o banco de dados no arquivo "peopleDB.js".

EX:

// src/db/peopleDB.js

// const conn = require('./connection');
// ...

const update = (person, id) => conn.execute(
    `UPDATE people 
      SET first_name = ?, last_name = ?, email = ?, phone = ? WHERE id = ?`,
    [person.firstName, person.lastName, person.email, person.phone, id],
  );

const remove = (id) => conn.execute('DELETE FROM people WHERE id = ?', [id]);

// module.exports = {
// ...
  update,
  remove,
// };

* agora os testes v√£o rodar e passar, assim como as requisi√ß√µes.

# VARI√ÅVEIS DE AMBIENTE  = Uma vari√°vel de ambiente √© um recurso dispon√≠vel nos sistemas operacionais que permite criar uma vari√°vel no formato NOME_DA_VARI√ÅVEL=VALOR, onde NOME_DA_VARI√ÅVEL √© o nome da vari√°vel de ambiente, e VALOR se refere a um valor que ser√° vinculado √† vari√°vel. Toda vez que solicitarmos ao sistema operacional o valor de uma vari√°vel de ambiente, fornecemos a ele uma NOME_DA_VARI√ÅVEL e ele retorna o VALOR associado a esta chave, se ela estiver definida. (OBS: LEMBRAR DE ESPECIFICAR NO README O ARQUIVO ".env.example" QUE PRECISA SER SUBSTITUIDO)

* primeiro vamos criar dois arquivos no diret√≥rio raiz o ".env" e o ".env.example", no .env vamos colocar os dados que tinha no "connection.js" e colocar o arquivo no .gitignore para n√£o ser enviado para o github, apenas o .git.example.

EX: arquivo .env

MYSQL_HOST=localhost
MYSQL_PORT=33060
MYSQL_USER=root
MYSQL_PASSWORD=root
MYSQL_DATABASE_NAME=trybecashdb
MYSQL_WAIT_FOR_CONNECTIONS=true
MYSQL_CONNECTION_LIMIT=10
MYSQL_QUEUE_LIMIT=0

EX: arquivo .env.example  (OBS: LEMBRAR DE ESPECIFICAR NO README O ARQUIVO ".env.example" QUE PRECISA SER SUBSTITUIDO)

MYSQL_HOST=<ENDERE√áO DO BANCO>
MYSQL_PORT=<PORTA DE CONEX√ÉO DO BANCO>
MYSQL_USER=<NOME DE USU√ÅRIO DO BANCO>
MYSQL_PASSWORD=<SENHA DE ACESSO DO BANCO>
MYSQL_DATABASE_NAME=<NOME DO BANCO DE DADOS>
MYSQL_WAIT_FOR_CONNECTIONS=true
MYSQL_CONNECTION_LIMIT=10
MYSQL_QUEUE_LIMIT=0

* agora vamos ajustar o arquivo "connection.js" e retirar os dados vis√≠veis de l√° que j√° foi colocado no arquivo ".env".

EX:

// src/db/connection.js

const mysql = require('mysql2/promise');

const connection = mysql.createPool({
  host: process.env.MYSQL_HOST,
  port: process.env.MYSQL_PORT,
  user: process.env.MYSQL_USER,
  password: process.env.MYSQL_PASSWORD,
  database: process.env.MYSQL_DATABASE_NAME,
  waitForConnections: process.env.MYSQL_WAIT_FOR_CONNECTIONS,
  connectionLimit: process.env.MYSQL_CONNECTION_LIMIT,
  queueLimit: process.env.MYSQL_QUEUE_LIMIT,
});

module.exports = connection;

* agora para iniciar e funcionar tudo direto vamos instalar um pacote node do env e pedir a requisi√ß√£o dele no arquivo "server.js".

EX:

npm i dotenv@16.0

require('dotenv').config();  = colocar esse c√≥digo no come√ßo no arquivo "server.js"

* agora sim est√° tudo completo e escondemos os dados do nosso banco de dados. lembrar de explicar o arquivo ".env.example" de como ele funciona no readme.

* GLOSS√ÅRIO:

Docker Compose
√â uma ferramenta para definir e executar aplica√ß√µes Docker de v√°rios containers. Utiliza-se um um arquivo yaml para definir as configura√ß√µes dos servi√ßos daquela aplica√ß√£o, que ser√£o iniciados com um √∫nico comando: docker compose up.

Pool de conex√µes
Um pool de conex√µes √© um reposit√≥rio com um conjunto de conex√µes estabelecidas previamente com o banco de dados. Essas conex√µes ser√£o reutilizadas durante a execu√ß√£o da aplica√ß√£o conforme a necessidade, ou seja, se uma API recebe duas ou mais requisi√ß√µes simult√¢neas, ela usar√° as conex√µes dispon√≠veis para atender as requisi√ß√µes com melhor desempenho.

Utilizando uma analogia, o pool de conex√µes √© como um estojo com v√°rios l√°pis do qual voc√™ pode retirar um sempre que precisar e, assim que aquele l√°pis n√£o for mais necess√°rio pra voc√™, voc√™ pode devolver ao estojo para que ele esteja dispon√≠vel da pr√≥xima vez que voc√™ precisar dele.

Prepared statements
S√£o como um template ou um molde para consultas SQL que uma aplica√ß√£o deseja executar, e que pode ser customizado utilizando vari√°veis de par√¢metros (os placeholders ou marcadores).

S√£o caracterizados pela chamada da fun√ß√£o conn.execute() com os dois par√¢metros: uma string que cont√©m uma query do MySQL constru√≠da utilizando placeholders (representados pelo sinal ?) e um array de valores que substituir√£o esses placeholders, seguindo a mesma ordem nos quais eles foram declarados.

Vari√°veis de ambiente
As vari√°veis de ambiente s√£o cadeias de caracteres que cont√™m informa√ß√µes sobre o ambiente do sistema e sobre o usu√°rio que est√° conectado no momento. Seu formato √© definido por NOME_DA_VARI√ÅVEL=VALOR, onde NOME_DA_VARI√ÅVEL √© o nome da vari√°vel de ambiente, e VALOR se refere a um valor que ser√° vinculado √† vari√°vel.

S√£o comumente usadas para guardar chaves e senhas, evitando sua exposi√ß√£o, ou outras configura√ß√µes do sistema.








