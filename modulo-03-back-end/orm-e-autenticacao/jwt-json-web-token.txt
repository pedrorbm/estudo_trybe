# JWT  = O JWT (JSON Web Token) Ã© um token gerado a partir de dados â€œpessoaisâ€ que pode ser trafegado pela internet ao fazer requisiÃ§Ãµes para APIs e afins. Mas atenÃ§Ã£o: toda a informaÃ§Ã£o que colocamos no JWT Ã© pÃºblica e qualquer pessoa com o token consegue ler essas informaÃ§Ãµes. O mecanismo de seguranÃ§a do JWT permite, no entanto, que apenas quem tem a senha consiga alterar as informaÃ§Ãµes contidas em um token.

A coisa toda funciona assim:

O navegador solicita que o usuÃ¡rio digite seu login e senha.
O navegador entÃ£o envia esse login e senha ao servidor, para verificar que esses dados estÃ£o corretos.
Uma vez que valida login e senha, o servidor cria dois objetos: um contendo informaÃ§Ãµes sobre o token que serÃ¡ gerado, que chamamos de header, e outro contendo os dados do usuÃ¡rio e as permissÃµes que aquela pessoa tem, ao qual chamamos de payload.
O servidor, entÃ£o, converte esses dois objetos em JSON, junta-os em uma mesma string e utiliza um algoritmo chamado HMAC para â€œcriptografarâ€ essa string usando um â€œsegredoâ€ que sÃ³ ele sabe, gerando o que chamamos de assinatura â€“ que nada mais Ã© do que header + payload criptografados.
Por fim, o servidor combina o header, o payload originais e a assinatura, criando assim o token.
O token Ã© enviado ao cliente, que o armazena para utilizÃ¡-lo nas prÃ³ximas requisiÃ§Ãµes.
Chamamos de autenticaÃ§Ã£o o processo pelo qual a pessoa usuÃ¡ria consegue, utilizando informaÃ§Ãµes confidenciais como email e senha, efetuar login com sucesso em uma aplicaÃ§Ã£o, tendo como retorno um JSON Web Token que possibilita acessar suas permissÃµes de navegaÃ§Ã£o.

O resultado terÃ¡ a seguinte estrutura:

(Header em base64).(Payload em base64).(Signature em base64)

Exemplo de resultado:

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIxIiwiZXhwIjoxNTQ3OTc0MDgyfQ.2Ye5_w1z3zpD4dSGdRp3s98ZipCNQqmsHRB9vioOx54

Nesse caso, temos:

Header: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9

Payload: eyJ1c2VybmFtZSI6InVzZXIxIiwiZXhwIjoxNTQ3OTc0MDgyfQ

Signature: 2Ye5_w1z3zpD4dSGdRp3s98ZipCNQqmsHRB9vioOx54

* como instalar e usar o JWT:

* Para comeÃ§ar, vamos instalar o pacote jsonwebtoken. Ele Ã© quem serÃ¡ responsÃ¡vel por gerar e validar os tokens para nÃ³s:

EX:

npm install -E jsonwebtoken@9.0.0

* Agora, vamos editar o arquivo src/controllers/login.js. LÃ¡, vamos trabalhar na geraÃ§Ã£o do nosso JWT e adicionar os seguintes trechos de cÃ³digo:

EX:

const jwt = require('jsonwebtoken');
const { UserService } = require('../services');

/* Sua chave secreta. Ã‰ com ela que os dados do seu usuÃ¡rio serÃ£o encriptados.
   Em projetos reais, armazene-a numa variÃ¡vel de ambiente e tenha cuidado com ela, pois sÃ³ quem tem acesso
   a ela poderÃ¡ criar ou alterar tokens JWT. */
const secret = process.env.JWT_SECRET || 'seusecretdetoken';

const isBodyValid = (username, password) => username && password;

module.exports = async (req, res) => {
  try {
    const { username, password } = req.body;

    if (!isBodyValid(username, password)) {
      return res.status(401).json({ message: 'Ã‰ necessÃ¡rio usuÃ¡rio e senha para fazer login' });
    }

    const user = await UserService.getByUsername(username);

    if (!user || user.password !== password) {
      return res.status(401).json({ message: 'UsuÃ¡rio nÃ£o existe ou senha invÃ¡lida' });
    }

    /* Criamos uma config bÃ¡sica para o nosso JWT, onde:
    expiresIn -> significa o tempo pelo qual esse token serÃ¡ vÃ¡lido;
    algorithm -> algoritmo que vocÃª usarÃ¡ para assinar sua mensagem
                (lembra que falamos do HMAC-SHA256 lÃ¡ no comeÃ§o?). */

    /* A propriedade expiresIn aceita o tempo de forma bem descritiva. Por exemplo: '7d' = 7 dias. '8h' = 8 horas. */
    const jwtConfig = {
      expiresIn: '7d',
      algorithm: 'HS256',
    };

    /* Aqui Ã© quando assinamos de fato nossa mensagem com a nossa "chave secreta".
      Mensagem essa que contÃ©m dados do seu usuÃ¡rio e/ou demais dados que vocÃª
      quiser colocar dentro de "data".
      O resultado dessa funÃ§Ã£o serÃ¡ equivalente a algo como: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImlkIjozLCJ1c2VybmFtZSI6Iml0YWxzc29kaiIsInBhc3N3b3JkIjoic2VuaGExMjMifSwiaWF0IjoxNjM4OTc1MTMyLCJleHAiOjE2Mzk1Nzk5MzJ9.hnpmu2p61Il8wdQfmUiJ7wiWXgw8UuioOU_D2RnB9kY */
    const token = jwt.sign({ data: { userId: user.id } }, secret, jwtConfig);

    /* Por fim, nÃ³s devolvemos essa informaÃ§Ã£o ao usuÃ¡rio. */
    res.status(200).json({ token });
  } catch (err) {
    return res.status(500).json({ message: 'Erro interno', error: err.message });
  }
};

* Feito isso, nÃ³s jÃ¡ podemos nos autenticar de verdade, nÃ£o Ã© mesmo? Ao fazer uma nova requisiÃ§Ã£o POST para /api/login, passando nome de usuÃ¡rio e senha corretos, obtemos um resultado semelhante ao seguinte:

EX:

{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7InVzZXJJZCI6MX0sImlhdCI6MTY1NjYxNjQyMiwiZXhwIjoxNjU3MjIxMjIyfQ.wfmRCMvD-tv0v1O14UwaOgeye3ezEUkBMWr6M_b6Bhw"
}

Eis o nosso token! Ã‰ ele que vamos ficar transitando pra lÃ¡ e pra cÃ¡, entÃ£o ele precisa ser guardado! Mas caso ele seja perdido, nÃ£o se preocupe; Ã© sÃ³ gerar outro token. ðŸ™‚

* Agora temos que usar esse token de alguma forma, nÃ£o Ã© mesmo? Para isso, vamos criar uma pasta chamada auth dentro do diretÃ³rio src e, dentro dela, um arquivo chamado validateJWT.js.

Esse arquivo conterÃ¡ uma funÃ§Ã£o que serÃ¡ usada como middleware para as nossas requisiÃ§Ãµes, validando todas as rotas em que nÃ³s solicitarmos autenticaÃ§Ã£o.

EX:

// src/auth/validateJWT.js
const jwt = require('jsonwebtoken');

const { UserService } = require('../services');

/* Mesma chave privada que usamos para criptografar o token.
   Agora, vamos usÃ¡-la para descriptografÃ¡-lo.
   Numa aplicaÃ§Ã£o real, essa chave jamais ficaria hardcoded no cÃ³digo assim,
   e muitos menos de forma duplicada, mas aqui sÃ³ estamos interessados em
   ilustrar seu uso ;) */
const secret = process.env.JWT_SECRET || 'seusecretdetoken';

/* Esta funÃ§Ã£o extrai o token da string "Bearer ..."
   recebida pela requisiÃ§Ã£o do login */
function extractToken(bearerToken) {
  return bearerToken.split(' ')[1];
}

module.exports = async (req, res, next) => {
  /* Aquele token gerado anteriormente virÃ¡ na requisiÃ§Ã£o atravÃ©s do
     header Authorization em todas as rotas que queremos que
     sejam autenticadas. */
  const bearerToken = req.header('Authorization');

  /* Caso o token nÃ£o seja informado, simplesmente retornamos
     o cÃ³digo de status 401 - nÃ£o autorizado. */
  if (!bearerToken) {
    return res.status(401).json({ error: 'Token nÃ£o encontrado' });
  }

  /* Utilizamos a funÃ§Ã£o para extrair o token */
  const token = extractToken(bearerToken);

  try {
    /* AtravÃ©s o mÃ©todo verify, podemos validar e decodificar o nosso JWT. */
    const decoded = jwt.verify(token, secret);
    /*
      A variÃ¡vel decoded serÃ¡ um objeto equivalente ao seguinte:
      {
        data: {
          userId: 1
        },
        iat: 1656616422,
        exp: 1657221222
      }
    */

    /* Caso o token esteja expirado, a prÃ³pria biblioteca irÃ¡ retornar um erro,
       por isso nÃ£o Ã© necessÃ¡rio fazer validaÃ§Ã£o do tempo.
       Caso esteja tudo certo, nÃ³s entÃ£o usamos o serviÃ§o de usuÃ¡rio para obter seus dados atualizados */

    const user = await UserService.getByUserId(decoded.data.userId);

    /* NÃ£o existe um usuÃ¡rio na nossa base com o id informado no token. */
    if (!user) {
      return res.status(401).json({ message: 'Erro ao procurar usuÃ¡rio do token.' });
    }

    /* O usuÃ¡rio existe! Colocamos ele em um campo no objeto req.
       Dessa forma, o usuÃ¡rio estarÃ¡ disponÃ­vel para outros middlewares que
       executem em sequÃªncia */
    req.user = user;

    /* Por fim, chamamos o prÃ³ximo middleware que, no nosso caso,
       Ã© a prÃ³pria callback da rota. */
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Token invÃ¡lido' });
  }
};

De olho na dica ðŸ‘€: Perceba que no nosso middleware utilizamos a funÃ§Ã£o extractToken Ã© porque no momento em que precisarmos fazer uma requisiÃ§Ã£o a API inserimos a palavra Bearer antes do nosso token. Este termo Ã© um padrÃ£o que identifica o tipo do token que estÃ¡ sendo enviado. Consulte a documentaÃ§Ã£o para mais informaÃ§Ãµes.

* No arquivo src/app.js, onde definimos as rotas, usamos esse middleware para adicionar autenticaÃ§Ã£o na nossa rota de listagem de posts.

EX:

// const express = require('express');
// const routes = require('./routes');

/* Aqui, importamos nossa funÃ§Ã£o que valida se o usuÃ¡rio estÃ¡ ou nÃ£o autenticado */
const validateJWT = require('./auth/validateJWT');

// const app = express();

// app.use(express.json());

// const apiRoutes = express.Router();

apiRoutes.get('/api/posts', validateJWT, routes.getPosts);
// apiRoutes.post('/api/users', routes.createUsers);
// apiRoutes.get('/api/users', routes.getUsers);
// apiRoutes.post('/api/login', routes.login);

// app.use(apiRoutes);

// module.exports = app;

Note que nÃ£o queremos autenticar o login e nem criaÃ§Ã£o de usuÃ¡rios, pois precisamos deles para o processo de autenticaÃ§Ã£o! Se houvesse outras rotas protegidas na nossa aplicaÃ§Ã£o, usarÃ­amos o middleware nelas tambÃ©m!

Agora que jÃ¡ estamos logados, vamos requisitar nossos posts!

Requisitando Posts implementando jwt
Requisitando Posts!
RequisiÃ§Ã£o nÃ£o autorizada implementando jwt
RequisiÃ§Ã£o nÃ£o autorizada!
VocÃª deve estar pensando: uÃ©! JÃ¡ fizemos o login, entÃ£o, por que nÃ£o podemos pegar os posts? Olhe com mais atenÃ§Ã£o para a resposta da API. Ela estÃ¡ dizendo que o token nÃ£o foi informado. NÃ³s conseguimos um token atravÃ©s do endpoint de login, mas nÃ£o fizemos nada com ele. Nesse caso, vamos mandar o token para a API via Headers, que sÃ£o informaÃ§Ãµes extras que podemos passar em uma requisiÃ§Ã£o.

Enviando token via Headers implementando jwt 
Enviando token via Headers!
Adicionamos um header chamado Authorization porque Ã© o que nosso middleware espera. Se nÃ£o se lembra, dÃª uma olhada de novo no arquivo src/auth/validateJWT.js.

* Feito isso, Ã© sÃ³ mandar bala na requisiÃ§Ã£o e ser feliz!

EX:

{
  "mockPosts": [
    {
      "title": "titulo fake",
      "content": "conteudo conteudo conteudo conteudo conteudo "
    },
    {
      "title": "titulo fake",
      "content": "conteudo conteudo conteudo conteudo conteudo "
    },
    {
      "title": "titulo fake",
      "content": "conteudo conteudo conteudo conteudo conteudo "
    },
    {
      "title": "titulo fake",
      "content": "conteudo conteudo conteudo conteudo conteudo "
    }
  ]
}

Voltamos a conseguir recuperar nossos posts. Mas, antes de terminarmos, um Ãºltimo comentÃ¡rio sobre nossa API: vocÃª notou que nossos posts sÃ£o fake e sÃ£o sempre os mesmos, independente do usuÃ¡rio logado, certo? Numa API real, buscarÃ­amos esses posts de um banco de dados, por exemplo. Mas como farÃ­amos para recuperar apenas os posts do usuÃ¡rio logado?

Lembra-se de que o middleware de autenticaÃ§Ã£o recupera o usuÃ¡rio do banco de dados e o coloca no req? Esse objeto Ã© o mesmo que Ã© passado para todos os middlewares e para a callback da rota.

* Como o middleware de autenticaÃ§Ã£o Ã© executado antes das funÃ§Ãµes dos controllers, req conterÃ¡ o usuÃ¡rio logado quando o controller em src/controllers/posts for executado, e poderÃ­amos utilizÃ¡-lo para fazer uma consulta ao banco de dados que trouxesse somente seus posts. Para confirmar isso, basta colocar um console.log dentro do controller:

EX:

const { PostService } = require('../services');

module.exports = async (req, res) => {
  console.log(req.user.dataValues);
  const posts = await PostService.getPosts(req);
  res.status(200).json({ mockPosts: posts });
};

* VocÃª deverÃ¡ ver algo assim, no terminal onde executou a API:

EX:

{
  id: 3,
  username: 'italssodj',
  password: 'senha123'
}



