# ORM  = Mapeamento objeto-relacional ou ORM (Object-Relational Mapping) √© uma t√©cnica que permite fazer um mapeamento estrutural entre as entidades do banco de dados e os objetos que as representam no c√≥digo JavaScript. O mapeamento objeto-relacional abstrai as diferen√ßas entre os dois paradigmas, da aplica√ß√£o e do banco de dados, como podemos ver na imagem a seguir (imagem armazenada na pasta orm-exemplo.png)

Com ORM n√£o precisamos mais escrever uma query SQL ‚Äúcrua‚Äù para cada vez que formos inserir um registro na tabela. A pr√≥pria biblioteca fica respons√°vel por isso. Voc√™ apenas passa o objeto JavaScript para ela e ela insere os dados no banco de dados.

No Node.js, temos o Sequelize, uma biblioteca de ORM bem conhecida e com suporte aos bancos de dados PostgreSQL, MariaDB, MySQL, SQLite e Microsoft SQL Server. √â justamente nessa biblioteca de ORM que vamos nos aprofundar no conte√∫do.

* sequelize  = (imagem na pasta estapas-para-implementacao-do-sequelize.png)
Esse processo pode parecer complexo, mas o Sequelize possui muitas vantagens sobre a utiliza√ß√£o de uma interface direta com o MySQL. Quando tentamos fazer a intera√ß√£o direta com o banco de dados, enfrentamos problemas como:

O JavaScript sozinho n√£o possui um suporte eficiente para o SQL, voc√™ precisaria de um script SQL separado para criar seu database e tabelas.
As queries SQL precisam ser incorporadas (‚Äúembedadas‚Äù) no c√≥digo do JavaScript para serem utilizadas.
Por causa dessas limita√ß√µes, acabamos apenas incluindo boilerplates de SQL em vez de utilizar a L√≥gica de Neg√≥cio na nossa aplica√ß√£o.
‚úèÔ∏èAnote a√≠: boilerplates s√£o trechos de c√≥digo que podem ser reutilizados em muitos lugares com pouca ou nenhuma altera√ß√£o.

Esses s√£o alguns problemas que o Sequelize ajuda a resolver! Com ele, voc√™ pode evitar a cria√ß√£o de queries SQL para produzir as tabelas. Com o uso das models e migrations no Sequelize, o seu c√≥digo se torna mais leg√≠vel, extens√≠vel e de f√°cil manuten√ß√£o.

Al√©m disso, por meio do mapeamento por objetos relacionais, √© poss√≠vel criar as rela√ß√µes e associa√ß√µes entre as tabelas com o pr√≥prio JavaScript. E ainda, √© poss√≠vel migrar seu database para outro banco de dados sem precisar reescrever todo o c√≥digo (por exemplo: mudar de MySQL para o SQL server).

* instala√ßao do sequelize

EX:

npm install -E sequelize@6.3.4

* O pr√≥ximo passo para utilizar o Sequelize √© instalar um CLI, que √© respons√°vel por gerar e executar as opera√ß√µes. Al√©m de instalar o CLI, tamb√©m precisamos instalar o mysql2, uma depend√™ncia necess√°ria para usarmos o MySQL com o Sequelize. Na pasta raiz da aplica√ß√£o, rode os comandos: (OBS: FORA DA PASTA "./SRC")

EX:

npm install -D -E sequelize-cli@6.2.0

npm install -E mysql2@2.1.0

mkdir src

* Depois que instalamos o CLI, precisamos iniciar um projeto com o Sequelize. Para isso, vamos executar o seguinte comando dentro da pasta src:

EX:

cd src

npx sequelize-cli init

Esse comando vai criar as seguintes pastas:

config: cont√©m um arquivo de configura√ß√£o, com orienta√ß√µes para o CLI se conectar com o nosso banco de dados;

models: cont√©m todos os modelos da nossa aplica√ß√£o;

migrations: cont√©m todos os arquivos de migra√ß√£o da nossa aplica√ß√£o;

seeders: cont√©m todos os arquivos de ‚Äúseeds‚Äù (sementes que s√£o usadas para popular o banco).

‚û°Ô∏è O arquivo .sequelizerc

O arquivo .sequelizerc √© um arquivo de configura√ß√£o do Sequelize. Esse arquivo √© respons√°vel por configurar o caminho das pastas migrations, models, seeders e config que o Sequelize ir√° procurar ao executar um comando.

Por padr√£o, ao rodar um comando Sequelize os arquivos dentro das pastas de migrations, models, seeders e config seriam procurados somente na camada em que estiv√©ssemos executando o comando. No nosso caso, como estamos utilizando a pasta src para abrigar os arquivos do Sequelize, caso execut√°ssemos um comando diretamente na raiz da aplica√ß√£o, ir√≠amos nos deparar com um erro.

Podemos entrar na pasta src e executar estes comandos, como fizemos anteriormente, pois assim teremos √™xito. Mas caso fosse uma aplica√ß√£o maior, com mais camadas, aumentar√≠amos a complexidade de subir e configurar a aplica√ß√£o.

√â neste momento que entra em cena o arquivo .sequelizerc. Dessa forma, podemos construir um c√≥digo com uma arquitetura mais organizada. ‚≠ê

* Antes de configurar esse arquivo, volte para a pasta raiz da aplica√ß√£o com o seguinte comando:

EX:

cd ..

* Agora crie um arquivo com o nome .sequelizerc com o seguinte conte√∫do: (O arquivo .sequelizerc √© um arquivo de configura√ß√£o do Sequelize e deve ser criado na pasta raiz. Nesse caso, a pasta app-with-sequelize.)

EX:

// app-with-sequelize/.sequelizerc

const path = require('path');

module.exports = {
  'config': path.resolve('src', 'config', 'config.js'),
  'models-path': path.resolve('src', 'models'),
  'seeders-path': path.resolve('src', 'seeders'),
  'migrations-path': path.resolve('src', 'migrations'),
};

Vamos entender melhor as informa√ß√µes deste arquivo:

path: √© um m√≥dulo interno do Node que nos fornece alguns utilit√°rios para trabalharmos com caminhos de arquivos e diret√≥rios;

config: √© um caminho para o arquivo de configura√ß√£o;

models-path: √© um caminho para o diret√≥rio de models;

seeders-path: √© um caminho para o diret√≥rio de seeders;

migrations-path: √© um caminho para o diret√≥rio de migrations.

* Agora precisamos configurar o arquivo config.json gerado pelo init do CLI. Ao alterar esse arquivo, estamos configurando o acesso da aplica√ß√£o ao nosso banco de dados.

‚û°Ô∏è Note que o arquivo config.json, localizado no diret√≥rio ./src/config, cont√©m informa√ß√µes sens√≠veis, como credenciais de acesso ao banco de dados, expostas no nosso c√≥digo. Uma boa pr√°tica √© substituir os valores por vari√°veis de ambiente, n√£o expondo assim, informa√ß√µes sens√≠veis relacionados √† configura√ß√£o geral da aplica√ß√£o. Ent√£o, vamos fazer isso do jeito certo!

‚û°Ô∏è Mudaremos o nome do nosso arquivo config.json para config.js

‚û°Ô∏è Retiraremos todo o conte√∫do de config.js e substituiremos pelo c√≥digo abaixo:

EX:

// src/config/config.js

const config = {
  username: process.env.MYSQL_USER,
  password: process.env.MYSQL_PASSWORD,
  database: process.env.MYSQL_DATABASE,
  host: process.env.MYSQL_HOST,
  dialect: 'mysql',
};

module.exports = {
  development: config,
  test: config,
  production: config,
};

Vamos entender melhor as informa√ß√µes que estamos passando:

username: usu√°rio de acesso ao banco de dados;

password: senha de acesso ao banco de dados;

database: nome do banco de dados no qual queremos conectar;

host: servidor no qual estamos conectando - por ser local, utilizamos o endere√ßo IP 127.0.0.1, ou seu alias localhost;

dialect: informa qual a biblioteca que o sequelize utiliza para se conectar ao banco de dados estamos utilizando. Nesse caso, mysql.

* Modifique o arquivo src/models/index.js para apontar para o arquivo config.js:

EX:

Para fazer isso, busque neste arquivo, a seguinte linha de c√≥digo:

const config = require(__dirname + '/../config/config.json')[env]; // configura√ß√£o antiga

Altere esta linha para ficar assim:

/ Praticamente √© s√≥ mudar a extens√£o de .json para .js! /
const config = require(__dirname + '/../config/config.js')[env]; // configura√ß√£o nova

* Antes de rodar os comandos Sequelize, precisamos garantir que temos uma inst√¢ncia do MySQL rodando.

Caso voc√™ j√° tenha um container com uma imagem do MySQL, pode utiliz√°-lo ou usar o comando abaixo no terminal para criar e rodar um:

‚ö†Ô∏è Garanta que a senha do banco esteja de acordo com a presente no .env. üòâ

EX:

docker container run --name teste-sequelize -e MYSQL_ROOT_PASSWORD=root -d -p 3306:3306 mysql:8.0.29

*  Cria√ß√£o do banco de dados usando o CLI do Sequelize

‚û°Ô∏èAgora que iniciamos uma aplica√ß√£o do Sequelize e a nossa inst√¢ncia do MySQL est√° rodando, podemos criar o banco de dados orm_example (que nomeamos no .env) na raiz do projeto:

EX:

env $(cat .env) npx sequelize db:create

NOTA: o comando env $(cat .env) ir√° realizar a leitura das vari√°veis do arquivo .env e repass√°-las para o pr√≥ximo comando, disponibilizando assim os valores das vari√°veis de ambiente para o seu c√≥digo atrav√©s do process.env.NOME_DA_VARIAVEL.

De olho na dica üëÄ: O .sequelizerc procura os arquivos de configura√ß√£o do Sequelize no diret√≥rio src. Por isso, √© importante que voc√™ esteja na raiz do projeto quando for rodar os comandos do Sequelize.

* No seu terminal, o Sequelize vai avisar que o database foi criado. Voc√™ pode verificar isso no pr√≥prio MySQL utilizando os comandos abaixo:

‚û°Ô∏è Execute o container criado anteriormente com o comando:

EX:

docker exec -it container-mysql bash

‚û°Ô∏è Entre no terminal do mysql com o comando:

mysql -u root -p

‚û°Ô∏è Digite a sua senha de acesso ao mysql e em seguida rode o comando abaixo:

show databases;

‚û°Ô∏è Perceba que, a partir desses passos, o banco orm_example foi criado e voc√™ n√£o precisou escrever nenhuma linha de SQL para isso. Essa √© uma das primeiras vantagens que o Sequelize nos oferece.

# MODEL  = Os models s√£o a ess√™ncia do Sequelize. Um model √© uma abstra√ß√£o que representa uma linha na tabela em seu banco de dados e passa v√°rias informa√ß√µes ao Sequelize sobre essa entidade, como o nome e quais atributos (colunas) ela possui (e seus tipos de dados).

* Vamos dar um exemplo para ficar mais evidente! Queremos criar uma tabela users, que cont√©m dados de v√°rias pessoas usu√°rias.

O que fazemos primeiro √© criar um model que vai representar uma pessoa em nossa aplica√ß√£o, ou uma linha na tabela users no nosso banco (vamos ver a tabela sendo criada no pr√≥ximo t√≥pico).
Crie um arquivo user.model.js na pasta model com o seguinte conte√∫do:

EX:

// src/models/user.model.js

const UserModel = (sequelize, DataTypes) => {
  const User = sequelize.define('User', {
    fullName: DataTypes.STRING,
    email: DataTypes.STRING,
  });

  return User;
};

module.exports = UserModel;

Perceba que adicionamos as colunas fullName e email no nosso model, ambas do tipo string.

Note tamb√©m que o nome do arquivo model √© user.model.js e que o nome da fun√ß√£o definida nele tamb√©m est√° no singular (User). Isso √© uma conven√ß√£o. Geralmente os models s√£o nomeados no singular, j√° que representam um registro (o equivalente a uma linha) da tabela, enquanto as tabelas s√£o nomeadas no plural. Como n√£o explicitamos o nome da tabela no model, por padr√£o, o Sequelize coloca no plural o nome do model e o usa como nome da tabela. No nosso caso, o model se chama user e nossa tabela Users, portanto, funciona perfeitamente.

* Utilizando o build
Antes de usarmos as fun√ß√µes, vamos adicionar uma nova linha no nosso arquivo user.model.js. Ela vai ser respons√°vel por sincronizar a model com os m√©todos do Sequelize:

EX:

// src/models/user.model.js
// const UserModel = (sequelize, DataTypes) => {
//  const User = sequelize.define('User', {
//    fullName: DataTypes.STRING,
//    email: DataTypes.STRING,
//  });
  (async () => {
    await sequelize.sync({ force: true });
    // As fun√ß√µes v√£o aqui
})();
//  return User;
// };
// module.exports = UserModel;

Note que o m√©todo sync est√° sendo chamado com o par√¢metro force: true. Isso significa que, toda vez que o servidor for iniciado, a tabela ser√° recriada. Isso √© √∫til para testes, mas n√£o deve ser usado em produ√ß√£o.

* Vamos ent√£o criar a nossa Model com o m√©todo build. O m√©todo build √© √∫til para criar uma inst√¢ncia de um model, mas sem salv√°-la no banco de dados. Podemos usar essa fun√ß√£o quando queremos criar um objeto que vai armazenar dados tempor√°rios, por exemplo:

EX:

const sara = User.build({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara instanceof User); // true
console.log(sara.fullName); // "Sara Silva Santos"

Note que o c√≥digo acima n√£o √© ass√≠ncrono, o que significa que o m√©todo build n√£o se comunica com o banco de dados. Isso acontece por que essa fun√ß√£o cria uma inst√¢ncia de um model, que representa os dados que ir√£o ser salvos no banco de dados, mas n√£o os salva. 

* Para salvar os dados no banco de dados, o m√©todo save deve ser utilizado:

EX:

await sara.save();
console.log('Pessoa salva no banco de dados!');

O m√©todo save √© ass√≠ncrono, por isso ele deve ser utilizado com await.

* Criando com create
Uma forma mais simples de criar uma inst√¢ncia de um model e salv√°-la no banco de dados √© usando o m√©todo create, que combina o build e o save em uma √∫nica fun√ß√£o:

EX:

const sara = await User.create({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara instanceof User); // true
console.log(sara.name); // "Sara Silva Santos"

Note que o m√©todo create √© ass√≠ncrono, pois ele se comunica com o banco de dados para criar a inst√¢ncia do model.

* Modificando informa√ß√µes no banco de dados
Quando trocamos informa√ß√µes de um model, precisamos salvar essas altera√ß√µes no banco de dados. Para isso, podemos usar o m√©todo save:

EX:

const sara = await User.create({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara.fullName); // "Sara Silva Santos"

sara.fullName = "Jane Doe";

// O nome ainda est√° "Sara Silva Santos" no banco de dados!

await sara.save();

// Agora o nome foi atualizado para "Jane Doe" no banco de dados!

* Tamb√©m √© poss√≠vel atualizar diversos campos de uma vez usando o m√©todo set:

EX:

const lucas = await User.create({
  fullName: 'Lucas Silva Santos',
  email: 'lucas.ss@trybe.com',
});

lucas.set({
  fullName: "Pedro Silva Santos",
  email: "pedro.ss@trybe.com"
});

// O nome ainda est√° "Lucas Silva Santos" no banco de dados!

await lucas.save();

// Agora o nome foi atualizado para "Pedro Silva Santos", e o email para pedro.ss@trybe.com no banco de dados!

Note que chamar a fun√ß√£o save no arquivo, vai atualizar todos os campos que foram alterados, n√£o apenas os que foram modificados atrav√©s do m√©todo set. 

* Para atualizar apenas os campos espec√≠ficos que foram modificados, podemos usar o m√©todo update:

EX:

const jane = await User.create({
fullName: "Jane Doe",
email: "jane.doe@trybe.com",
});

jane.email = "ada.doe@trybe.com";
await jane.update({ fullName: "Ada Joe" });

// O banco de dados agora tem "Ada Joe" para o nome, mas o email ainda √© "jane.doe@trybe.com".

await jane.save();
// O banco de dados agora tem "ada.doe@trybe.com" para o email.

* Excluindo informa√ß√µes do banco de dados
Quando precisamos excluir um model do banco de dados, podemos usar o m√©todo destroy:

EX:

const mario = await User.create({ fullName: "Mario Bors" });

console.log(mario.fullName); // "Mario Bors"

await mario.destroy();

// Agora essa entrada n√£o existe mais no banco de dados!

# MIGRATIONS  = Uma migration √© uma forma de versionar o schema do banco de dados. Ou seja, cada migration conter√° um peda√ßo de c√≥digo que representa o hist√≥rico das altera√ß√µes feitas no nosso banco de dados.

üí™ Vamos trazer isso pra pr√°tica!

Imagine o seguinte: voc√™ escreve um c√≥digo definindo como um banco de dados deve ser criado e esse c√≥digo fica salvo em um arquivo na pasta migrations. Ap√≥s um tempo, uma atualiza√ß√£o √© feita e uma coluna √© acrescentada em uma tabela. O que voc√™ faz?

Voc√™ vai escrever o c√≥digo em outro arquivo para acrescentar essa coluna, certo? Pense que, cada arquivo ser√° marcado com uma estampa datetime, ent√£o ao longo do tempo esse c√≥digo vai empilhando dezenas, √†s vezes centenas, de arquivos. Cada um desses arquivos marca uma vers√£o do banco de dados e o seu hist√≥rico de mudan√ßas e evolu√ß√µes.

Quem clona um projeto pela primeira vez, roda suas migrations para configurar o banco de dados no formato mais recente enviado para a main (ou branch principal), sem ter que fazer mais nada. A√≠ sim √© poss√≠vel trabalhar localmente no banco de dados da aplica√ß√£o sem medo de ele ser diferente da vers√£o mais nova que encontramos na main.

Usando migrations, o mapeador objeto-relacional sabe exatamente quais altera√ß√µes executar no banco de dados, tanto para criar algo novo quanto para restaurar o banco para uma vers√£o mais antiga. Al√©m disso, uma migration tem dois c√≥digos conhecidos como Up e Down. Ou seja: toda migration, al√©m de saber o que fazer para executar as mudan√ßas no banco de dados (Up), tamb√©m deve saber como reverter essas mudan√ßas (Down). Isso significa que as migrations t√™m o poder de avan√ßar ou reverter o seu banco de dados para qualquer um dos estados que ele j√° teve.

EX:

(imagem salva na pasta "exemplo-migrations.png")

*  Agora vamos gerar um novo arquivo, com apenas o ‚Äúesqueleto‚Äù de uma migration, usando o seguinte comando no terminal:

EX:

npx sequelize migration:generate --name create-user

* Com isso, um novo arquivo [timestamp]-create-user.js ser√° criado na pasta migrations contendo o seguinte c√≥digo:

EX:

// src/migrations/[timestamp]-create-user.js

'use strict';

module.exports = {
  async up (queryInterface, Sequelize) {
    /**
     * Add altering commands here.
     *
     * Example:
     * await queryInterface.createTable('users', { id: Sequelize.INTEGER });
     */
  },

  async down (queryInterface, Sequelize) {
    /**
     * Add reverting commands here.
     *
     * Example:
     * await queryInterface.dropTable('users');
     */
  }
};

Ao serem criadas pelo Sequelize, os arquivos de migrations e seeds t√™m seus nomes iniciados por um timestamp, que √© seguido pelo nome que n√≥s definimos no comando, gerando ao final um arquivo de nome similar a 20220827010852-create-user.js.

* Agora vamos mexer apenas dentro das fun√ß√µes up e down. Repare que ambas as fun√ß√µes recebem dois par√¢metros: um √© o queryInterface, e o outro √© o Sequelize. Ambos os par√¢metros s√£o objetos que armazenam dados e opera√ß√µes. O queryInterface √© usado pela biblioteca para modificar o banco de dados, seguindo o ‚Äúdialeto‚Äù do banco que estamos utilizando. O objeto Sequelize armazena os tipos de dados dispon√≠veis no contexto do banco, por exemplo varchar, string, integer, date etc.

‚û°Ô∏è O objetivo da nossa migration √© criar a tabela users com os seguintes campos e condi√ß√µes:

id: Identificador do item.

√â uma chave prim√°ria;
Valor n√£o pode ser nulo;
Possui incremento autom√°tico;
√â do tipo Integer.
fullName: Nome completo da pessoa usu√°ria da aplica√ß√£o.

√â do tipo String.
email: E-mail da pessoa usu√°ria da aplica√ß√£o.

√â do tipo String.
createdAt: Data da cria√ß√£o do item.

Valor n√£o pode ser nulo;
√â do tipo Date.
updatedAt: Data da atualiza√ß√£o do item.

Valor n√£o pode ser nulo;
√â do tipo Date.
Podemos criar a tabela Users atrav√©s da fun√ß√£o createTable do queryInterface. A fun√ß√£o createTable recebe dois par√¢metros:

O primeiro recebe uma string com o nome da tabela;
O segundo recebe um objeto com os campos, e suas condi√ß√µes, da tabela.
Lembra da conven√ß√£o que mencionamos anteriormente, na qual o nome do model √© no singular e o nome da tabela √© no plural? √â por esta raz√£o que na fun√ß√£o createTable o nome especificado ser√° "Users". üòâ

* Para come√ßar, chamamos a fun√ß√£o createTable passando o nome da tabela dentro do bloco de execu√ß√£o (up):

‚ö†Ô∏è Usamos o await porque a fun√ß√£o createTable √© ass√≠ncrona!

EX:

// src/migrations/[timestamp]-create-user.js

// 'use strict';

// module.exports = {
//   up: async (queryInterface, Sequelize) => {
       await queryInterface.createTable('Users', {});
//   },

//   down: async (queryInterface, Sequelize) => {
      /**
       * Add reverting commands here.
       *
       * Example:
       * await queryInterface.dropTable('users');
       */
//   }
// };

* Agora vamos adicionar todos os campos da nossa tabela e suas determinadas condi√ß√µes:

EX:

// src/migrations/[timestamp]-create-user.js

// 'use strict';

// module.exports = {
//   up: async (queryInterface, Sequelize) => {
       await queryInterface.createTable('Users', {
         id: {
           allowNull: false,
           autoIncrement: true,
           primaryKey: true,
           type: Sequelize.INTEGER
         },
         fullName: {
           type: Sequelize.STRING
         },
         email: {
           type: Sequelize.STRING
         },
         createdAt: {
           allowNull: false,
           type: Sequelize.DATE
         },
         updatedAt: {
           allowNull: false,
           type: Sequelize.DATE
         }
       });
//   },

//   down: async (queryInterface, Sequelize) => {
      /**
       * Add reverting commands here.
       *
       * Example:
       * await queryInterface.dropTable('users');
       */
//   }
// };

‚û°Ô∏è Percebeu que cada campo possui um objeto representando as propriedades daquele campo em espec√≠fico? Veja o que s√£o cada uma dessas propriedades:

allowNull: Define se o campo pode ou n√£o receber um valor null;
autoIncrement: Define se o campo vai ter incremento autom√°tico;
primaryKey: Define se o campo √© uma chave prim√°ria;
type: Define o tipo do campo, por exemplo STRING, INTEGER, DATE, etc.

* Agora vamos implementar o bloco de revers√£o (down) com um c√≥digo que vai apenas apagar a tabela caso seja necess√°rio desfazer a opera√ß√£o de execu√ß√£o (up). Assim escreveremos uma migration perfeitamente revers√≠vel!

EX:

// src/migrations/[timestamp]-create-user.js

//  'use strict';

//  module.exports = {
//    up: async (queryInterface, Sequelize) => {
//      ...
//    },
//    down: async (queryInterface, Sequelize) => {
        await queryInterface.dropTable('Users');
//    }
//  };

‚ö†Ô∏èImportante: se o c√≥digo da migration tiver erros, as suas migrations podem n√£o executar corretamente os processos de criar ou desfazer uma nova vers√£o do banco. √â preciso ter bastante cuidado na hora de mexer no c√≥digo de uma migration.

‚ö†Ô∏èImportante: A execu√ß√£o de uma migration requer o uso das vari√°veis de ambiente, uma vez que ser√° realizado um acesso ao banco de dados.

* Com a migration criada, basta executarmos o seguinte comando pelo CLI:

EX:

env $(cat .env) npx sequelize db:migrate

* Caso queira reverter uma migration use o seguinte comando:

EX:

env $(cat .env) npx sequelize db:migrate:undo

* Criando uma nova migration para alterar uma tabela j√° existente
Imagine agora, com base no modelo User, se for preciso salvar o telefone do usu√°rio. O que pode vir √† mente √© que basta adicionar o novo atributo no modelo e na migration, como fizemos com o atributo email anteriormente, correto?

‚ùå Errado, essa √© uma pr√°tica que n√£o √© escal√°vel! Imagine que foi feito um deploy do seu c√≥digo e a migration foi usada para criar o banco em ambiente de produ√ß√£o. Nesse caso, voc√™ teria que rodar o comando db:migrate:undo e recriar o banco para executar o comando db:migrate, para ent√£o recriar uma tabela. O problema disso √© que ao rodar o undo voc√™ perde todos os dados salvos anteriormente na tabela, e isso √© uma coisa que jamais deve ser feita. Anotou a√≠?

Ent√£o qual seria a forma correta de adicionar uma nova coluna em uma tabela j√° existente?

‚úîÔ∏è A resposta certa √©: criar uma nova migration que permita alterar a tabela. Para isso, o objeto queryInterface possui fun√ß√µes espec√≠ficas, que permitem criar uma nova coluna, remover uma coluna ou mesmo mudar o tipo de uma coluna que j√° existe. Nesse caso, o queryInterface abstrai o que a fun√ß√£o ALTER TABLE faz no SQL. Deseja saber mais sobre ALTER TABLE e est√° com sua gest√£o de tempo em dia? Consulte o conte√∫do adicional sobre o assunto.

Lembre-se que a tabela Users tem que estar criada para que os passos a seguir sejam executados com sucesso, portanto, se voc√™ reverteu a migration que a criava, refa√ßa-a com o comando npx sequelize db:migrate.

* Para criar uma outra migration para adicionar a coluna phoneNum na sua tabela Users, voc√™ deve criar um novo arquivo com o seguinte comando:

EX:

npx sequelize migration:generate --name add-column-phone-table-users

Com isso, um novo arquivo [timestamp]-add-column-phone-table-users.js ser√° criado.

* Agora podemos inserir a fun√ß√£o queryInterface.addColumn() no escopo Up para adicionar uma nova coluna √† nossa tabela Users, e adicionar a fun√ß√£o queryInterface.removeColumn() no escopo Down para remover a nova coluna da tabela. Veja como fazer isso a partir do c√≥digo abaixo:

EX:

// src/migrations/[timestamp]-add-column-phone-table-users.js

'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
   await queryInterface.addColumn('Users', 'phoneNum', {
     type: Sequelize.STRING,
   });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('Users', 'phoneNum');
  }
};

*  Em seguida rodamos o comando abaixo para executar a nossa nova migration:

EX:

env $(cat .env) npx sequelize db:migrate

* Tamb√©m devemos alterar o model user.model.js para incluir a nova coluna phoneNum da seguinte forma:

EX:

// src/models/user.model.js

// const User = (sequelize, DataTypes) => {
//   const User = sequelize.define('User', {
//     fullName: DataTypes.STRING,
//     email: DataTypes.STRING,
       // aqui inserimos o datatype da coluna criada
       phoneNum: DataTypes.STRING,
//   });
// 
//   return User;
// };

// module.exports = User;

‚û°Ô∏è Pronto! Conseguimos criar uma migration para adi√ß√£o da coluna phoneNum na tabela Users. Desta maneira, se outra pessoa for alterar este projeto em outra m√°quina, ela pode executar as migrations e atualizar o banco de dados local com as modifica√ß√µes feitas por voc√™!

# SEEDERS  = agora chegou o momento de aprender a popular nosso banco de dados utilizando o Seeders. Podemos configurar nosso banco para ser automaticamente criado e povoado.

* As seeds seguem a mesma linha das migrations, portanto primeiramente vamos precisar executar a cria√ß√£o de uma nova seed pelo CLI:

EX:

npx sequelize seed:generate --name users

Reparem que o arquivo foi criado dentro da pasta seeders com o mesmo formato do arquivo de uma migration. 

* Agora, devemos adicionar ao arquivo criado quais informa√ß√µes aquele seed vai gerar. O c√≥digo abaixo vai adicionar dois usu√°rios ao banco de dados:

EX:

// src/seeders/[timestamp]-users.js

'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => queryInterface.bulkInsert('Users',
    [
      {
        fullName: 'Leonardo',
        email: 'leo@test.com',
        // usamos a fun√ß√£o CURRENT_TIMESTAMP do SQL para salvar a data e hora atual nos campos `createdAt` e `updatedAt`
        createdAt: Sequelize.literal('CURRENT_TIMESTAMP'),
        updatedAt: Sequelize.literal('CURRENT_TIMESTAMP'),
      },
      {
        fullName: 'JEduardo',
        email: 'edu@test.com',
        createdAt: Sequelize.literal('CURRENT_TIMESTAMP'),
        updatedAt: Sequelize.literal('CURRENT_TIMESTAMP'),
      },
    ], {}),

  down: async (queryInterface) => queryInterface.bulkDelete('Users', null, {}),
};

Na fun√ß√£o acima, estamos utilizando o par√¢metro recebido pela fun√ß√£o queryInterface para conversar com o banco de dados. Dessa forma, conseguimos inserir os dados que queremos. Tamb√©m estamos adicionando os dados, que est√£o na estrutura de uma array de objetos, na tabela users. O queryInterface tem a fun√ß√£o bulkInsert, a qual estamos utilizando, que insere m√∫ltiplos dados na tabela.

Note que a seed segue o mesmo princ√≠pio de up e down, ou seja, devemos colocar tamb√©m o que a seed deve fazer caso precise reverter a opera√ß√£o. Aqui, um c√≥digo ruim pode quebrar o fluxo de uso/revers√£o dos seeds, ent√£o escreva com aten√ß√£o!

* Para executar a seed, basta rodarmos o comando abaixo:

EX:

env $(cat .env) npx sequelize db:seed:all

* Para reverter o seed, use o seguinte comando:

EX:

env $(cat .env) npx sequelize db:seed:undo:all

# Implementando a listagem de pessoas usu√°rias

Caso precisemos buscar todas as pessoas usu√°rias, por exemplo, basta criarmos os diret√≥rios e arquivos para nossos services e controllers e preench√™-los como no c√≥digo abaixo:

EX: SERVICE

// src/services/user.service.js

const { User } = require('../models');

/* Esta fun√ß√£o usa o m√©todo findAll do Sequelize para buscar todas as linhas da tabela Users
Equivale a fazer a query: SELECT * FROM Users */
const getAll = async () => {
  const users = await User.findAll();

  return users;
};

module.exports = {
  getAll,
};

EX: CONTROLLER

// src/controllers/user.controller.js

const UserService = require('../services/user.service');

const getAll = async (_req, res) => {
  try {
    const users = await UserService.getAll();
    return res.status(200).json(users);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: 'Ocorreu um erro' });
  }
};

module.exports = {
  getAll,
};

Note que n√£o precisamos escrever uma query SQL para buscar os dados, pois o Sequelize abstrai isso para n√≥s. Ele oculta essa complexidade e nos prov√™ uma forma menos trabalhosa de escrever esse c√≥digo.

Repare que estamos importando o modelo que criamos do arquivo index.js da pasta models, e n√£o diretamente do arquivo user.models.js. Quando executamos o comando npx sequelize init, o arquivo index.js √© gerado dentro da pasta models.

O c√≥digo desse arquivo index.js √© respons√°vel por:

Realizar a conex√£o com o banco de dados, por meio do arquivo config.json ou config.js;
Coletar todos os modelos definidos dentro da pasta models e;
Caso necess√°rio, associar um modelo a algum outro.

* Agora precisamos criar nossos arquivos app.js e server.js com os c√≥digo logo abaixo dentro da pasta src. Teste e veja o comportamento de uma aplica√ß√£o utilizando o Sequelize.

EX:

// src/app.js

const express = require('express');

const User = require('./controllers/user.controller');

const app = express();

app.use(express.json());

app.get('/user', User.getAll);

module.exports = app;

EX:

// src/server.js

const app = require('./app');

const PORT = process.env.PORT || 3001;

app.listen(PORT, () => {
  console.log(`Escutando na porta ${PORT}`);
});

* Antes de executar a aplica√ß√£o, precisamos adicionar o Express e o nodemon como depend√™ncias da nossa aplica√ß√£o:

EX:

npm install -E express@4.17
npm install -D -E nodemon@2.0.15

* Agora, altere a chave no package.json a chave main para que aponte para o arquivo server.js: e adicione o script dev para rodar sua aplica√ß√£o.

EX:

//  {
//  ...
  "main": "src/server.js",
//  ...
  "scripts": {
    "dev": "nodemon src/server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
//  ...
//  }

Agora voc√™ pode executar o comando "env $(cat .env) npm run dev" e testar fazer uma requisi√ß√£o para URL http://localhost:3001/user. Como acabamos de criar o banco de dados e a tabela Users nas li√ß√µes anteriores, a resposta da requisi√ß√£o ser√° um array com duas pessoas usu√°rias, essas pessoas s√£o as que foram inseridas gra√ßas ao Seeder que foi criado e executado anteriormente.

* Implementando os demais endpoints do CRUD de pessoas usu√°rias
O caso que mostramos acima foi para buscar todas as pessoas usu√°rias, mas conseguimos realizar todas as outras opera√ß√µes de consulta, inser√ß√£o e dele√ß√£o tamb√©m:

EX: SERVICE

// src/services/user.service.js

// const { User } = require('../models/');

// const getAll = async () => {
//   const users = await User.findAll();

//   return users;
// };

/* Esta fun√ß√£o usa o m√©todo findByPk do Sequelize para buscar um usu√°rio pelo id.
Equivale a fazer a query: SELECT * FROM Users WHERE id=? */
const getById = async (id) => {
  const user = await User.findByPk(id);

  return user;
};

/* Esta fun√ß√£o usa o m√©todo findOne do Sequelize combinado 
com a chave where para buscar por id e email. 
Equivale a fazer a query: SELECT * FROM Users WHERE id=? AND email=? */
const getByIdAndEmail = async (id, email) => {
  const user = await User.findOne({ where: { id, email } });

  return user;
};

/* Esta fun√ß√£o usa o m√©todo create do Sequelize para inserir um objeto na tabela Users
Equivale a fazer a query: INSERT INTO Users (full_name, email) VALUES (?, ?) */
const createUser = async (fullName, email) => {
  const newUser = await User.create({ fullName, email });

  return newUser;
};

/* Esta fun√ß√£o usa o m√©todo update do Sequelize para atualizar um objeto na tabela Users
Equivale a fazer a query: UPDATE Users SET full_name=?, email=? WHERE id=?*/
const updateUser = async (id, fullName, email) => {
  const [updatedUser] = await User.update(
    { fullName, email },
    { where: { id } },
  );

  console.log(updatedUser); // confira o que √© retornado quando o user com o id √© ou n√£o encontrado;
  return updatedUser;
};

/* Esta fun√ß√£o usa o m√©todo destroy do Sequelize para remover um objeto na tabela Users
Equivale a fazer a query: DELETE FROM Users WHERE id=?*/
const deleteUser = async (id) => {
  const user = await User.destroy(
    { where: { id } },
  );

  console.log(user); // confira o que √© retornado quando o user com o id √© ou n√£o encontrado;
  return user;
};

module.exports = {
  getAll,
  getById,
  getByIdAndEmail,
  createUser,
  updateUser,
  deleteUser,
};

EX: CONTROLLER

// src/controllers/user.controller.js

// const UserService = require('../services/user.service');

const error500Message = 'Algo deu errado';

// const getAll = async (_req, res) => {
//   try {
//     const users = await UserService.getAll();
//     return res.status(200).json(users);
//   } catch (e) {
//     console.log(e.message);
//     res.status(500).json({ message: 'Ocorreu um erro' });
//   }
// };

const getById = async (req, res) => {
  try {
    const { id } = req.params;
    const user = await UserService.getById(id);

    if (!user) return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });

    return res.status(200).json(user);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

const getByIdAndEmail = async (req, res) => {
  try {
    const { id } = req.params;
    const { email } = req.query;
    const user = await UserService.getByIdAndEmail(id, email);

    if (!user) return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });

    return res.status(200).json(user);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

const createUser = async (req, res) => {
  try {
    const { fullName, email } = req.body;
    const newUser = await UserService.createUser(fullName, email);

    return res.status(201).json(newUser);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

const updateUser = async (req, res) => {
  try {
    const { fullName, email } = req.body;
    const { id } = req.params;
    const updatedUser = await UserService.updateUser(id, fullName, email);

    if (!updatedUser) return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });

    return res.status(200).json({ message: 'Usu√°rio atualizado com sucesso!' });
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

const deleteUser = async (req, res) => {
  try {
    const { id } = req.params;
    await UserService.deleteUser(id);

    return res.status(200).json({ message: 'Usu√°rio exclu√≠do com sucesso!' });
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

module.exports = {
  getAll,
  getById,
  getByIdAndEmail,
  createUser,
  updateUser,
  deleteUser,
};

EX: APP

// src/app.js

// const express = require('express');

// const User = require('./controllers/user.controller');

// const app = express();

// app.use(express.json());

// app.get('/user', User.getAll);

// Este endpoint usa o m√©todo findByPk do Sequelize para buscar um usu√°rio pelo id.
app.get('/user/:id', User.getById);

// Este endpoint usa o m√©todo findOne do Sequelize para buscar um usu√°rio pelo id e email.
// URL a ser utilizada para o exemplo "http://localhost:3001/user/search/1?email=leo@test.com"
app.get('/user/search/:id', User.getByIdAndEmail);

// Este endpoint usa o m√©todo create do Sequelize para salvar um usu√°rio no banco.
app.post('/user', User.createUser);

// Este endpoint usa o m√©todo update do Sequelize para alterar um usu√°rio no banco.
app.put('/user/:id', User.updateUser);

// Este endpoint usa o m√©todo destroy do Sequelize para remover um usu√°rio no banco.
app.delete('/user/:id', User.deleteUser);

// module.exports = app;

* Testes
Para testarmos os models criados com o Sequelize, seguiremos os mesmos conceitos vistos anteriormente: vamos isolar as opera√ß√µes de IO e utilizaremos bibliotecas espec√≠ficas para nos ajudar com os stubs e asser√ß√µes.

* Antes de come√ßar a realizar os testes, vamos instalar nossas depend√™ncias de desenvolvimento como nas aulas anteriores:

EX:

npm i mocha@10.0.0 chai@4.3.4 sinon@14.0.0 chai-http@4.3.0 -D -E

* Agora vamos alterar a linha abaixo em nosso package.json para executar nossos testes com o comando npm test, como nas aulas anteriores:

EX:

// package.json

"scripts": {
  ...
  "test": "mocha tests/**/*$NAME*.test.js --exit"
},

* Para testar um model com Sequelize, podemos utilizar bibliotecas espec√≠ficas para nos ajudar nessa tarefa. Uma bastante utilizada √© a Sequelize Test Helpers. Vamos ver um exemplo de como podemos utiliz√°-la:

Use o comando abaixo para instalar a biblioteca Sequelize Test Helpers:

EX:

npm i sequelize-test-helpers@1.4.3 -D -E

* Crie o arquivo abaixo na raiz do projeto e depois rode npm test:

EX:

// tests/unit/models/user.test.js

const {
  sequelize,
  dataTypes,
  checkModelName,
  checkPropertyExists,
} = require('sequelize-test-helpers');

const UserModel = require('../../../src/models/user.model');

describe('O model de User', () => {
  const User = UserModel(sequelize, dataTypes);
  const user = new User();

  describe('possui o nome "User"', () => {
    checkModelName(User)('User');
  });

  describe('possui as propriedades "fullName" e "email"', () => {
    ['fullName', 'email'].forEach(checkPropertyExists(user));
  });
});

√â poss√≠vel fazer essas asser√ß√µes diretamente, por√©m esse m√≥dulo j√° possui diversas fun√ß√µes prontas para facilitar a escrita dos testes.


















