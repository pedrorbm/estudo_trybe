# ORM  = Mapeamento objeto-relacional ou ORM (Object-Relational Mapping) √© uma t√©cnica que permite fazer um mapeamento estrutural entre as entidades do banco de dados e os objetos que as representam no c√≥digo JavaScript. O mapeamento objeto-relacional abstrai as diferen√ßas entre os dois paradigmas, da aplica√ß√£o e do banco de dados, como podemos ver na imagem a seguir (imagem armazenada na pasta orm-exemplo.png)

Com ORM n√£o precisamos mais escrever uma query SQL ‚Äúcrua‚Äù para cada vez que formos inserir um registro na tabela. A pr√≥pria biblioteca fica respons√°vel por isso. Voc√™ apenas passa o objeto JavaScript para ela e ela insere os dados no banco de dados.

No Node.js, temos o Sequelize, uma biblioteca de ORM bem conhecida e com suporte aos bancos de dados PostgreSQL, MariaDB, MySQL, SQLite e Microsoft SQL Server. √â justamente nessa biblioteca de ORM que vamos nos aprofundar no conte√∫do.

* sequelize  = (imagem na pasta estapas-para-implementacao-do-sequelize.png)
Esse processo pode parecer complexo, mas o Sequelize possui muitas vantagens sobre a utiliza√ß√£o de uma interface direta com o MySQL. Quando tentamos fazer a intera√ß√£o direta com o banco de dados, enfrentamos problemas como:

O JavaScript sozinho n√£o possui um suporte eficiente para o SQL, voc√™ precisaria de um script SQL separado para criar seu database e tabelas.
As queries SQL precisam ser incorporadas (‚Äúembedadas‚Äù) no c√≥digo do JavaScript para serem utilizadas.
Por causa dessas limita√ß√µes, acabamos apenas incluindo boilerplates de SQL em vez de utilizar a L√≥gica de Neg√≥cio na nossa aplica√ß√£o.
‚úèÔ∏èAnote a√≠: boilerplates s√£o trechos de c√≥digo que podem ser reutilizados em muitos lugares com pouca ou nenhuma altera√ß√£o.

Esses s√£o alguns problemas que o Sequelize ajuda a resolver! Com ele, voc√™ pode evitar a cria√ß√£o de queries SQL para produzir as tabelas. Com o uso das models e migrations no Sequelize, o seu c√≥digo se torna mais leg√≠vel, extens√≠vel e de f√°cil manuten√ß√£o.

Al√©m disso, por meio do mapeamento por objetos relacionais, √© poss√≠vel criar as rela√ß√µes e associa√ß√µes entre as tabelas com o pr√≥prio JavaScript. E ainda, √© poss√≠vel migrar seu database para outro banco de dados sem precisar reescrever todo o c√≥digo (por exemplo: mudar de MySQL para o SQL server).

* instala√ßao do sequelize

EX:

npm install -E sequelize@6.3.4

* O pr√≥ximo passo para utilizar o Sequelize √© instalar um CLI, que √© respons√°vel por gerar e executar as opera√ß√µes. Al√©m de instalar o CLI, tamb√©m precisamos instalar o mysql2, uma depend√™ncia necess√°ria para usarmos o MySQL com o Sequelize. Na pasta raiz da aplica√ß√£o, rode os comandos: (OBS: FORA DA PASTA "./SRC")

EX:

npm install -D -E sequelize-cli@6.2.0

npm install -E mysql2@2.1.0

mkdir src

* Depois que instalamos o CLI, precisamos iniciar um projeto com o Sequelize. Para isso, vamos executar o seguinte comando dentro da pasta src:

EX:

cd src

npx sequelize-cli init

Esse comando vai criar as seguintes pastas:

config: cont√©m um arquivo de configura√ß√£o, com orienta√ß√µes para o CLI se conectar com o nosso banco de dados;

models: cont√©m todos os modelos da nossa aplica√ß√£o;

migrations: cont√©m todos os arquivos de migra√ß√£o da nossa aplica√ß√£o;

seeders: cont√©m todos os arquivos de ‚Äúseeds‚Äù (sementes que s√£o usadas para popular o banco).

‚û°Ô∏è O arquivo .sequelizerc

O arquivo .sequelizerc √© um arquivo de configura√ß√£o do Sequelize. Esse arquivo √© respons√°vel por configurar o caminho das pastas migrations, models, seeders e config que o Sequelize ir√° procurar ao executar um comando.

Por padr√£o, ao rodar um comando Sequelize os arquivos dentro das pastas de migrations, models, seeders e config seriam procurados somente na camada em que estiv√©ssemos executando o comando. No nosso caso, como estamos utilizando a pasta src para abrigar os arquivos do Sequelize, caso execut√°ssemos um comando diretamente na raiz da aplica√ß√£o, ir√≠amos nos deparar com um erro.

Podemos entrar na pasta src e executar estes comandos, como fizemos anteriormente, pois assim teremos √™xito. Mas caso fosse uma aplica√ß√£o maior, com mais camadas, aumentar√≠amos a complexidade de subir e configurar a aplica√ß√£o.

√â neste momento que entra em cena o arquivo .sequelizerc. Dessa forma, podemos construir um c√≥digo com uma arquitetura mais organizada. ‚≠ê

* Antes de configurar esse arquivo, volte para a pasta raiz da aplica√ß√£o com o seguinte comando:

EX:

cd ..

* Agora crie um arquivo com o nome .sequelizerc com o seguinte conte√∫do: (O arquivo .sequelizerc √© um arquivo de configura√ß√£o do Sequelize e deve ser criado na pasta raiz. Nesse caso, a pasta app-with-sequelize.)

EX:

// app-with-sequelize/.sequelizerc

const path = require('path');

module.exports = {
  'config': path.resolve('src', 'config', 'config.js'),
  'models-path': path.resolve('src', 'models'),
  'seeders-path': path.resolve('src', 'seeders'),
  'migrations-path': path.resolve('src', 'migrations'),
};

Vamos entender melhor as informa√ß√µes deste arquivo:

path: √© um m√≥dulo interno do Node que nos fornece alguns utilit√°rios para trabalharmos com caminhos de arquivos e diret√≥rios;

config: √© um caminho para o arquivo de configura√ß√£o;

models-path: √© um caminho para o diret√≥rio de models;

seeders-path: √© um caminho para o diret√≥rio de seeders;

migrations-path: √© um caminho para o diret√≥rio de migrations.

* Agora precisamos configurar o arquivo config.json gerado pelo init do CLI. Ao alterar esse arquivo, estamos configurando o acesso da aplica√ß√£o ao nosso banco de dados.

‚û°Ô∏è Note que o arquivo config.json, localizado no diret√≥rio ./src/config, cont√©m informa√ß√µes sens√≠veis, como credenciais de acesso ao banco de dados, expostas no nosso c√≥digo. Uma boa pr√°tica √© substituir os valores por vari√°veis de ambiente, n√£o expondo assim, informa√ß√µes sens√≠veis relacionados √† configura√ß√£o geral da aplica√ß√£o. Ent√£o, vamos fazer isso do jeito certo!

‚û°Ô∏è Mudaremos o nome do nosso arquivo config.json para config.js

‚û°Ô∏è Retiraremos todo o conte√∫do de config.js e substituiremos pelo c√≥digo abaixo:

EX:

// src/config/config.js

const config = {
  username: process.env.MYSQL_USER,
  password: process.env.MYSQL_PASSWORD,
  database: process.env.MYSQL_DATABASE,
  host: process.env.MYSQL_HOST,
  dialect: 'mysql',
};

module.exports = {
  development: config,
  test: config,
  production: config,
};

Vamos entender melhor as informa√ß√µes que estamos passando:

username: usu√°rio de acesso ao banco de dados;

password: senha de acesso ao banco de dados;

database: nome do banco de dados no qual queremos conectar;

host: servidor no qual estamos conectando - por ser local, utilizamos o endere√ßo IP 127.0.0.1, ou seu alias localhost;

dialect: informa qual a biblioteca que o sequelize utiliza para se conectar ao banco de dados estamos utilizando. Nesse caso, mysql.

* Modifique o arquivo src/models/index.js para apontar para o arquivo config.js:

EX:

Para fazer isso, busque neste arquivo, a seguinte linha de c√≥digo:

const config = require(__dirname + '/../config/config.json')[env]; // configura√ß√£o antiga

Altere esta linha para ficar assim:

/ Praticamente √© s√≥ mudar a extens√£o de .json para .js! /
const config = require(__dirname + '/../config/config.js')[env]; // configura√ß√£o nova

* Antes de rodar os comandos Sequelize, precisamos garantir que temos uma inst√¢ncia do MySQL rodando.

Caso voc√™ j√° tenha um container com uma imagem do MySQL, pode utiliz√°-lo ou usar o comando abaixo no terminal para criar e rodar um:

‚ö†Ô∏è Garanta que a senha do banco esteja de acordo com a presente no .env. üòâ

EX:

docker container run --name teste-sequelize -e MYSQL_ROOT_PASSWORD=root -d -p 3306:3306 mysql:8.0.29

*  Cria√ß√£o do banco de dados usando o CLI do Sequelize

‚û°Ô∏èAgora que iniciamos uma aplica√ß√£o do Sequelize e a nossa inst√¢ncia do MySQL est√° rodando, podemos criar o banco de dados orm_example (que nomeamos no .env) na raiz do projeto:

EX:

env $(cat .env) npx sequelize db:create

NOTA: o comando env $(cat .env) ir√° realizar a leitura das vari√°veis do arquivo .env e repass√°-las para o pr√≥ximo comando, disponibilizando assim os valores das vari√°veis de ambiente para o seu c√≥digo atrav√©s do process.env.NOME_DA_VARIAVEL.

De olho na dica üëÄ: O .sequelizerc procura os arquivos de configura√ß√£o do Sequelize no diret√≥rio src. Por isso, √© importante que voc√™ esteja na raiz do projeto quando for rodar os comandos do Sequelize.

* No seu terminal, o Sequelize vai avisar que o database foi criado. Voc√™ pode verificar isso no pr√≥prio MySQL utilizando os comandos abaixo:

‚û°Ô∏è Execute o container criado anteriormente com o comando:

EX:

docker exec -it container-mysql bash

‚û°Ô∏è Entre no terminal do mysql com o comando:

mysql -u root -p

‚û°Ô∏è Digite a sua senha de acesso ao mysql e em seguida rode o comando abaixo:

show databases;

‚û°Ô∏è Perceba que, a partir desses passos, o banco orm_example foi criado e voc√™ n√£o precisou escrever nenhuma linha de SQL para isso. Essa √© uma das primeiras vantagens que o Sequelize nos oferece.

# MODEL  = Os models s√£o a ess√™ncia do Sequelize. Um model √© uma abstra√ß√£o que representa uma linha na tabela em seu banco de dados e passa v√°rias informa√ß√µes ao Sequelize sobre essa entidade, como o nome e quais atributos (colunas) ela possui (e seus tipos de dados).

* Vamos dar um exemplo para ficar mais evidente! Queremos criar uma tabela users, que cont√©m dados de v√°rias pessoas usu√°rias.

O que fazemos primeiro √© criar um model que vai representar uma pessoa em nossa aplica√ß√£o, ou uma linha na tabela users no nosso banco (vamos ver a tabela sendo criada no pr√≥ximo t√≥pico).
Crie um arquivo user.model.js na pasta model com o seguinte conte√∫do:

EX:

// src/models/user.model.js

const UserModel = (sequelize, DataTypes) => {
  const User = sequelize.define('User', {
    fullName: DataTypes.STRING,
    email: DataTypes.STRING,
  });

  return User;
};

module.exports = UserModel;

Perceba que adicionamos as colunas fullName e email no nosso model, ambas do tipo string.

Note tamb√©m que o nome do arquivo model √© user.model.js e que o nome da fun√ß√£o definida nele tamb√©m est√° no singular (User). Isso √© uma conven√ß√£o. Geralmente os models s√£o nomeados no singular, j√° que representam um registro (o equivalente a uma linha) da tabela, enquanto as tabelas s√£o nomeadas no plural. Como n√£o explicitamos o nome da tabela no model, por padr√£o, o Sequelize coloca no plural o nome do model e o usa como nome da tabela. No nosso caso, o model se chama user e nossa tabela Users, portanto, funciona perfeitamente.

* Utilizando o build
Antes de usarmos as fun√ß√µes, vamos adicionar uma nova linha no nosso arquivo user.model.js. Ela vai ser respons√°vel por sincronizar a model com os m√©todos do Sequelize:

EX:

// src/models/user.model.js
// const UserModel = (sequelize, DataTypes) => {
//  const User = sequelize.define('User', {
//    fullName: DataTypes.STRING,
//    email: DataTypes.STRING,
//  });
  (async () => {
    await sequelize.sync({ force: true });
    // As fun√ß√µes v√£o aqui
})();
//  return User;
// };
// module.exports = UserModel;

Note que o m√©todo sync est√° sendo chamado com o par√¢metro force: true. Isso significa que, toda vez que o servidor for iniciado, a tabela ser√° recriada. Isso √© √∫til para testes, mas n√£o deve ser usado em produ√ß√£o.

* Vamos ent√£o criar a nossa Model com o m√©todo build. O m√©todo build √© √∫til para criar uma inst√¢ncia de um model, mas sem salv√°-la no banco de dados. Podemos usar essa fun√ß√£o quando queremos criar um objeto que vai armazenar dados tempor√°rios, por exemplo:

EX:

const sara = User.build({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara instanceof User); // true
console.log(sara.fullName); // "Sara Silva Santos"

Note que o c√≥digo acima n√£o √© ass√≠ncrono, o que significa que o m√©todo build n√£o se comunica com o banco de dados. Isso acontece por que essa fun√ß√£o cria uma inst√¢ncia de um model, que representa os dados que ir√£o ser salvos no banco de dados, mas n√£o os salva. 

* Para salvar os dados no banco de dados, o m√©todo save deve ser utilizado:

EX:

await sara.save();
console.log('Pessoa salva no banco de dados!');

O m√©todo save √© ass√≠ncrono, por isso ele deve ser utilizado com await.

* Criando com create
Uma forma mais simples de criar uma inst√¢ncia de um model e salv√°-la no banco de dados √© usando o m√©todo create, que combina o build e o save em uma √∫nica fun√ß√£o:

EX:

const sara = await User.create({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara instanceof User); // true
console.log(sara.name); // "Sara Silva Santos"

Note que o m√©todo create √© ass√≠ncrono, pois ele se comunica com o banco de dados para criar a inst√¢ncia do model.

* Modificando informa√ß√µes no banco de dados
Quando trocamos informa√ß√µes de um model, precisamos salvar essas altera√ß√µes no banco de dados. Para isso, podemos usar o m√©todo save:

EX:

const sara = await User.create({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara.fullName); // "Sara Silva Santos"

sara.fullName = "Jane Doe";

// O nome ainda est√° "Sara Silva Santos" no banco de dados!

await sara.save();

// Agora o nome foi atualizado para "Jane Doe" no banco de dados!

* Tamb√©m √© poss√≠vel atualizar diversos campos de uma vez usando o m√©todo set:

EX:

const lucas = await User.create({
  fullName: 'Lucas Silva Santos',
  email: 'lucas.ss@trybe.com',
});

lucas.set({
  fullName: "Pedro Silva Santos",
  email: "pedro.ss@trybe.com"
});

// O nome ainda est√° "Lucas Silva Santos" no banco de dados!

await lucas.save();

// Agora o nome foi atualizado para "Pedro Silva Santos", e o email para pedro.ss@trybe.com no banco de dados!

Note que chamar a fun√ß√£o save no arquivo, vai atualizar todos os campos que foram alterados, n√£o apenas os que foram modificados atrav√©s do m√©todo set. 

* Para atualizar apenas os campos espec√≠ficos que foram modificados, podemos usar o m√©todo update:

EX:

const jane = await User.create({
fullName: "Jane Doe",
email: "jane.doe@trybe.com",
});

jane.email = "ada.doe@trybe.com";
await jane.update({ fullName: "Ada Joe" });

// O banco de dados agora tem "Ada Joe" para o nome, mas o email ainda √© "jane.doe@trybe.com".

await jane.save();
// O banco de dados agora tem "ada.doe@trybe.com" para o email.

* Excluindo informa√ß√µes do banco de dados
Quando precisamos excluir um model do banco de dados, podemos usar o m√©todo destroy:

EX:

const mario = await User.create({ fullName: "Mario Bors" });

console.log(mario.fullName); // "Mario Bors"

await mario.destroy();

// Agora essa entrada n√£o existe mais no banco de dados!

# MIGRATIONS  = Uma migration √© uma forma de versionar o schema do banco de dados. Ou seja, cada migration conter√° um peda√ßo de c√≥digo que representa o hist√≥rico das altera√ß√µes feitas no nosso banco de dados.

üí™ Vamos trazer isso pra pr√°tica!

Imagine o seguinte: voc√™ escreve um c√≥digo definindo como um banco de dados deve ser criado e esse c√≥digo fica salvo em um arquivo na pasta migrations. Ap√≥s um tempo, uma atualiza√ß√£o √© feita e uma coluna √© acrescentada em uma tabela. O que voc√™ faz?

Voc√™ vai escrever o c√≥digo em outro arquivo para acrescentar essa coluna, certo? Pense que, cada arquivo ser√° marcado com uma estampa datetime, ent√£o ao longo do tempo esse c√≥digo vai empilhando dezenas, √†s vezes centenas, de arquivos. Cada um desses arquivos marca uma vers√£o do banco de dados e o seu hist√≥rico de mudan√ßas e evolu√ß√µes.

Quem clona um projeto pela primeira vez, roda suas migrations para configurar o banco de dados no formato mais recente enviado para a main (ou branch principal), sem ter que fazer mais nada. A√≠ sim √© poss√≠vel trabalhar localmente no banco de dados da aplica√ß√£o sem medo de ele ser diferente da vers√£o mais nova que encontramos na main.

Usando migrations, o mapeador objeto-relacional sabe exatamente quais altera√ß√µes executar no banco de dados, tanto para criar algo novo quanto para restaurar o banco para uma vers√£o mais antiga. Al√©m disso, uma migration tem dois c√≥digos conhecidos como Up e Down. Ou seja: toda migration, al√©m de saber o que fazer para executar as mudan√ßas no banco de dados (Up), tamb√©m deve saber como reverter essas mudan√ßas (Down). Isso significa que as migrations t√™m o poder de avan√ßar ou reverter o seu banco de dados para qualquer um dos estados que ele j√° teve.

EX:

(imagem salva na pasta "exemplo-migrations.png")

*  Agora vamos gerar um novo arquivo, com apenas o ‚Äúesqueleto‚Äù de uma migration, usando o seguinte comando no terminal:

EX:

npx sequelize migration:generate --name create-user

* Com isso, um novo arquivo [timestamp]-create-user.js ser√° criado na pasta migrations contendo o seguinte c√≥digo:

EX:

// src/migrations/[timestamp]-create-user.js

'use strict';

module.exports = {
  async up (queryInterface, Sequelize) {
    /**
     * Add altering commands here.
     *
     * Example:
     * await queryInterface.createTable('users', { id: Sequelize.INTEGER });
     */
  },

  async down (queryInterface, Sequelize) {
    /**
     * Add reverting commands here.
     *
     * Example:
     * await queryInterface.dropTable('users');
     */
  }
};

Ao serem criadas pelo Sequelize, os arquivos de migrations e seeds t√™m seus nomes iniciados por um timestamp, que √© seguido pelo nome que n√≥s definimos no comando, gerando ao final um arquivo de nome similar a 20220827010852-create-user.js.

* Agora vamos mexer apenas dentro das fun√ß√µes up e down. Repare que ambas as fun√ß√µes recebem dois par√¢metros: um √© o queryInterface, e o outro √© o Sequelize. Ambos os par√¢metros s√£o objetos que armazenam dados e opera√ß√µes. O queryInterface √© usado pela biblioteca para modificar o banco de dados, seguindo o ‚Äúdialeto‚Äù do banco que estamos utilizando. O objeto Sequelize armazena os tipos de dados dispon√≠veis no contexto do banco, por exemplo varchar, string, integer, date etc.

‚û°Ô∏è O objetivo da nossa migration √© criar a tabela users com os seguintes campos e condi√ß√µes:

id: Identificador do item.

√â uma chave prim√°ria;
Valor n√£o pode ser nulo;
Possui incremento autom√°tico;
√â do tipo Integer.
fullName: Nome completo da pessoa usu√°ria da aplica√ß√£o.

√â do tipo String.
email: E-mail da pessoa usu√°ria da aplica√ß√£o.

√â do tipo String.
createdAt: Data da cria√ß√£o do item.

Valor n√£o pode ser nulo;
√â do tipo Date.
updatedAt: Data da atualiza√ß√£o do item.

Valor n√£o pode ser nulo;
√â do tipo Date.
Podemos criar a tabela Users atrav√©s da fun√ß√£o createTable do queryInterface. A fun√ß√£o createTable recebe dois par√¢metros:

O primeiro recebe uma string com o nome da tabela;
O segundo recebe um objeto com os campos, e suas condi√ß√µes, da tabela.
Lembra da conven√ß√£o que mencionamos anteriormente, na qual o nome do model √© no singular e o nome da tabela √© no plural? √â por esta raz√£o que na fun√ß√£o createTable o nome especificado ser√° "Users". üòâ

* Para come√ßar, chamamos a fun√ß√£o createTable passando o nome da tabela dentro do bloco de execu√ß√£o (up):

‚ö†Ô∏è Usamos o await porque a fun√ß√£o createTable √© ass√≠ncrona!

EX:

// src/migrations/[timestamp]-create-user.js

// 'use strict';

// module.exports = {
//   up: async (queryInterface, Sequelize) => {
       await queryInterface.createTable('Users', {});
//   },

//   down: async (queryInterface, Sequelize) => {
      /**
       * Add reverting commands here.
       *
       * Example:
       * await queryInterface.dropTable('users');
       */
//   }
// };

* Agora vamos adicionar todos os campos da nossa tabela e suas determinadas condi√ß√µes:

EX:

// src/migrations/[timestamp]-create-user.js

// 'use strict';

// module.exports = {
//   up: async (queryInterface, Sequelize) => {
       await queryInterface.createTable('Users', {
         id: {
           allowNull: false,
           autoIncrement: true,
           primaryKey: true,
           type: Sequelize.INTEGER
         },
         fullName: {
           type: Sequelize.STRING
         },
         email: {
           type: Sequelize.STRING
         },
         createdAt: {
           allowNull: false,
           type: Sequelize.DATE
         },
         updatedAt: {
           allowNull: false,
           type: Sequelize.DATE
         }
       });
//   },

//   down: async (queryInterface, Sequelize) => {
      /**
       * Add reverting commands here.
       *
       * Example:
       * await queryInterface.dropTable('users');
       */
//   }
// };

‚û°Ô∏è Percebeu que cada campo possui um objeto representando as propriedades daquele campo em espec√≠fico? Veja o que s√£o cada uma dessas propriedades:

allowNull: Define se o campo pode ou n√£o receber um valor null;
autoIncrement: Define se o campo vai ter incremento autom√°tico;
primaryKey: Define se o campo √© uma chave prim√°ria;
type: Define o tipo do campo, por exemplo STRING, INTEGER, DATE, etc.

* Agora vamos implementar o bloco de revers√£o (down) com um c√≥digo que vai apenas apagar a tabela caso seja necess√°rio desfazer a opera√ß√£o de execu√ß√£o (up). Assim escreveremos uma migration perfeitamente revers√≠vel!

EX:

// src/migrations/[timestamp]-create-user.js

//  'use strict';

//  module.exports = {
//    up: async (queryInterface, Sequelize) => {
//      ...
//    },
//    down: async (queryInterface, Sequelize) => {
        await queryInterface.dropTable('Users');
//    }
//  };

‚ö†Ô∏èImportante: se o c√≥digo da migration tiver erros, as suas migrations podem n√£o executar corretamente os processos de criar ou desfazer uma nova vers√£o do banco. √â preciso ter bastante cuidado na hora de mexer no c√≥digo de uma migration.

‚ö†Ô∏èImportante: A execu√ß√£o de uma migration requer o uso das vari√°veis de ambiente, uma vez que ser√° realizado um acesso ao banco de dados.

* Com a migration criada, basta executarmos o seguinte comando pelo CLI:

EX:

env $(cat .env) npx sequelize db:migrate

* Caso queira reverter uma migration use o seguinte comando:

EX:

env $(cat .env) npx sequelize db:migrate:undo

* Criando uma nova migration para alterar uma tabela j√° existente
Imagine agora, com base no modelo User, se for preciso salvar o telefone do usu√°rio. O que pode vir √† mente √© que basta adicionar o novo atributo no modelo e na migration, como fizemos com o atributo email anteriormente, correto?

‚ùå Errado, essa √© uma pr√°tica que n√£o √© escal√°vel! Imagine que foi feito um deploy do seu c√≥digo e a migration foi usada para criar o banco em ambiente de produ√ß√£o. Nesse caso, voc√™ teria que rodar o comando db:migrate:undo e recriar o banco para executar o comando db:migrate, para ent√£o recriar uma tabela. O problema disso √© que ao rodar o undo voc√™ perde todos os dados salvos anteriormente na tabela, e isso √© uma coisa que jamais deve ser feita. Anotou a√≠?

Ent√£o qual seria a forma correta de adicionar uma nova coluna em uma tabela j√° existente?

‚úîÔ∏è A resposta certa √©: criar uma nova migration que permita alterar a tabela. Para isso, o objeto queryInterface possui fun√ß√µes espec√≠ficas, que permitem criar uma nova coluna, remover uma coluna ou mesmo mudar o tipo de uma coluna que j√° existe. Nesse caso, o queryInterface abstrai o que a fun√ß√£o ALTER TABLE faz no SQL. Deseja saber mais sobre ALTER TABLE e est√° com sua gest√£o de tempo em dia? Consulte o conte√∫do adicional sobre o assunto.

Lembre-se que a tabela Users tem que estar criada para que os passos a seguir sejam executados com sucesso, portanto, se voc√™ reverteu a migration que a criava, refa√ßa-a com o comando npx sequelize db:migrate.

* Para criar uma outra migration para adicionar a coluna phoneNum na sua tabela Users, voc√™ deve criar um novo arquivo com o seguinte comando:

EX:

npx sequelize migration:generate --name add-column-phone-table-users

Com isso, um novo arquivo [timestamp]-add-column-phone-table-users.js ser√° criado.

* Agora podemos inserir a fun√ß√£o queryInterface.addColumn() no escopo Up para adicionar uma nova coluna √† nossa tabela Users, e adicionar a fun√ß√£o queryInterface.removeColumn() no escopo Down para remover a nova coluna da tabela. Veja como fazer isso a partir do c√≥digo abaixo:

EX:

// src/migrations/[timestamp]-add-column-phone-table-users.js

'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
   await queryInterface.addColumn('Users', 'phoneNum', {
     type: Sequelize.STRING,
   });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('Users', 'phoneNum');
  }
};

*  Em seguida rodamos o comando abaixo para executar a nossa nova migration:

EX:

env $(cat .env) npx sequelize db:migrate

* Tamb√©m devemos alterar o model user.model.js para incluir a nova coluna phoneNum da seguinte forma:

EX:

// src/models/user.model.js

// const User = (sequelize, DataTypes) => {
//   const User = sequelize.define('User', {
//     fullName: DataTypes.STRING,
//     email: DataTypes.STRING,
       // aqui inserimos o datatype da coluna criada
       phoneNum: DataTypes.STRING,
//   });
// 
//   return User;
// };

// module.exports = User;

‚û°Ô∏è Pronto! Conseguimos criar uma migration para adi√ß√£o da coluna phoneNum na tabela Users. Desta maneira, se outra pessoa for alterar este projeto em outra m√°quina, ela pode executar as migrations e atualizar o banco de dados local com as modifica√ß√µes feitas por voc√™!














