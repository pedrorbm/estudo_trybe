# ORM  = Mapeamento objeto-relacional ou ORM (Object-Relational Mapping) √© uma t√©cnica que permite fazer um mapeamento estrutural entre as entidades do banco de dados e os objetos que as representam no c√≥digo JavaScript. O mapeamento objeto-relacional abstrai as diferen√ßas entre os dois paradigmas, da aplica√ß√£o e do banco de dados, como podemos ver na imagem a seguir (imagem armazenada na pasta orm-exemplo.png)

Com ORM n√£o precisamos mais escrever uma query SQL ‚Äúcrua‚Äù para cada vez que formos inserir um registro na tabela. A pr√≥pria biblioteca fica respons√°vel por isso. Voc√™ apenas passa o objeto JavaScript para ela e ela insere os dados no banco de dados.

No Node.js, temos o Sequelize, uma biblioteca de ORM bem conhecida e com suporte aos bancos de dados PostgreSQL, MariaDB, MySQL, SQLite e Microsoft SQL Server. √â justamente nessa biblioteca de ORM que vamos nos aprofundar no conte√∫do.

* sequelize  = (imagem na pasta estapas-para-implementacao-do-sequelize.png)
Esse processo pode parecer complexo, mas o Sequelize possui muitas vantagens sobre a utiliza√ß√£o de uma interface direta com o MySQL. Quando tentamos fazer a intera√ß√£o direta com o banco de dados, enfrentamos problemas como:

O JavaScript sozinho n√£o possui um suporte eficiente para o SQL, voc√™ precisaria de um script SQL separado para criar seu database e tabelas.
As queries SQL precisam ser incorporadas (‚Äúembedadas‚Äù) no c√≥digo do JavaScript para serem utilizadas.
Por causa dessas limita√ß√µes, acabamos apenas incluindo boilerplates de SQL em vez de utilizar a L√≥gica de Neg√≥cio na nossa aplica√ß√£o.
‚úèÔ∏èAnote a√≠: boilerplates s√£o trechos de c√≥digo que podem ser reutilizados em muitos lugares com pouca ou nenhuma altera√ß√£o.

Esses s√£o alguns problemas que o Sequelize ajuda a resolver! Com ele, voc√™ pode evitar a cria√ß√£o de queries SQL para produzir as tabelas. Com o uso das models e migrations no Sequelize, o seu c√≥digo se torna mais leg√≠vel, extens√≠vel e de f√°cil manuten√ß√£o.

Al√©m disso, por meio do mapeamento por objetos relacionais, √© poss√≠vel criar as rela√ß√µes e associa√ß√µes entre as tabelas com o pr√≥prio JavaScript. E ainda, √© poss√≠vel migrar seu database para outro banco de dados sem precisar reescrever todo o c√≥digo (por exemplo: mudar de MySQL para o SQL server).

* instala√ßao do sequelize

EX:

npm install -E sequelize@6.3.4

* O pr√≥ximo passo para utilizar o Sequelize √© instalar um CLI, que √© respons√°vel por gerar e executar as opera√ß√µes. Al√©m de instalar o CLI, tamb√©m precisamos instalar o mysql2, uma depend√™ncia necess√°ria para usarmos o MySQL com o Sequelize. Na pasta raiz da aplica√ß√£o, rode os comandos: (OBS: FORA DA PASTA "./SRC")

EX:

npm install -D -E sequelize-cli@6.2.0

npm install -E mysql2@2.1.0

mkdir src

* Depois que instalamos o CLI, precisamos iniciar um projeto com o Sequelize. Para isso, vamos executar o seguinte comando dentro da pasta src:

EX:

cd src

npx sequelize-cli init

Esse comando vai criar as seguintes pastas:

config: cont√©m um arquivo de configura√ß√£o, com orienta√ß√µes para o CLI se conectar com o nosso banco de dados;

models: cont√©m todos os modelos da nossa aplica√ß√£o;

migrations: cont√©m todos os arquivos de migra√ß√£o da nossa aplica√ß√£o;

seeders: cont√©m todos os arquivos de ‚Äúseeds‚Äù (sementes que s√£o usadas para popular o banco).

‚û°Ô∏è O arquivo .sequelizerc

O arquivo .sequelizerc √© um arquivo de configura√ß√£o do Sequelize. Esse arquivo √© respons√°vel por configurar o caminho das pastas migrations, models, seeders e config que o Sequelize ir√° procurar ao executar um comando.

Por padr√£o, ao rodar um comando Sequelize os arquivos dentro das pastas de migrations, models, seeders e config seriam procurados somente na camada em que estiv√©ssemos executando o comando. No nosso caso, como estamos utilizando a pasta src para abrigar os arquivos do Sequelize, caso execut√°ssemos um comando diretamente na raiz da aplica√ß√£o, ir√≠amos nos deparar com um erro.

Podemos entrar na pasta src e executar estes comandos, como fizemos anteriormente, pois assim teremos √™xito. Mas caso fosse uma aplica√ß√£o maior, com mais camadas, aumentar√≠amos a complexidade de subir e configurar a aplica√ß√£o.

√â neste momento que entra em cena o arquivo .sequelizerc. Dessa forma, podemos construir um c√≥digo com uma arquitetura mais organizada. ‚≠ê

* Antes de configurar esse arquivo, volte para a pasta raiz da aplica√ß√£o com o seguinte comando:

EX:

cd ..

* Agora crie um arquivo com o nome .sequelizerc com o seguinte conte√∫do: (O arquivo .sequelizerc √© um arquivo de configura√ß√£o do Sequelize e deve ser criado na pasta raiz. Nesse caso, a pasta app-with-sequelize.)

EX:

// app-with-sequelize/.sequelizerc

const path = require('path');

module.exports = {
  'config': path.resolve('src', 'config', 'config.js'),
  'models-path': path.resolve('src', 'models'),
  'seeders-path': path.resolve('src', 'seeders'),
  'migrations-path': path.resolve('src', 'migrations'),
};

Vamos entender melhor as informa√ß√µes deste arquivo:

path: √© um m√≥dulo interno do Node que nos fornece alguns utilit√°rios para trabalharmos com caminhos de arquivos e diret√≥rios;

config: √© um caminho para o arquivo de configura√ß√£o;

models-path: √© um caminho para o diret√≥rio de models;

seeders-path: √© um caminho para o diret√≥rio de seeders;

migrations-path: √© um caminho para o diret√≥rio de migrations.

* Agora precisamos configurar o arquivo config.json gerado pelo init do CLI. Ao alterar esse arquivo, estamos configurando o acesso da aplica√ß√£o ao nosso banco de dados.

‚û°Ô∏è Note que o arquivo config.json, localizado no diret√≥rio ./src/config, cont√©m informa√ß√µes sens√≠veis, como credenciais de acesso ao banco de dados, expostas no nosso c√≥digo. Uma boa pr√°tica √© substituir os valores por vari√°veis de ambiente, n√£o expondo assim, informa√ß√µes sens√≠veis relacionados √† configura√ß√£o geral da aplica√ß√£o. Ent√£o, vamos fazer isso do jeito certo!

‚û°Ô∏è Mudaremos o nome do nosso arquivo config.json para config.js

‚û°Ô∏è Retiraremos todo o conte√∫do de config.js e substituiremos pelo c√≥digo abaixo:

EX:

// src/config/config.js

const config = {
  username: process.env.MYSQL_USER,
  password: process.env.MYSQL_PASSWORD,
  database: process.env.MYSQL_DATABASE,
  host: process.env.MYSQL_HOST,
  dialect: 'mysql',
};

module.exports = {
  development: config,
  test: config,
  production: config,
};

Vamos entender melhor as informa√ß√µes que estamos passando:

username: usu√°rio de acesso ao banco de dados;

password: senha de acesso ao banco de dados;

database: nome do banco de dados no qual queremos conectar;

host: servidor no qual estamos conectando - por ser local, utilizamos o endere√ßo IP 127.0.0.1, ou seu alias localhost;

dialect: informa qual a biblioteca que o sequelize utiliza para se conectar ao banco de dados estamos utilizando. Nesse caso, mysql.

* Modifique o arquivo src/models/index.js para apontar para o arquivo config.js:

EX:

Para fazer isso, busque neste arquivo, a seguinte linha de c√≥digo:

const config = require(__dirname + '/../config/config.json')[env]; // configura√ß√£o antiga

Altere esta linha para ficar assim:

/ Praticamente √© s√≥ mudar a extens√£o de .json para .js! /
const config = require(__dirname + '/../config/config.js')[env]; // configura√ß√£o nova

* Antes de rodar os comandos Sequelize, precisamos garantir que temos uma inst√¢ncia do MySQL rodando.

Caso voc√™ j√° tenha um container com uma imagem do MySQL, pode utiliz√°-lo ou usar o comando abaixo no terminal para criar e rodar um:

‚ö†Ô∏è Garanta que a senha do banco esteja de acordo com a presente no .env. üòâ

EX:

docker container run --name teste-sequelize -e MYSQL_ROOT_PASSWORD=root -d -p 3306:3306 mysql:8.0.29

*  Cria√ß√£o do banco de dados usando o CLI do Sequelize

‚û°Ô∏èAgora que iniciamos uma aplica√ß√£o do Sequelize e a nossa inst√¢ncia do MySQL est√° rodando, podemos criar o banco de dados orm_example (que nomeamos no .env) na raiz do projeto:

EX:

env $(cat .env) npx sequelize db:create

NOTA: o comando env $(cat .env) ir√° realizar a leitura das vari√°veis do arquivo .env e repass√°-las para o pr√≥ximo comando, disponibilizando assim os valores das vari√°veis de ambiente para o seu c√≥digo atrav√©s do process.env.NOME_DA_VARIAVEL.

De olho na dica üëÄ: O .sequelizerc procura os arquivos de configura√ß√£o do Sequelize no diret√≥rio src. Por isso, √© importante que voc√™ esteja na raiz do projeto quando for rodar os comandos do Sequelize.

* No seu terminal, o Sequelize vai avisar que o database foi criado. Voc√™ pode verificar isso no pr√≥prio MySQL utilizando os comandos abaixo:

‚û°Ô∏è Execute o container criado anteriormente com o comando:

EX:

docker exec -it container-mysql bash

‚û°Ô∏è Entre no terminal do mysql com o comando:

mysql -u root -p

‚û°Ô∏è Digite a sua senha de acesso ao mysql e em seguida rode o comando abaixo:

show databases;

‚û°Ô∏è Perceba que, a partir desses passos, o banco orm_example foi criado e voc√™ n√£o precisou escrever nenhuma linha de SQL para isso. Essa √© uma das primeiras vantagens que o Sequelize nos oferece.

# MODEL  = Os models s√£o a ess√™ncia do Sequelize. Um model √© uma abstra√ß√£o que representa uma linha na tabela em seu banco de dados e passa v√°rias informa√ß√µes ao Sequelize sobre essa entidade, como o nome e quais atributos (colunas) ela possui (e seus tipos de dados).

* Vamos dar um exemplo para ficar mais evidente! Queremos criar uma tabela users, que cont√©m dados de v√°rias pessoas usu√°rias.

O que fazemos primeiro √© criar um model que vai representar uma pessoa em nossa aplica√ß√£o, ou uma linha na tabela users no nosso banco (vamos ver a tabela sendo criada no pr√≥ximo t√≥pico).
Crie um arquivo user.model.js na pasta model com o seguinte conte√∫do:

EX:

// src/models/user.model.js

const UserModel = (sequelize, DataTypes) => {
  const User = sequelize.define('User', {
    fullName: DataTypes.STRING,
    email: DataTypes.STRING,
  });

  return User;
};

module.exports = UserModel;

Perceba que adicionamos as colunas fullName e email no nosso model, ambas do tipo string.

Note tamb√©m que o nome do arquivo model √© user.model.js e que o nome da fun√ß√£o definida nele tamb√©m est√° no singular (User). Isso √© uma conven√ß√£o. Geralmente os models s√£o nomeados no singular, j√° que representam um registro (o equivalente a uma linha) da tabela, enquanto as tabelas s√£o nomeadas no plural. Como n√£o explicitamos o nome da tabela no model, por padr√£o, o Sequelize coloca no plural o nome do model e o usa como nome da tabela. No nosso caso, o model se chama user e nossa tabela Users, portanto, funciona perfeitamente.

* Utilizando o build
Antes de usarmos as fun√ß√µes, vamos adicionar uma nova linha no nosso arquivo user.model.js. Ela vai ser respons√°vel por sincronizar a model com os m√©todos do Sequelize:

EX:

// src/models/user.model.js
// const UserModel = (sequelize, DataTypes) => {
//  const User = sequelize.define('User', {
//    fullName: DataTypes.STRING,
//    email: DataTypes.STRING,
//  });
  (async () => {
    await sequelize.sync({ force: true });
    // As fun√ß√µes v√£o aqui
})();
//  return User;
// };
// module.exports = UserModel;

Note que o m√©todo sync est√° sendo chamado com o par√¢metro force: true. Isso significa que, toda vez que o servidor for iniciado, a tabela ser√° recriada. Isso √© √∫til para testes, mas n√£o deve ser usado em produ√ß√£o.

* Vamos ent√£o criar a nossa Model com o m√©todo build. O m√©todo build √© √∫til para criar uma inst√¢ncia de um model, mas sem salv√°-la no banco de dados. Podemos usar essa fun√ß√£o quando queremos criar um objeto que vai armazenar dados tempor√°rios, por exemplo:

EX:

const sara = User.build({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara instanceof User); // true
console.log(sara.fullName); // "Sara Silva Santos"

Note que o c√≥digo acima n√£o √© ass√≠ncrono, o que significa que o m√©todo build n√£o se comunica com o banco de dados. Isso acontece por que essa fun√ß√£o cria uma inst√¢ncia de um model, que representa os dados que ir√£o ser salvos no banco de dados, mas n√£o os salva. 

* Para salvar os dados no banco de dados, o m√©todo save deve ser utilizado:

EX:

await sara.save();
console.log('Pessoa salva no banco de dados!');

O m√©todo save √© ass√≠ncrono, por isso ele deve ser utilizado com await.

* Criando com create
Uma forma mais simples de criar uma inst√¢ncia de um model e salv√°-la no banco de dados √© usando o m√©todo create, que combina o build e o save em uma √∫nica fun√ß√£o:

EX:

const sara = await User.create({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara instanceof User); // true
console.log(sara.name); // "Sara Silva Santos"

Note que o m√©todo create √© ass√≠ncrono, pois ele se comunica com o banco de dados para criar a inst√¢ncia do model.

* Modificando informa√ß√µes no banco de dados
Quando trocamos informa√ß√µes de um model, precisamos salvar essas altera√ß√µes no banco de dados. Para isso, podemos usar o m√©todo save:

EX:

const sara = await User.create({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara.fullName); // "Sara Silva Santos"

sara.fullName = "Jane Doe";

// O nome ainda est√° "Sara Silva Santos" no banco de dados!

await sara.save();

// Agora o nome foi atualizado para "Jane Doe" no banco de dados!

* Tamb√©m √© poss√≠vel atualizar diversos campos de uma vez usando o m√©todo set:

EX:

const lucas = await User.create({
  fullName: 'Lucas Silva Santos',
  email: 'lucas.ss@trybe.com',
});

lucas.set({
  fullName: "Pedro Silva Santos",
  email: "pedro.ss@trybe.com"
});

// O nome ainda est√° "Lucas Silva Santos" no banco de dados!

await lucas.save();

// Agora o nome foi atualizado para "Pedro Silva Santos", e o email para pedro.ss@trybe.com no banco de dados!

Note que chamar a fun√ß√£o save no arquivo, vai atualizar todos os campos que foram alterados, n√£o apenas os que foram modificados atrav√©s do m√©todo set. 

* Para atualizar apenas os campos espec√≠ficos que foram modificados, podemos usar o m√©todo update:

EX:

const jane = await User.create({
fullName: "Jane Doe",
email: "jane.doe@trybe.com",
});

jane.email = "ada.doe@trybe.com";
await jane.update({ fullName: "Ada Joe" });

// O banco de dados agora tem "Ada Joe" para o nome, mas o email ainda √© "jane.doe@trybe.com".

await jane.save();
// O banco de dados agora tem "ada.doe@trybe.com" para o email.

* Excluindo informa√ß√µes do banco de dados
Quando precisamos excluir um model do banco de dados, podemos usar o m√©todo destroy:

EX:

const mario = await User.create({ fullName: "Mario Bors" });

console.log(mario.fullName); // "Mario Bors"

await mario.destroy();

// Agora essa entrada n√£o existe mais no banco de dados!

# MIGRATIONS  = Uma migration √© uma forma de versionar o schema do banco de dados. Ou seja, cada migration conter√° um peda√ßo de c√≥digo que representa o hist√≥rico das altera√ß√µes feitas no nosso banco de dados.

üí™ Vamos trazer isso pra pr√°tica!

Imagine o seguinte: voc√™ escreve um c√≥digo definindo como um banco de dados deve ser criado e esse c√≥digo fica salvo em um arquivo na pasta migrations. Ap√≥s um tempo, uma atualiza√ß√£o √© feita e uma coluna √© acrescentada em uma tabela. O que voc√™ faz?

Voc√™ vai escrever o c√≥digo em outro arquivo para acrescentar essa coluna, certo? Pense que, cada arquivo ser√° marcado com uma estampa datetime, ent√£o ao longo do tempo esse c√≥digo vai empilhando dezenas, √†s vezes centenas, de arquivos. Cada um desses arquivos marca uma vers√£o do banco de dados e o seu hist√≥rico de mudan√ßas e evolu√ß√µes.

Quem clona um projeto pela primeira vez, roda suas migrations para configurar o banco de dados no formato mais recente enviado para a main (ou branch principal), sem ter que fazer mais nada. A√≠ sim √© poss√≠vel trabalhar localmente no banco de dados da aplica√ß√£o sem medo de ele ser diferente da vers√£o mais nova que encontramos na main.

Usando migrations, o mapeador objeto-relacional sabe exatamente quais altera√ß√µes executar no banco de dados, tanto para criar algo novo quanto para restaurar o banco para uma vers√£o mais antiga. Al√©m disso, uma migration tem dois c√≥digos conhecidos como Up e Down. Ou seja: toda migration, al√©m de saber o que fazer para executar as mudan√ßas no banco de dados (Up), tamb√©m deve saber como reverter essas mudan√ßas (Down). Isso significa que as migrations t√™m o poder de avan√ßar ou reverter o seu banco de dados para qualquer um dos estados que ele j√° teve.

EX:

(imagem salva na pasta "exemplo-migrations.png")

*  Agora vamos gerar um novo arquivo, com apenas o ‚Äúesqueleto‚Äù de uma migration, usando o seguinte comando no terminal:

EX:

npx sequelize migration:generate --name create-user

* Com isso, um novo arquivo [timestamp]-create-user.js ser√° criado na pasta migrations contendo o seguinte c√≥digo:

EX:

// src/migrations/[timestamp]-create-user.js

'use strict';

module.exports = {
  async up (queryInterface, Sequelize) {
    /**
     * Add altering commands here.
     *
     * Example:
     * await queryInterface.createTable('users', { id: Sequelize.INTEGER });
     */
  },

  async down (queryInterface, Sequelize) {
    /**
     * Add reverting commands here.
     *
     * Example:
     * await queryInterface.dropTable('users');
     */
  }
};

Ao serem criadas pelo Sequelize, os arquivos de migrations e seeds t√™m seus nomes iniciados por um timestamp, que √© seguido pelo nome que n√≥s definimos no comando, gerando ao final um arquivo de nome similar a 20220827010852-create-user.js.

* Agora vamos mexer apenas dentro das fun√ß√µes up e down. Repare que ambas as fun√ß√µes recebem dois par√¢metros: um √© o queryInterface, e o outro √© o Sequelize. Ambos os par√¢metros s√£o objetos que armazenam dados e opera√ß√µes. O queryInterface √© usado pela biblioteca para modificar o banco de dados, seguindo o ‚Äúdialeto‚Äù do banco que estamos utilizando. O objeto Sequelize armazena os tipos de dados dispon√≠veis no contexto do banco, por exemplo varchar, string, integer, date etc.

‚û°Ô∏è O objetivo da nossa migration √© criar a tabela users com os seguintes campos e condi√ß√µes:

id: Identificador do item.

√â uma chave prim√°ria;
Valor n√£o pode ser nulo;
Possui incremento autom√°tico;
√â do tipo Integer.
fullName: Nome completo da pessoa usu√°ria da aplica√ß√£o.

√â do tipo String.
email: E-mail da pessoa usu√°ria da aplica√ß√£o.

√â do tipo String.
createdAt: Data da cria√ß√£o do item.

Valor n√£o pode ser nulo;
√â do tipo Date.
updatedAt: Data da atualiza√ß√£o do item.

Valor n√£o pode ser nulo;
√â do tipo Date.
Podemos criar a tabela Users atrav√©s da fun√ß√£o createTable do queryInterface. A fun√ß√£o createTable recebe dois par√¢metros:

O primeiro recebe uma string com o nome da tabela;
O segundo recebe um objeto com os campos, e suas condi√ß√µes, da tabela.
Lembra da conven√ß√£o que mencionamos anteriormente, na qual o nome do model √© no singular e o nome da tabela √© no plural? √â por esta raz√£o que na fun√ß√£o createTable o nome especificado ser√° "Users". üòâ

* Para come√ßar, chamamos a fun√ß√£o createTable passando o nome da tabela dentro do bloco de execu√ß√£o (up):

‚ö†Ô∏è Usamos o await porque a fun√ß√£o createTable √© ass√≠ncrona!

EX:

// src/migrations/[timestamp]-create-user.js

// 'use strict';

// module.exports = {
//   up: async (queryInterface, Sequelize) => {
       await queryInterface.createTable('Users', {});
//   },

//   down: async (queryInterface, Sequelize) => {
      /**
       * Add reverting commands here.
       *
       * Example:
       * await queryInterface.dropTable('users');
       */
//   }
// };

* Agora vamos adicionar todos os campos da nossa tabela e suas determinadas condi√ß√µes:

EX:

// src/migrations/[timestamp]-create-user.js

// 'use strict';

// module.exports = {
//   up: async (queryInterface, Sequelize) => {
       await queryInterface.createTable('Users', {
         id: {
           allowNull: false,
           autoIncrement: true,
           primaryKey: true,
           type: Sequelize.INTEGER
         },
         fullName: {
           type: Sequelize.STRING
         },
         email: {
           type: Sequelize.STRING
         },
         createdAt: {
           allowNull: false,
           type: Sequelize.DATE
         },
         updatedAt: {
           allowNull: false,
           type: Sequelize.DATE
         }
       });
//   },

//   down: async (queryInterface, Sequelize) => {
      /**
       * Add reverting commands here.
       *
       * Example:
       * await queryInterface.dropTable('users');
       */
//   }
// };

‚û°Ô∏è Percebeu que cada campo possui um objeto representando as propriedades daquele campo em espec√≠fico? Veja o que s√£o cada uma dessas propriedades:

allowNull: Define se o campo pode ou n√£o receber um valor null;
autoIncrement: Define se o campo vai ter incremento autom√°tico;
primaryKey: Define se o campo √© uma chave prim√°ria;
type: Define o tipo do campo, por exemplo STRING, INTEGER, DATE, etc.

* Agora vamos implementar o bloco de revers√£o (down) com um c√≥digo que vai apenas apagar a tabela caso seja necess√°rio desfazer a opera√ß√£o de execu√ß√£o (up). Assim escreveremos uma migration perfeitamente revers√≠vel!

EX:

// src/migrations/[timestamp]-create-user.js

//  'use strict';

//  module.exports = {
//    up: async (queryInterface, Sequelize) => {
//      ...
//    },
//    down: async (queryInterface, Sequelize) => {
        await queryInterface.dropTable('Users');
//    }
//  };

‚ö†Ô∏èImportante: se o c√≥digo da migration tiver erros, as suas migrations podem n√£o executar corretamente os processos de criar ou desfazer uma nova vers√£o do banco. √â preciso ter bastante cuidado na hora de mexer no c√≥digo de uma migration.

‚ö†Ô∏èImportante: A execu√ß√£o de uma migration requer o uso das vari√°veis de ambiente, uma vez que ser√° realizado um acesso ao banco de dados.

* Com a migration criada, basta executarmos o seguinte comando pelo CLI:

EX:

env $(cat .env) npx sequelize db:migrate

* Caso queira reverter uma migration use o seguinte comando:

EX:

env $(cat .env) npx sequelize db:migrate:undo

* Criando uma nova migration para alterar uma tabela j√° existente
Imagine agora, com base no modelo User, se for preciso salvar o telefone do usu√°rio. O que pode vir √† mente √© que basta adicionar o novo atributo no modelo e na migration, como fizemos com o atributo email anteriormente, correto?

‚ùå Errado, essa √© uma pr√°tica que n√£o √© escal√°vel! Imagine que foi feito um deploy do seu c√≥digo e a migration foi usada para criar o banco em ambiente de produ√ß√£o. Nesse caso, voc√™ teria que rodar o comando db:migrate:undo e recriar o banco para executar o comando db:migrate, para ent√£o recriar uma tabela. O problema disso √© que ao rodar o undo voc√™ perde todos os dados salvos anteriormente na tabela, e isso √© uma coisa que jamais deve ser feita. Anotou a√≠?

Ent√£o qual seria a forma correta de adicionar uma nova coluna em uma tabela j√° existente?

‚úîÔ∏è A resposta certa √©: criar uma nova migration que permita alterar a tabela. Para isso, o objeto queryInterface possui fun√ß√µes espec√≠ficas, que permitem criar uma nova coluna, remover uma coluna ou mesmo mudar o tipo de uma coluna que j√° existe. Nesse caso, o queryInterface abstrai o que a fun√ß√£o ALTER TABLE faz no SQL. Deseja saber mais sobre ALTER TABLE e est√° com sua gest√£o de tempo em dia? Consulte o conte√∫do adicional sobre o assunto.

Lembre-se que a tabela Users tem que estar criada para que os passos a seguir sejam executados com sucesso, portanto, se voc√™ reverteu a migration que a criava, refa√ßa-a com o comando npx sequelize db:migrate.

* Para criar uma outra migration para adicionar a coluna phoneNum na sua tabela Users, voc√™ deve criar um novo arquivo com o seguinte comando:

EX:

npx sequelize migration:generate --name add-column-phone-table-users

Com isso, um novo arquivo [timestamp]-add-column-phone-table-users.js ser√° criado.

* Agora podemos inserir a fun√ß√£o queryInterface.addColumn() no escopo Up para adicionar uma nova coluna √† nossa tabela Users, e adicionar a fun√ß√£o queryInterface.removeColumn() no escopo Down para remover a nova coluna da tabela. Veja como fazer isso a partir do c√≥digo abaixo:

EX:

// src/migrations/[timestamp]-add-column-phone-table-users.js

'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
   await queryInterface.addColumn('Users', 'phoneNum', {
     type: Sequelize.STRING,
   });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('Users', 'phoneNum');
  }
};

*  Em seguida rodamos o comando abaixo para executar a nossa nova migration:

EX:

env $(cat .env) npx sequelize db:migrate

* Tamb√©m devemos alterar o model user.model.js para incluir a nova coluna phoneNum da seguinte forma:

EX:

// src/models/user.model.js

// const User = (sequelize, DataTypes) => {
//   const User = sequelize.define('User', {
//     fullName: DataTypes.STRING,
//     email: DataTypes.STRING,
       // aqui inserimos o datatype da coluna criada
       phoneNum: DataTypes.STRING,
//   });
// 
//   return User;
// };

// module.exports = User;

‚û°Ô∏è Pronto! Conseguimos criar uma migration para adi√ß√£o da coluna phoneNum na tabela Users. Desta maneira, se outra pessoa for alterar este projeto em outra m√°quina, ela pode executar as migrations e atualizar o banco de dados local com as modifica√ß√µes feitas por voc√™!

# SEEDERS  = agora chegou o momento de aprender a popular nosso banco de dados utilizando o Seeders. Podemos configurar nosso banco para ser automaticamente criado e povoado.

* As seeds seguem a mesma linha das migrations, portanto primeiramente vamos precisar executar a cria√ß√£o de uma nova seed pelo CLI:

EX:

npx sequelize seed:generate --name users

Reparem que o arquivo foi criado dentro da pasta seeders com o mesmo formato do arquivo de uma migration. 

* Agora, devemos adicionar ao arquivo criado quais informa√ß√µes aquele seed vai gerar. O c√≥digo abaixo vai adicionar dois usu√°rios ao banco de dados:

EX:

// src/seeders/[timestamp]-users.js

'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => queryInterface.bulkInsert('Users',
    [
      {
        fullName: 'Leonardo',
        email: 'leo@test.com',
        // usamos a fun√ß√£o CURRENT_TIMESTAMP do SQL para salvar a data e hora atual nos campos `createdAt` e `updatedAt`
        createdAt: Sequelize.literal('CURRENT_TIMESTAMP'),
        updatedAt: Sequelize.literal('CURRENT_TIMESTAMP'),
      },
      {
        fullName: 'JEduardo',
        email: 'edu@test.com',
        createdAt: Sequelize.literal('CURRENT_TIMESTAMP'),
        updatedAt: Sequelize.literal('CURRENT_TIMESTAMP'),
      },
    ], {}),

  down: async (queryInterface) => queryInterface.bulkDelete('Users', null, {}),
};

Na fun√ß√£o acima, estamos utilizando o par√¢metro recebido pela fun√ß√£o queryInterface para conversar com o banco de dados. Dessa forma, conseguimos inserir os dados que queremos. Tamb√©m estamos adicionando os dados, que est√£o na estrutura de uma array de objetos, na tabela users. O queryInterface tem a fun√ß√£o bulkInsert, a qual estamos utilizando, que insere m√∫ltiplos dados na tabela.

Note que a seed segue o mesmo princ√≠pio de up e down, ou seja, devemos colocar tamb√©m o que a seed deve fazer caso precise reverter a opera√ß√£o. Aqui, um c√≥digo ruim pode quebrar o fluxo de uso/revers√£o dos seeds, ent√£o escreva com aten√ß√£o!

* Para executar a seed, basta rodarmos o comando abaixo:

EX:

env $(cat .env) npx sequelize db:seed:all

* Para reverter o seed, use o seguinte comando:

EX:

env $(cat .env) npx sequelize db:seed:undo:all

# Implementando a listagem de pessoas usu√°rias

Caso precisemos buscar todas as pessoas usu√°rias, por exemplo, basta criarmos os diret√≥rios e arquivos para nossos services e controllers e preench√™-los como no c√≥digo abaixo:

EX: SERVICE

// src/services/user.service.js

const { User } = require('../models');

/* Esta fun√ß√£o usa o m√©todo findAll do Sequelize para buscar todas as linhas da tabela Users
Equivale a fazer a query: SELECT * FROM Users */
const getAll = async () => {
  const users = await User.findAll();

  return users;
};

module.exports = {
  getAll,
};

EX: CONTROLLER

// src/controllers/user.controller.js

const UserService = require('../services/user.service');

const getAll = async (_req, res) => {
  try {
    const users = await UserService.getAll();
    return res.status(200).json(users);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: 'Ocorreu um erro' });
  }
};

module.exports = {
  getAll,
};

Note que n√£o precisamos escrever uma query SQL para buscar os dados, pois o Sequelize abstrai isso para n√≥s. Ele oculta essa complexidade e nos prov√™ uma forma menos trabalhosa de escrever esse c√≥digo.

Repare que estamos importando o modelo que criamos do arquivo index.js da pasta models, e n√£o diretamente do arquivo user.models.js. Quando executamos o comando npx sequelize init, o arquivo index.js √© gerado dentro da pasta models.

O c√≥digo desse arquivo index.js √© respons√°vel por:

Realizar a conex√£o com o banco de dados, por meio do arquivo config.json ou config.js;
Coletar todos os modelos definidos dentro da pasta models e;
Caso necess√°rio, associar um modelo a algum outro.

* Agora precisamos criar nossos arquivos app.js e server.js com os c√≥digo logo abaixo dentro da pasta src. Teste e veja o comportamento de uma aplica√ß√£o utilizando o Sequelize.

EX:

// src/app.js

const express = require('express');

const User = require('./controllers/user.controller');

const app = express();

app.use(express.json());

app.get('/user', User.getAll);

module.exports = app;

EX:

// src/server.js

const app = require('./app');

const PORT = process.env.PORT || 3001;

app.listen(PORT, () => {
  console.log(`Escutando na porta ${PORT}`);
});

* Antes de executar a aplica√ß√£o, precisamos adicionar o Express e o nodemon como depend√™ncias da nossa aplica√ß√£o:

EX:

npm install -E express@4.17
npm install -D -E nodemon@2.0.15

* Agora, altere a chave no package.json a chave main para que aponte para o arquivo server.js: e adicione o script dev para rodar sua aplica√ß√£o.

EX:

//  {
//  ...
  "main": "src/server.js",
//  ...
  "scripts": {
    "dev": "nodemon src/server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
//  ...
//  }

Agora voc√™ pode executar o comando "env $(cat .env) npm run dev" e testar fazer uma requisi√ß√£o para URL http://localhost:3001/user. Como acabamos de criar o banco de dados e a tabela Users nas li√ß√µes anteriores, a resposta da requisi√ß√£o ser√° um array com duas pessoas usu√°rias, essas pessoas s√£o as que foram inseridas gra√ßas ao Seeder que foi criado e executado anteriormente.

* Implementando os demais endpoints do CRUD de pessoas usu√°rias
O caso que mostramos acima foi para buscar todas as pessoas usu√°rias, mas conseguimos realizar todas as outras opera√ß√µes de consulta, inser√ß√£o e dele√ß√£o tamb√©m:

EX: SERVICE

// src/services/user.service.js

// const { User } = require('../models/');

// const getAll = async () => {
//   const users = await User.findAll();

//   return users;
// };

/* Esta fun√ß√£o usa o m√©todo findByPk do Sequelize para buscar um usu√°rio pelo id.
Equivale a fazer a query: SELECT * FROM Users WHERE id=? */
const getById = async (id) => {
  const user = await User.findByPk(id);

  return user;
};

/* Esta fun√ß√£o usa o m√©todo findOne do Sequelize combinado 
com a chave where para buscar por id e email. 
Equivale a fazer a query: SELECT * FROM Users WHERE id=? AND email=? */
const getByIdAndEmail = async (id, email) => {
  const user = await User.findOne({ where: { id, email } });

  return user;
};

/* Esta fun√ß√£o usa o m√©todo create do Sequelize para inserir um objeto na tabela Users
Equivale a fazer a query: INSERT INTO Users (full_name, email) VALUES (?, ?) */
const createUser = async (fullName, email) => {
  const newUser = await User.create({ fullName, email });

  return newUser;
};

/* Esta fun√ß√£o usa o m√©todo update do Sequelize para atualizar um objeto na tabela Users
Equivale a fazer a query: UPDATE Users SET full_name=?, email=? WHERE id=?*/
const updateUser = async (id, fullName, email) => {
  const [updatedUser] = await User.update(
    { fullName, email },
    { where: { id } },
  );

  console.log(updatedUser); // confira o que √© retornado quando o user com o id √© ou n√£o encontrado;
  return updatedUser;
};

/* Esta fun√ß√£o usa o m√©todo destroy do Sequelize para remover um objeto na tabela Users
Equivale a fazer a query: DELETE FROM Users WHERE id=?*/
const deleteUser = async (id) => {
  const user = await User.destroy(
    { where: { id } },
  );

  console.log(user); // confira o que √© retornado quando o user com o id √© ou n√£o encontrado;
  return user;
};

module.exports = {
  getAll,
  getById,
  getByIdAndEmail,
  createUser,
  updateUser,
  deleteUser,
};

EX: CONTROLLER

// src/controllers/user.controller.js

// const UserService = require('../services/user.service');

const error500Message = 'Algo deu errado';

// const getAll = async (_req, res) => {
//   try {
//     const users = await UserService.getAll();
//     return res.status(200).json(users);
//   } catch (e) {
//     console.log(e.message);
//     res.status(500).json({ message: 'Ocorreu um erro' });
//   }
// };

const getById = async (req, res) => {
  try {
    const { id } = req.params;
    const user = await UserService.getById(id);

    if (!user) return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });

    return res.status(200).json(user);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

const getByIdAndEmail = async (req, res) => {
  try {
    const { id } = req.params;
    const { email } = req.query;
    const user = await UserService.getByIdAndEmail(id, email);

    if (!user) return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });

    return res.status(200).json(user);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

const createUser = async (req, res) => {
  try {
    const { fullName, email } = req.body;
    const newUser = await UserService.createUser(fullName, email);

    return res.status(201).json(newUser);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

const updateUser = async (req, res) => {
  try {
    const { fullName, email } = req.body;
    const { id } = req.params;
    const updatedUser = await UserService.updateUser(id, fullName, email);

    if (!updatedUser) return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });

    return res.status(200).json({ message: 'Usu√°rio atualizado com sucesso!' });
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

const deleteUser = async (req, res) => {
  try {
    const { id } = req.params;
    await UserService.deleteUser(id);

    return res.status(200).json({ message: 'Usu√°rio exclu√≠do com sucesso!' });
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

module.exports = {
  getAll,
  getById,
  getByIdAndEmail,
  createUser,
  updateUser,
  deleteUser,
};

EX: APP

// src/app.js

// const express = require('express');

// const User = require('./controllers/user.controller');

// const app = express();

// app.use(express.json());

// app.get('/user', User.getAll);

// Este endpoint usa o m√©todo findByPk do Sequelize para buscar um usu√°rio pelo id.
app.get('/user/:id', User.getById);

// Este endpoint usa o m√©todo findOne do Sequelize para buscar um usu√°rio pelo id e email.
// URL a ser utilizada para o exemplo "http://localhost:3001/user/search/1?email=leo@test.com"
app.get('/user/search/:id', User.getByIdAndEmail);

// Este endpoint usa o m√©todo create do Sequelize para salvar um usu√°rio no banco.
app.post('/user', User.createUser);

// Este endpoint usa o m√©todo update do Sequelize para alterar um usu√°rio no banco.
app.put('/user/:id', User.updateUser);

// Este endpoint usa o m√©todo destroy do Sequelize para remover um usu√°rio no banco.
app.delete('/user/:id', User.deleteUser);

// module.exports = app;

* Testes
Para testarmos os models criados com o Sequelize, seguiremos os mesmos conceitos vistos anteriormente: vamos isolar as opera√ß√µes de IO e utilizaremos bibliotecas espec√≠ficas para nos ajudar com os stubs e asser√ß√µes.

* Antes de come√ßar a realizar os testes, vamos instalar nossas depend√™ncias de desenvolvimento como nas aulas anteriores:

EX:

npm i mocha@10.0.0 chai@4.3.4 sinon@14.0.0 chai-http@4.3.0 -D -E

* Agora vamos alterar a linha abaixo em nosso package.json para executar nossos testes com o comando npm test, como nas aulas anteriores:

EX:

// package.json

"scripts": {
  ...
  "test": "mocha tests/**/*$NAME*.test.js --exit"
},

* Para testar um model com Sequelize, podemos utilizar bibliotecas espec√≠ficas para nos ajudar nessa tarefa. Uma bastante utilizada √© a Sequelize Test Helpers. Vamos ver um exemplo de como podemos utiliz√°-la:

Use o comando abaixo para instalar a biblioteca Sequelize Test Helpers:

EX:

npm i sequelize-test-helpers@1.4.3 -D -E

* Crie o arquivo abaixo na raiz do projeto e depois rode npm test:

EX:

// tests/unit/models/user.test.js

const {
  sequelize,
  dataTypes,
  checkModelName,
  checkPropertyExists,
} = require('sequelize-test-helpers');

const UserModel = require('../../../src/models/user.model');

describe('O model de User', () => {
  const User = UserModel(sequelize, dataTypes);
  const user = new User();

  describe('possui o nome "User"', () => {
    checkModelName(User)('User');
  });

  describe('possui as propriedades "fullName" e "email"', () => {
    ['fullName', 'email'].forEach(checkPropertyExists(user));
  });
});

√â poss√≠vel fazer essas asser√ß√µes diretamente, por√©m esse m√≥dulo j√° possui diversas fun√ß√µes prontas para facilitar a escrita dos testes.


# PRIMARY KEY, FOREIGN KEY E JOINS NO SEQUELIZE:(MODIFICANDO NO TESTE PROJETO "APP-WITH" DA PASTA COM A TABELA "employees").

# RELACIONAMENTO 1:1

* Agora vamos criar as migrations e para criar a migration que ser√° respons√°vel pela tabela Employees, basta utilizar o comando:

EX:

npx sequelize migration:generate --name create-employees

Lembre-se que todas as migrations e seeds, quando criadas pelos comandos do Sequelize, t√™m um timestamp antes do nome do arquivo, lembre-se disso ao procur√°-las!

* Abra a migration e substitua o c√≥digo existente pelo seguinte c√≥digo:

EX:

// src/migrations/[timestamp]-create-employee.js

module.exports = {
  up: async (queryInterface, Sequelize) => {
    return queryInterface.createTable('employees', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      firstName: {
        allowNull: false,
        type: Sequelize.STRING,
        field: 'first_name',
      },
      lastName: {
        allowNull: false,
        type: Sequelize.STRING,
        field: 'last_name',
      },
      age: {
        allowNull: false,
        type: Sequelize.INTEGER,
      },
    });
  },

  down: async (queryInterface, _Sequelize) => {
    return queryInterface.dropTable('employees');
  },
};

* Agora vamos criar a migration respons√°vel pela tabela Addresses utilizando o comando:

EX:

npx sequelize migration:generate --name create-addresses

* Abra a migration e substitua seu conte√∫do presente pelo seguinte c√≥digo:

EX:

// src/migrations/[timestamp]-create-addresses.js

module.exports = {
  up: async (queryInterface, Sequelize) => {
    return queryInterface.createTable('addresses', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      city: {
        allowNull: false,
        type: Sequelize.STRING,
      },
      street: {
        allowNull: false,
        type: Sequelize.STRING,
      },
      number: {
        allowNull: false,
        type: Sequelize.INTEGER,
      },
      employeeId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        // Configuram o que deve acontecer ao atualizar ou excluir um usu√°rio
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
        field: 'employee_id',
        // Informa que o campo √© uma Foreign Key (Chave estrangeira)
        references: {
          // Informa a tabela da refer√™ncia da associa√ß√£o
          model: 'employees',
          // Informa a coluna da refer√™ncia que √© a chave correspondente
          key: 'id',
        },
      },
    });
  },

  down: async (queryInterface, _Sequelize) => {
    return queryInterface.dropTable('addresses');
  },
};

Repare que, agora, temos algumas informa√ß√µes novas sendo passadas para o Sequelize no momento de adicionar a coluna employeeId. Esses dados informam ao Sequelize que aquele campo deve ser uma _foreign key_. Vamos passar por cada um deles:

references.model: indica qual tabela nossa foreign key est√° referenciando.
references.key: indica qual coluna da tabela estrangeira deve ser utilizada para nossa foreign key.
onUpdate e onDelete: configura o que deve acontecer ao atualizar ou excluir um usu√°rio. Nesse caso, todos os endere√ßos daquele usu√°rio ser√£o alterados ou exclu√≠dos.
Essa migration cria uma foreign key na tabela addresses, que relaciona o campo employee_id dessa tabela ao campo id da tabela employees.

* Vamos executar o seguinte comando para gerar as migrations:

EX:

env $(cat .env) npx sequelize db:migrate

Ok, mas como criamos essa associa√ß√£o no sequelize? ü§î

Com as migrations criadas, vamos para os models criar essas associa√ß√µes!

* Dentro da pasta models, crie o arquivo employee.model.js, que conter√° a seguinte estrutura:

EX:

// src/models/employee.model.js

module.exports = (sequelize, DataTypes) => {
  const Employee = sequelize.define('Employee', {
    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    firstName: DataTypes.STRING,
    lastName: DataTypes.STRING,
    age: DataTypes.INTEGER,
  },
  {
    timestamps: false, // remove a obrigatoriedade de utilizar os campos `createdAt` e `updatedAt`
    tableName: 'employees',
    underscored: true,
  });

  Employee.associate = (models) => {
    Employee.hasOne(models.Address,
      { foreignKey: 'employeeId', as: 'addresses' });
  };

  return Employee;
};

A fun√ß√£o Employee.associate = (models) => {} que criamos √© onde declararemos as associa√ß√µes daquele model. No nosso caso, estamos dizendo que a tabela Employees possui um Address, referenciado pela foreign key employee_id, o model Employee deve cham√°-la de addresses (note a letra min√∫scula), como definido na propriedade as.

Essa fun√ß√£o √© chamada pelo arquivo src/models/index.js, criado pelo comando npx sequelize-cli init que voc√™ executou ao come√ßar o exemplo.

Os m√©todos de cria√ß√£o de associa√ß√µes que o Sequelize disponibiliza s√£o:

hasOne
belongsTo
hasMany
belongsToMany
No caso de relacionamentos 1:1, utilizamos os m√©todos hasOne e belongsTo. A tradu√ß√£o literal desses m√©todos facilita o seu entendimento.

hasOne = tem um belongsTo = pertencente a

* No model Address, por sua vez, temos que fazer o caminho inverso, declarando que o address pertence a Employee. Fazemos isso da seguinte forma:

EX:

// src/models/address.model.js

module.exports = (sequelize, DataTypes) => {
  const Address = sequelize.define('Address', {
    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    city: DataTypes.STRING,
    street: DataTypes.STRING,
    number: DataTypes.INTEGER,
    employeeId: { type: DataTypes.INTEGER, foreignKey: true },
    // A declara√ß√£o da Foreign Key √© opcional no model
  },
  {
    timestamps: false,
    tableName: 'addresses',
    underscored: true,
  });

  Address.associate = (models) => {
// define o tipo de relacionamento
    Address.belongsTo(models.Employee,
    // define qual a foreign key a ser criada
      { foreignKey: 'employeeId', as: 'employees' });
  };

  return Address;
};

üëÄ De olho na dica: üëÄ

Note que apesar do uso da Foreign Key ser opcional no model, √© importante deixar expl√≠cito dentro da fun√ß√£o associate qual o relacionamento ser√° feito, e qual Foreign Key vai ser criada quando queremos criar uma Foreign Key.

* Validando relacionamentos 1:1
Agora, vamos validar o relacionamento. Para isso, precisaremos criar seeders para inserirmos dados nas tabelas e um servidor para responder as requisi√ß√µes.

Para criar os dois seeders, utilize os comandos abaixo:

EX:

npx sequelize seed:generate --name employees
npx sequelize seed:generate --name addresses

* Depois, abra o arquivo employees dentro da pasta seeders e copie o c√≥digo a seguir:

EX:

// src/seeders/[timestamp]-employees.js

module.exports = {
  up: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkInsert('employees',
      [
        {
          first_name: 'Marcos',
          last_name: 'Zuck',
          age: 49,
        },
        {
          first_name: 'Fred',
          last_name: 'Merc√∫rio',
          age: 19,
        },
        {
          first_name: 'Ayrton',
          last_name: 'Keno',
          age: 51,
        },
        {
          first_name: 'Robin',
          last_name: 'Mathias',
          age: 63,
        },
      ],
      {},
    );
  },

  down: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkDelete('employees', null, {});
  },
};

* O arquivo addresses da pasta seeds deve conter o seguinte c√≥digo:

EX:

// src/seeders/[timestamp]-addresses.js

module.exports = {
  up: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkInsert('addresses',
      [
        {
          city: 'Belo Horizonte',
          street: 'Rua Fl√≥rida',
          number: 1080,
          employee_id: 1,
        },
        {
          city: 'S√£o Paulo',
          street: 'Avenida Paulista',
          number: 1980,
          employee_id: 2,
        },
        {
          city: 'Fortaleza',
          street: 'Rua das Enseadas',
          number: 95,
          employee_id: 3,
        },
        {
          city: 'Belo Horizonte',
          street: 'Rua Andaluzita',
          number: 131,
          employee_id: 4,
        },
        {
          city: 'Curitiba',
          street: 'Rua Fria',
          number: 101,
          employee_id: 4,
        },
      ],
      {},
    );
  },

  down: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkDelete('addresses', null, {});
  },
};

* Depois, utilize o comando abaixo para executar os seeders:

EX:

env $(cat .env) npx sequelize db:seed:all

Existe uma possibilidade de voc√™ se deparar com o erro ‚ÄúCannot add or update a child row: a foreign key constraint fails‚Äù. Isso acontece porque precisamos que a seed de employees rode primeiro que a de addresses, de forma de que a segunda possa pegar a chave que usa como foreign key da primeira.

Contudo, como criamos as seeds juntas, as timestamps de ambas s√£o iguais e elas acabam sendo executadas na ordem alfab√©tica: primeiro addresses, depois employees, causando o erro. Para resolver isso de forma simples, basta renomear a seed de employees, tornando o n√∫mero da timestamp menor que o de address e rodar o comando acima novamente.

* Por √∫ltimo, vamos criar o servidor para testarmos nossas associations. A grande diferen√ßa quando vamos fazer uma requisi√ß√£o que necessite da utiliza√ß√£o de uma association com o Sequelize, √© o campo include. Esse campo diz ao Sequelize quais ser√£o as configura√ß√µes da requisi√ß√£o. A propriedade model se refere a qual tabela ser√° utilizada. J√° a propriedade as deve ser igual √† que declaramos no momento da cria√ß√£o da associa√ß√£o no respectivo model.

Para finalmente podermos rodar nossa aplica√ß√£o precisamos de mais alguns arquivos. Por isso, dentro de src criaremos os diret√≥rios Services e Controllers e os preencheremos da seguinte forma:

EX:

// src/services/employee.service.js

const { Address, Employee } = require('../models/');

const getAll = async () => {
  const users = await Employee.findAll({
    include: { model: Address, as: 'addresses' },
  });

  return users;
};

module.exports = { getAll };

EX:

// src/controllers/employee.controller.js

const EmployeeService = require('../services/employee.service');

const getAll = async (_req, res) => {
  try {
    const employees = await EmployeeService.getAll();
    return res.status(200).json(employees);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: 'Ocorreu um erro' });
  }
};

module.exports = {
  getAll,
};

* Agora, precisamos criar mais dois arquivos, dentro da pasta src, o app.js e o server.js. Seu preenchimento deve ficar assim:

EX:

// src/app.js

const express = require('express');

const employee = require('./controllers/employee.controller');

const app = express();

app.use(express.json());

app.get('/employees', employee.getAll);

module.exports = app;

EX:

// src/server.js

const app = require('./app');

const PORT = process.env.PORT || 3001;

app.listen(PORT, () => {
  console.log(`Escutando na porta ${PORT}`);
});
Por fim, vamos fazer algumas pequenas altera√ß√µes no package.json: definir nosso arquivo principal e criar um script para rodar a aplica√ß√£o com o nodemon.

EX:

// package.json
{
  // ...
  "main": "src/server.js",
  "scripts": {
    "dev": "nodemon src/server.js"
  },
  // ...
}

Agora, inicie o servidor com "env $(cat .env) npm run dev", fa√ßa uma requisi√ß√£o do tipo GET para o endpoint localhost:3001/employees e verifique a resposta, na qual em cada um dos empregados (employees), aparecer√° o respectivo endere√ßo (address).

esse √© o relacionamento 1:1, agora vamos para o 1:N.

# RELACIONAMENTO 1:N, OU SEJ A 1 PARA MUITOS.

* No caso dos relacionamentos 1:N, n√£o h√° grande diferen√ßa na maneira como criamos as associa√ß√µes. Caso cada employee possu√≠sse v√°rios address, bastaria declarar seu model da seguinte forma:

EX:

// src/models/employee.model.js

//  module.exports = (sequelize, DataTypes) => {
//  const Employee = sequelize.define('Employee', {
//  ...
//  });

//  Employee.associate = (models) => {
    Employee.hasMany(models.Address,
//      { foreignKey: 'employeeId', as: 'addresses' });
//  };

//  return Employee;
//  };

hasMany: tem muitos

Mudamos apenas o m√©todo de declara√ß√£o da associa√ß√£o para hasMany, indicando que cada employee pode possuir muitos addresses. Fa√ßa uma nova requisi√ß√£o para o endpoint localhost:3000/employees e observe o id 4 no resultado e veja a diferen√ßa que ocorre quando √© usado hasOne e/ou hasMany.

No model addresses, por sua vez, n√£o h√° necessidade de alterarmos nada, pois cada address continua pertencendo a apenas um employee, o que justifica o uso do m√©todo belongsTo.

* para funcionar primeiro tem que dropar a tabela (cuidado com os dados, se tiver tudo nos seed pode ir tranquilo como √© o caso desse exemplo), criar ela novamente, depois coloca as migrations e depois as seeds.

EX:

env $(cat .env) npx sequelize db:drop

env $(cat .env) npx sequelize db:create

env $(cat .env) npx sequelize db:migrate

env $(cat .env) npx sequelize db:seed:all

* Agora, veremos os dois m√©todos de utiliza√ß√£o dos relacionamentos:

Eager loading, ou carregamento antecipado;
Lazy loading, ou carregamento tardio.

Nesse caso, vamos aprender a utilizar cada um desses dois modos e como eles acontecem no c√≥digo, usando o relacionamento 1:N visto h√° pouco.

* Eager loading

* Esse m√©todo carrega todos os dados na mesma request. Logo, ao utilizar eager loading, todas as informa√ß√µes s√£o trazidas, independente se vamos us√°-las ou n√£o. Este modo √© √∫til para cen√°rios em que sabemos, j√° de antem√£o, que sempre vamos precisar de todos os dados das entidades envolvidas.

Antes de prosseguirmos, vamos alterar o schema do banco de dados para que as tabelas tenham uma rela√ß√£o 1:N. Para isso, utilizaremos os seeders j√° criados.

* Abra o arquivo [timestamp]-employees.js dentro da pasta seeders, apague tudo que hav√≠amos colocado antes e copie o c√≥digo abaixo:

EX:

// src/seeders/[timestamp]-employees.js

module.exports = {
  up: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkInsert('employees',
      [
        { first_name: 'Marcos', last_name: 'Zuck', age: 49 },
        { first_name: 'Fred', last_name: 'Mercurio', age: 19 },
        { first_name: 'Ayrton', last_name: 'Keno', age: 51 },
        { first_name: 'Robin', last_name: 'Mathias', age: 63 },
        { first_name: 'Antonio', last_name: 'Augusto', age: 18 },
      ],
      {},
    );
  },

  down: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkDelete('employees', null, {});
  },
};

* Depois, abra o arquivo [timestamp]-addresses.js dentro da pasta seeders, limpe-o e copie o c√≥digo abaixo:

EX:

// src/seeders/[timestamp]-addresses.js

module.exports = {
  up: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkInsert('addresses',
      [
        {
          city: 'Belo Horizonte',
          street: 'Rua Florida',
          number: 1080,
          employee_id: 1,
        },
        {
          city: 'S√£o Paulo',
          street: 'Avenida Paulista',
          number: 1980,
          employee_id: 2,
        },
        {
          city: 'Fortaleza',
          street: 'Rua das Enseadas',
          number: 95,
          employee_id: 3,
        },
        {
          city: 'Belo Horizonte',
          street: 'Rua Andaluzita',
          number: 131,
          employee_id: 4,
        },
        {
          city: 'Belo Horizonte',
          street: 'Rua Vicente Alvarenga',
          number: 80,
          employee_id: 1,
        },
        {
          city: 'Curitiba',
          street: 'Rua Fria',
          number: 101,
          employee_id: 5,
        },
      ],
      {},
    );
  },

  down: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkDelete('addresses', null, {});
  },
};

* Finalmente, utilize o comando abaixo para remover as tabelas antigas, depois recri√°-las e, por √∫ltimo, executar os seeders:

EX:

env $(cat .env) npx sequelize db:migrate:undo:all
env $(cat .env) npx sequelize db:migrate
env $(cat .env) npx sequelize db:seed:all

* Agora, vamos ver como utilizar o Eager loading na pr√°tica. Vamos voltar ao arquivo src/app.js e criar mais uma rota:

EX:

// src/app.js

// const express = require('express');
// const employee = require('./controllers/employee.controller');

// const app = express();

// app.use(express.json());

app.get('/employees/:id', employee.getById);
// app.get('/employees', employee.getAll);

// module.exports = app;

* Com a nova rota j√° adicionada, vamos voltar ao arquivo src/controllers/employee.controller.js e adicionar o m√©todo getById:

EX:

// src/controllers/employee.controller.js

// const EmployeeService = require('../services/employee.service');

// const getAll = async (_req, res) => {
//   ...
// };

const getById = async (req, res) => {
  try {
    const { id } = req.params;
    const employee = await EmployeeService.getById(id);

    if (!employee) {
      return res.status(404).json({ message: 'Pessoa colaboradora n√£o encontrada' });
    }

    return res.status(200).json(employee);
  } catch (e) {
    console.log(e);
    res.status(500).json({ message: 'Ocorreu um erro' });
  };
}

// module.exports = {
//   getAll,
  getById
// };

* Por fim, criaremos o m√©todo getById, agora no arquivo src/services/employee.service.js

EX:

// src/services/employee.service.js

// const { Address, Employee } = require('../models/');

// const getAll = async () => {
//   ...
// };

const getById = async (id) => {
  const employee = await Employee.findOne({
      where: { id },
      include: [{ model: Address, as: 'addresses' }],
    });
  return employee;
}

// module.exports = {
//   getAll,
  getById
// };

Agora, fa√ßa uma requisi√ß√£o do tipo GET para o endpoint http://localhost:3001/employees/1 e veja como o resultado √© retornado.

* Al√©m das propriedades que j√° citamos, o campo include pode manipular os dados que ser√£o retornados. Por exemplo, se n√£o quisermos o acesso ao n√∫mero do endere√ßo, bastaria alterar o c√≥digo, adicionando a propriedade attributes e dentro dela o que queremos fazer:

EX:

// src/services/employee.service.js

// ...

// const getAll = async () => {
//   ...
// };

// const getById = async (id) => {
//   const employee = await Employee.findOne({
//       where: { id },
       include: [{
         model: Address, as: 'addresses', attributes: { exclude: ['number'] },
       }],
//   });
//   return employee;
// }

// ...

Dessa maneira, o campo number ser√° exclu√≠do do retorno da requisi√ß√£o.

* lazy loading

Agora vamos ver como funciona a outra forma de carregar dados de associa√ß√µes: o lazy loading. Esse m√©todo consiste, basicamente, em n√£o especificar uma propriedade includes no momento de realizar a query no banco. Dessa forma, cria-se a possibilidade de termos dois usos para o mesmo endpoint.

Para utilizarmos duas a√ß√µes diferentes em um endpoint, usaremos a query string includeAddresses, na qual, caso o par√¢metro dela seja true, os endere√ßos daquele funcion√°rio tamb√©m ser√£o retornados.

* Antes, vamos voltar a fun√ß√£o getById de employee como estava anteriormente:

EX:

// src/services/employee.service.js

// ...

const getById = async (id) => {
  const employee = await Employee.findOne({
    where: { id },
  });
  return employee;
}

// ...

* Agora, vamos criar uma fun√ß√£o getAllByEmployeeId para address que tem como responsabilidade buscar todos os endere√ßos de acordo com o employee_id:

Precisaremos criar o arquivo address.service.js, que ter√° o seguinte c√≥digo:

EX:

// src/services/address.service.js

const { Address } = require('../models/');

const getAllByEmployeeId = async (employeeId) => {
  const addresses = await Address.findAll({ where: { employeeId } });

  return addresses;
};

module.exports = {
  getAllByEmployeeId,
}

Por fim, importamos o service que acabamos de criar para que possamos us√°-lo no Controller:

EX:

// src/controllers/employee.controller.js

const AddressService = require('../services/address.service');

//  ...

const getById = async (req, res) => {
//   try {
//     const { id } = req.params;
//     const employee = await EmployeeService.getById(id);

//     if (!employee) {
//       return res.status(404).json({ message: 'Pessoa colaboradora n√£o encontrada' });
//     }

    if (req.query.includeAddresses === 'true') {
      const addresses = await AddressService.getAllByEmployeeId(id);
      return res.status(200).json({ employee, addresses });
    }

//     return res.status(200).json(employee);
//   } catch (e) {
//     console.log(e);
//     res.status(500).json({ message: 'Ocorreu um erro' });
//   };
// }

// ...

Reinicie a aplica√ß√£o e realize uma requisi√ß√£o do tipo GET para o endpoint http://localhost:3001/employees/1?includeAddresses=true. Depois, altere para ?includeAddresses=false ou retire o ?includeAddresses=true e veja seu retorno.

Como presenciamos, o lazy loading √© muito √∫til em situa√ß√µes em que n√£o sabemos se vamos, de fato, precisar buscar todas as informa√ß√µes de uma s√≥ vez. Aqui, se tiv√©ssemos utilizado o eager loading, ter√≠amos buscado os dados das pessoas colaboradoras mesmo quando includeAddresses n√£o era informado, e precisar√≠amos excluir a chave addresses do resultado do banco. Com o lazy loading, podemos carregar apenas os dados do funcion√°rio e dos endere√ßos apenas quando necess√°rio, economizando recursos do banco.





















