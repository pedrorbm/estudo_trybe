# ORM  = Mapeamento objeto-relacional ou ORM (Object-Relational Mapping) Ã© uma tÃ©cnica que permite fazer um mapeamento estrutural entre as entidades do banco de dados e os objetos que as representam no cÃ³digo JavaScript. O mapeamento objeto-relacional abstrai as diferenÃ§as entre os dois paradigmas, da aplicaÃ§Ã£o e do banco de dados, como podemos ver na imagem a seguir (imagem armazenada na pasta orm-exemplo.png)

Com ORM nÃ£o precisamos mais escrever uma query SQL â€œcruaâ€ para cada vez que formos inserir um registro na tabela. A prÃ³pria biblioteca fica responsÃ¡vel por isso. VocÃª apenas passa o objeto JavaScript para ela e ela insere os dados no banco de dados.

No Node.js, temos o Sequelize, uma biblioteca de ORM bem conhecida e com suporte aos bancos de dados PostgreSQL, MariaDB, MySQL, SQLite e Microsoft SQL Server. Ã‰ justamente nessa biblioteca de ORM que vamos nos aprofundar no conteÃºdo.

* sequelize  = (imagem na pasta estapas-para-implementacao-do-sequelize.png)
Esse processo pode parecer complexo, mas o Sequelize possui muitas vantagens sobre a utilizaÃ§Ã£o de uma interface direta com o MySQL. Quando tentamos fazer a interaÃ§Ã£o direta com o banco de dados, enfrentamos problemas como:

O JavaScript sozinho nÃ£o possui um suporte eficiente para o SQL, vocÃª precisaria de um script SQL separado para criar seu database e tabelas.
As queries SQL precisam ser incorporadas (â€œembedadasâ€) no cÃ³digo do JavaScript para serem utilizadas.
Por causa dessas limitaÃ§Ãµes, acabamos apenas incluindo boilerplates de SQL em vez de utilizar a LÃ³gica de NegÃ³cio na nossa aplicaÃ§Ã£o.
âœï¸Anote aÃ­: boilerplates sÃ£o trechos de cÃ³digo que podem ser reutilizados em muitos lugares com pouca ou nenhuma alteraÃ§Ã£o.

Esses sÃ£o alguns problemas que o Sequelize ajuda a resolver! Com ele, vocÃª pode evitar a criaÃ§Ã£o de queries SQL para produzir as tabelas. Com o uso das models e migrations no Sequelize, o seu cÃ³digo se torna mais legÃ­vel, extensÃ­vel e de fÃ¡cil manutenÃ§Ã£o.

AlÃ©m disso, por meio do mapeamento por objetos relacionais, Ã© possÃ­vel criar as relaÃ§Ãµes e associaÃ§Ãµes entre as tabelas com o prÃ³prio JavaScript. E ainda, Ã© possÃ­vel migrar seu database para outro banco de dados sem precisar reescrever todo o cÃ³digo (por exemplo: mudar de MySQL para o SQL server).

* instalaÃ§ao do sequelize

EX:

npm install -E sequelize@6.3.4

* O prÃ³ximo passo para utilizar o Sequelize Ã© instalar um CLI, que Ã© responsÃ¡vel por gerar e executar as operaÃ§Ãµes. AlÃ©m de instalar o CLI, tambÃ©m precisamos instalar o mysql2, uma dependÃªncia necessÃ¡ria para usarmos o MySQL com o Sequelize. Na pasta raiz da aplicaÃ§Ã£o, rode os comandos: (OBS: FORA DA PASTA "./SRC")

EX:

npm install -D -E sequelize-cli@6.2.0

npm install -E mysql2@2.1.0

mkdir src

* Depois que instalamos o CLI, precisamos iniciar um projeto com o Sequelize. Para isso, vamos executar o seguinte comando dentro da pasta src:

EX:

cd src

npx sequelize-cli init

Esse comando vai criar as seguintes pastas:

config: contÃ©m um arquivo de configuraÃ§Ã£o, com orientaÃ§Ãµes para o CLI se conectar com o nosso banco de dados;

models: contÃ©m todos os modelos da nossa aplicaÃ§Ã£o;

migrations: contÃ©m todos os arquivos de migraÃ§Ã£o da nossa aplicaÃ§Ã£o;

seeders: contÃ©m todos os arquivos de â€œseedsâ€ (sementes que sÃ£o usadas para popular o banco).

âž¡ï¸ O arquivo .sequelizerc

O arquivo .sequelizerc Ã© um arquivo de configuraÃ§Ã£o do Sequelize. Esse arquivo Ã© responsÃ¡vel por configurar o caminho das pastas migrations, models, seeders e config que o Sequelize irÃ¡ procurar ao executar um comando.

Por padrÃ£o, ao rodar um comando Sequelize os arquivos dentro das pastas de migrations, models, seeders e config seriam procurados somente na camada em que estivÃ©ssemos executando o comando. No nosso caso, como estamos utilizando a pasta src para abrigar os arquivos do Sequelize, caso executÃ¡ssemos um comando diretamente na raiz da aplicaÃ§Ã£o, irÃ­amos nos deparar com um erro.

Podemos entrar na pasta src e executar estes comandos, como fizemos anteriormente, pois assim teremos Ãªxito. Mas caso fosse uma aplicaÃ§Ã£o maior, com mais camadas, aumentarÃ­amos a complexidade de subir e configurar a aplicaÃ§Ã£o.

Ã‰ neste momento que entra em cena o arquivo .sequelizerc. Dessa forma, podemos construir um cÃ³digo com uma arquitetura mais organizada. â­

* Antes de configurar esse arquivo, volte para a pasta raiz da aplicaÃ§Ã£o com o seguinte comando:

EX:

cd ..

* Agora crie um arquivo com o nome .sequelizerc com o seguinte conteÃºdo: (O arquivo .sequelizerc Ã© um arquivo de configuraÃ§Ã£o do Sequelize e deve ser criado na pasta raiz. Nesse caso, a pasta app-with-sequelize.)

EX:

// app-with-sequelize/.sequelizerc

const path = require('path');

module.exports = {
  'config': path.resolve('src', 'config', 'config.js'),
  'models-path': path.resolve('src', 'models'),
  'seeders-path': path.resolve('src', 'seeders'),
  'migrations-path': path.resolve('src', 'migrations'),
};

Vamos entender melhor as informaÃ§Ãµes deste arquivo:

path: Ã© um mÃ³dulo interno do Node que nos fornece alguns utilitÃ¡rios para trabalharmos com caminhos de arquivos e diretÃ³rios;

config: Ã© um caminho para o arquivo de configuraÃ§Ã£o;

models-path: Ã© um caminho para o diretÃ³rio de models;

seeders-path: Ã© um caminho para o diretÃ³rio de seeders;

migrations-path: Ã© um caminho para o diretÃ³rio de migrations.

* Agora precisamos configurar o arquivo config.json gerado pelo init do CLI. Ao alterar esse arquivo, estamos configurando o acesso da aplicaÃ§Ã£o ao nosso banco de dados.

âž¡ï¸ Note que o arquivo config.json, localizado no diretÃ³rio ./src/config, contÃ©m informaÃ§Ãµes sensÃ­veis, como credenciais de acesso ao banco de dados, expostas no nosso cÃ³digo. Uma boa prÃ¡tica Ã© substituir os valores por variÃ¡veis de ambiente, nÃ£o expondo assim, informaÃ§Ãµes sensÃ­veis relacionados Ã  configuraÃ§Ã£o geral da aplicaÃ§Ã£o. EntÃ£o, vamos fazer isso do jeito certo!

âž¡ï¸ Mudaremos o nome do nosso arquivo config.json para config.js

âž¡ï¸ Retiraremos todo o conteÃºdo de config.js e substituiremos pelo cÃ³digo abaixo:

EX:

// src/config/config.js

const config = {
  username: process.env.MYSQL_USER,
  password: process.env.MYSQL_PASSWORD,
  database: process.env.MYSQL_DATABASE,
  host: process.env.MYSQL_HOST,
  dialect: 'mysql',
};

module.exports = {
  development: config,
  test: config,
  production: config,
};

Vamos entender melhor as informaÃ§Ãµes que estamos passando:

username: usuÃ¡rio de acesso ao banco de dados;

password: senha de acesso ao banco de dados;

database: nome do banco de dados no qual queremos conectar;

host: servidor no qual estamos conectando - por ser local, utilizamos o endereÃ§o IP 127.0.0.1, ou seu alias localhost;

dialect: informa qual a biblioteca que o sequelize utiliza para se conectar ao banco de dados estamos utilizando. Nesse caso, mysql.

* Modifique o arquivo src/models/index.js para apontar para o arquivo config.js:

EX:

Para fazer isso, busque neste arquivo, a seguinte linha de cÃ³digo:

const config = require(__dirname + '/../config/config.json')[env]; // configuraÃ§Ã£o antiga

Altere esta linha para ficar assim:

/ Praticamente Ã© sÃ³ mudar a extensÃ£o de .json para .js! /
const config = require(__dirname + '/../config/config.js')[env]; // configuraÃ§Ã£o nova

* Antes de rodar os comandos Sequelize, precisamos garantir que temos uma instÃ¢ncia do MySQL rodando.

Caso vocÃª jÃ¡ tenha um container com uma imagem do MySQL, pode utilizÃ¡-lo ou usar o comando abaixo no terminal para criar e rodar um:

âš ï¸ Garanta que a senha do banco esteja de acordo com a presente no .env. ðŸ˜‰

EX:

docker container run --name teste-sequelize -e MYSQL_ROOT_PASSWORD=root -d -p 3306:3306 mysql:8.0.29

*  CriaÃ§Ã£o do banco de dados usando o CLI do Sequelize

âž¡ï¸Agora que iniciamos uma aplicaÃ§Ã£o do Sequelize e a nossa instÃ¢ncia do MySQL estÃ¡ rodando, podemos criar o banco de dados orm_example (que nomeamos no .env) na raiz do projeto:

EX:

env $(cat .env) npx sequelize db:create

NOTA: o comando env $(cat .env) irÃ¡ realizar a leitura das variÃ¡veis do arquivo .env e repassÃ¡-las para o prÃ³ximo comando, disponibilizando assim os valores das variÃ¡veis de ambiente para o seu cÃ³digo atravÃ©s do process.env.NOME_DA_VARIAVEL.

De olho na dica ðŸ‘€: O .sequelizerc procura os arquivos de configuraÃ§Ã£o do Sequelize no diretÃ³rio src. Por isso, Ã© importante que vocÃª esteja na raiz do projeto quando for rodar os comandos do Sequelize.

* No seu terminal, o Sequelize vai avisar que o database foi criado. VocÃª pode verificar isso no prÃ³prio MySQL utilizando os comandos abaixo:

âž¡ï¸ Execute o container criado anteriormente com o comando:

EX:

docker exec -it container-mysql bash

âž¡ï¸ Entre no terminal do mysql com o comando:

mysql -u root -p

âž¡ï¸ Digite a sua senha de acesso ao mysql e em seguida rode o comando abaixo:

show databases;

âž¡ï¸ Perceba que, a partir desses passos, o banco orm_example foi criado e vocÃª nÃ£o precisou escrever nenhuma linha de SQL para isso. Essa Ã© uma das primeiras vantagens que o Sequelize nos oferece.

# MODEL  = Os models sÃ£o a essÃªncia do Sequelize. Um model Ã© uma abstraÃ§Ã£o que representa uma linha na tabela em seu banco de dados e passa vÃ¡rias informaÃ§Ãµes ao Sequelize sobre essa entidade, como o nome e quais atributos (colunas) ela possui (e seus tipos de dados).

* Vamos dar um exemplo para ficar mais evidente! Queremos criar uma tabela users, que contÃ©m dados de vÃ¡rias pessoas usuÃ¡rias.

O que fazemos primeiro Ã© criar um model que vai representar uma pessoa em nossa aplicaÃ§Ã£o, ou uma linha na tabela users no nosso banco (vamos ver a tabela sendo criada no prÃ³ximo tÃ³pico).
Crie um arquivo user.model.js na pasta model com o seguinte conteÃºdo:

EX:

// src/models/user.model.js

const UserModel = (sequelize, DataTypes) => {
  const User = sequelize.define('User', {
    fullName: DataTypes.STRING,
    email: DataTypes.STRING,
  });

  return User;
};

module.exports = UserModel;

Perceba que adicionamos as colunas fullName e email no nosso model, ambas do tipo string.

Note tambÃ©m que o nome do arquivo model Ã© user.model.js e que o nome da funÃ§Ã£o definida nele tambÃ©m estÃ¡ no singular (User). Isso Ã© uma convenÃ§Ã£o. Geralmente os models sÃ£o nomeados no singular, jÃ¡ que representam um registro (o equivalente a uma linha) da tabela, enquanto as tabelas sÃ£o nomeadas no plural. Como nÃ£o explicitamos o nome da tabela no model, por padrÃ£o, o Sequelize coloca no plural o nome do model e o usa como nome da tabela. No nosso caso, o model se chama user e nossa tabela Users, portanto, funciona perfeitamente.

* Utilizando o build
Antes de usarmos as funÃ§Ãµes, vamos adicionar uma nova linha no nosso arquivo user.model.js. Ela vai ser responsÃ¡vel por sincronizar a model com os mÃ©todos do Sequelize:

EX:

// src/models/user.model.js
// const UserModel = (sequelize, DataTypes) => {
//  const User = sequelize.define('User', {
//    fullName: DataTypes.STRING,
//    email: DataTypes.STRING,
//  });
  (async () => {
    await sequelize.sync({ force: true });
    // As funÃ§Ãµes vÃ£o aqui
})();
//  return User;
// };
// module.exports = UserModel;

Note que o mÃ©todo sync estÃ¡ sendo chamado com o parÃ¢metro force: true. Isso significa que, toda vez que o servidor for iniciado, a tabela serÃ¡ recriada. Isso Ã© Ãºtil para testes, mas nÃ£o deve ser usado em produÃ§Ã£o.

* Vamos entÃ£o criar a nossa Model com o mÃ©todo build. O mÃ©todo build Ã© Ãºtil para criar uma instÃ¢ncia de um model, mas sem salvÃ¡-la no banco de dados. Podemos usar essa funÃ§Ã£o quando queremos criar um objeto que vai armazenar dados temporÃ¡rios, por exemplo:

EX:

const sara = User.build({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara instanceof User); // true
console.log(sara.fullName); // "Sara Silva Santos"

Note que o cÃ³digo acima nÃ£o Ã© assÃ­ncrono, o que significa que o mÃ©todo build nÃ£o se comunica com o banco de dados. Isso acontece por que essa funÃ§Ã£o cria uma instÃ¢ncia de um model, que representa os dados que irÃ£o ser salvos no banco de dados, mas nÃ£o os salva. 

* Para salvar os dados no banco de dados, o mÃ©todo save deve ser utilizado:

EX:

await sara.save();
console.log('Pessoa salva no banco de dados!');

O mÃ©todo save Ã© assÃ­ncrono, por isso ele deve ser utilizado com await.

* Criando com create
Uma forma mais simples de criar uma instÃ¢ncia de um model e salvÃ¡-la no banco de dados Ã© usando o mÃ©todo create, que combina o build e o save em uma Ãºnica funÃ§Ã£o:

EX:

const sara = await User.create({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara instanceof User); // true
console.log(sara.name); // "Sara Silva Santos"

Note que o mÃ©todo create Ã© assÃ­ncrono, pois ele se comunica com o banco de dados para criar a instÃ¢ncia do model.

* Modificando informaÃ§Ãµes no banco de dados
Quando trocamos informaÃ§Ãµes de um model, precisamos salvar essas alteraÃ§Ãµes no banco de dados. Para isso, podemos usar o mÃ©todo save:

EX:

const sara = await User.create({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara.fullName); // "Sara Silva Santos"

sara.fullName = "Jane Doe";

// O nome ainda estÃ¡ "Sara Silva Santos" no banco de dados!

await sara.save();

// Agora o nome foi atualizado para "Jane Doe" no banco de dados!

* TambÃ©m Ã© possÃ­vel atualizar diversos campos de uma vez usando o mÃ©todo set:

EX:

const lucas = await User.create({
  fullName: 'Lucas Silva Santos',
  email: 'lucas.ss@trybe.com',
});

lucas.set({
  fullName: "Pedro Silva Santos",
  email: "pedro.ss@trybe.com"
});

// O nome ainda estÃ¡ "Lucas Silva Santos" no banco de dados!

await lucas.save();

// Agora o nome foi atualizado para "Pedro Silva Santos", e o email para pedro.ss@trybe.com no banco de dados!

Note que chamar a funÃ§Ã£o save no arquivo, vai atualizar todos os campos que foram alterados, nÃ£o apenas os que foram modificados atravÃ©s do mÃ©todo set. 

* Para atualizar apenas os campos especÃ­ficos que foram modificados, podemos usar o mÃ©todo update:

EX:

const jane = await User.create({
fullName: "Jane Doe",
email: "jane.doe@trybe.com",
});

jane.email = "ada.doe@trybe.com";
await jane.update({ fullName: "Ada Joe" });

// O banco de dados agora tem "Ada Joe" para o nome, mas o email ainda Ã© "jane.doe@trybe.com".

await jane.save();
// O banco de dados agora tem "ada.doe@trybe.com" para o email.

* Excluindo informaÃ§Ãµes do banco de dados
Quando precisamos excluir um model do banco de dados, podemos usar o mÃ©todo destroy:

EX:

const mario = await User.create({ fullName: "Mario Bors" });

console.log(mario.fullName); // "Mario Bors"

await mario.destroy();

// Agora essa entrada nÃ£o existe mais no banco de dados!

# MIGRATIONS  = Uma migration Ã© uma forma de versionar o schema do banco de dados. Ou seja, cada migration conterÃ¡ um pedaÃ§o de cÃ³digo que representa o histÃ³rico das alteraÃ§Ãµes feitas no nosso banco de dados.

ðŸ’ª Vamos trazer isso pra prÃ¡tica!

Imagine o seguinte: vocÃª escreve um cÃ³digo definindo como um banco de dados deve ser criado e esse cÃ³digo fica salvo em um arquivo na pasta migrations. ApÃ³s um tempo, uma atualizaÃ§Ã£o Ã© feita e uma coluna Ã© acrescentada em uma tabela. O que vocÃª faz?

VocÃª vai escrever o cÃ³digo em outro arquivo para acrescentar essa coluna, certo? Pense que, cada arquivo serÃ¡ marcado com uma estampa datetime, entÃ£o ao longo do tempo esse cÃ³digo vai empilhando dezenas, Ã s vezes centenas, de arquivos. Cada um desses arquivos marca uma versÃ£o do banco de dados e o seu histÃ³rico de mudanÃ§as e evoluÃ§Ãµes.

Quem clona um projeto pela primeira vez, roda suas migrations para configurar o banco de dados no formato mais recente enviado para a main (ou branch principal), sem ter que fazer mais nada. AÃ­ sim Ã© possÃ­vel trabalhar localmente no banco de dados da aplicaÃ§Ã£o sem medo de ele ser diferente da versÃ£o mais nova que encontramos na main.

Usando migrations, o mapeador objeto-relacional sabe exatamente quais alteraÃ§Ãµes executar no banco de dados, tanto para criar algo novo quanto para restaurar o banco para uma versÃ£o mais antiga. AlÃ©m disso, uma migration tem dois cÃ³digos conhecidos como Up e Down. Ou seja: toda migration, alÃ©m de saber o que fazer para executar as mudanÃ§as no banco de dados (Up), tambÃ©m deve saber como reverter essas mudanÃ§as (Down). Isso significa que as migrations tÃªm o poder de avanÃ§ar ou reverter o seu banco de dados para qualquer um dos estados que ele jÃ¡ teve.

EX:

(imagem salva na pasta "exemplo-migrations.png")

*  Agora vamos gerar um novo arquivo, com apenas o â€œesqueletoâ€ de uma migration, usando o seguinte comando no terminal:

EX:

npx sequelize migration:generate --name create-user

* Com isso, um novo arquivo [timestamp]-create-user.js serÃ¡ criado na pasta migrations contendo o seguinte cÃ³digo:

EX:

// src/migrations/[timestamp]-create-user.js

'use strict';

module.exports = {
  async up (queryInterface, Sequelize) {
    /**
     * Add altering commands here.
     *
     * Example:
     * await queryInterface.createTable('users', { id: Sequelize.INTEGER });
     */
  },

  async down (queryInterface, Sequelize) {
    /**
     * Add reverting commands here.
     *
     * Example:
     * await queryInterface.dropTable('users');
     */
  }
};

Ao serem criadas pelo Sequelize, os arquivos de migrations e seeds tÃªm seus nomes iniciados por um timestamp, que Ã© seguido pelo nome que nÃ³s definimos no comando, gerando ao final um arquivo de nome similar a 20220827010852-create-user.js.

* Agora vamos mexer apenas dentro das funÃ§Ãµes up e down. Repare que ambas as funÃ§Ãµes recebem dois parÃ¢metros: um Ã© o queryInterface, e o outro Ã© o Sequelize. Ambos os parÃ¢metros sÃ£o objetos que armazenam dados e operaÃ§Ãµes. O queryInterface Ã© usado pela biblioteca para modificar o banco de dados, seguindo o â€œdialetoâ€ do banco que estamos utilizando. O objeto Sequelize armazena os tipos de dados disponÃ­veis no contexto do banco, por exemplo varchar, string, integer, date etc.

âž¡ï¸ O objetivo da nossa migration Ã© criar a tabela users com os seguintes campos e condiÃ§Ãµes:

id: Identificador do item.

Ã‰ uma chave primÃ¡ria;
Valor nÃ£o pode ser nulo;
Possui incremento automÃ¡tico;
Ã‰ do tipo Integer.
fullName: Nome completo da pessoa usuÃ¡ria da aplicaÃ§Ã£o.

Ã‰ do tipo String.
email: E-mail da pessoa usuÃ¡ria da aplicaÃ§Ã£o.

Ã‰ do tipo String.
createdAt: Data da criaÃ§Ã£o do item.

Valor nÃ£o pode ser nulo;
Ã‰ do tipo Date.
updatedAt: Data da atualizaÃ§Ã£o do item.

Valor nÃ£o pode ser nulo;
Ã‰ do tipo Date.
Podemos criar a tabela Users atravÃ©s da funÃ§Ã£o createTable do queryInterface. A funÃ§Ã£o createTable recebe dois parÃ¢metros:

O primeiro recebe uma string com o nome da tabela;
O segundo recebe um objeto com os campos, e suas condiÃ§Ãµes, da tabela.
Lembra da convenÃ§Ã£o que mencionamos anteriormente, na qual o nome do model Ã© no singular e o nome da tabela Ã© no plural? Ã‰ por esta razÃ£o que na funÃ§Ã£o createTable o nome especificado serÃ¡ "Users". ðŸ˜‰

* Para comeÃ§ar, chamamos a funÃ§Ã£o createTable passando o nome da tabela dentro do bloco de execuÃ§Ã£o (up):

âš ï¸ Usamos o await porque a funÃ§Ã£o createTable Ã© assÃ­ncrona!

EX:

// src/migrations/[timestamp]-create-user.js

// 'use strict';

// module.exports = {
//   up: async (queryInterface, Sequelize) => {
       await queryInterface.createTable('Users', {});
//   },

//   down: async (queryInterface, Sequelize) => {
      /**
       * Add reverting commands here.
       *
       * Example:
       * await queryInterface.dropTable('users');
       */
//   }
// };

* Agora vamos adicionar todos os campos da nossa tabela e suas determinadas condiÃ§Ãµes:

EX:

// src/migrations/[timestamp]-create-user.js

// 'use strict';

// module.exports = {
//   up: async (queryInterface, Sequelize) => {
       await queryInterface.createTable('Users', {
         id: {
           allowNull: false,
           autoIncrement: true,
           primaryKey: true,
           type: Sequelize.INTEGER
         },
         fullName: {
           type: Sequelize.STRING
         },
         email: {
           type: Sequelize.STRING
         },
         createdAt: {
           allowNull: false,
           type: Sequelize.DATE
         },
         updatedAt: {
           allowNull: false,
           type: Sequelize.DATE
         }
       });
//   },

//   down: async (queryInterface, Sequelize) => {
      /**
       * Add reverting commands here.
       *
       * Example:
       * await queryInterface.dropTable('users');
       */
//   }
// };

âž¡ï¸ Percebeu que cada campo possui um objeto representando as propriedades daquele campo em especÃ­fico? Veja o que sÃ£o cada uma dessas propriedades:

allowNull: Define se o campo pode ou nÃ£o receber um valor null;
autoIncrement: Define se o campo vai ter incremento automÃ¡tico;
primaryKey: Define se o campo Ã© uma chave primÃ¡ria;
type: Define o tipo do campo, por exemplo STRING, INTEGER, DATE, etc.

* Agora vamos implementar o bloco de reversÃ£o (down) com um cÃ³digo que vai apenas apagar a tabela caso seja necessÃ¡rio desfazer a operaÃ§Ã£o de execuÃ§Ã£o (up). Assim escreveremos uma migration perfeitamente reversÃ­vel!

EX:

// src/migrations/[timestamp]-create-user.js

//  'use strict';

//  module.exports = {
//    up: async (queryInterface, Sequelize) => {
//      ...
//    },
//    down: async (queryInterface, Sequelize) => {
        await queryInterface.dropTable('Users');
//    }
//  };

âš ï¸Importante: se o cÃ³digo da migration tiver erros, as suas migrations podem nÃ£o executar corretamente os processos de criar ou desfazer uma nova versÃ£o do banco. Ã‰ preciso ter bastante cuidado na hora de mexer no cÃ³digo de uma migration.

âš ï¸Importante: A execuÃ§Ã£o de uma migration requer o uso das variÃ¡veis de ambiente, uma vez que serÃ¡ realizado um acesso ao banco de dados.

* Com a migration criada, basta executarmos o seguinte comando pelo CLI:

EX:

env $(cat .env) npx sequelize db:migrate

* Caso queira reverter uma migration use o seguinte comando:

EX:

env $(cat .env) npx sequelize db:migrate:undo

* Criando uma nova migration para alterar uma tabela jÃ¡ existente
Imagine agora, com base no modelo User, se for preciso salvar o telefone do usuÃ¡rio. O que pode vir Ã  mente Ã© que basta adicionar o novo atributo no modelo e na migration, como fizemos com o atributo email anteriormente, correto?

âŒ Errado, essa Ã© uma prÃ¡tica que nÃ£o Ã© escalÃ¡vel! Imagine que foi feito um deploy do seu cÃ³digo e a migration foi usada para criar o banco em ambiente de produÃ§Ã£o. Nesse caso, vocÃª teria que rodar o comando db:migrate:undo e recriar o banco para executar o comando db:migrate, para entÃ£o recriar uma tabela. O problema disso Ã© que ao rodar o undo vocÃª perde todos os dados salvos anteriormente na tabela, e isso Ã© uma coisa que jamais deve ser feita. Anotou aÃ­?

EntÃ£o qual seria a forma correta de adicionar uma nova coluna em uma tabela jÃ¡ existente?

âœ”ï¸ A resposta certa Ã©: criar uma nova migration que permita alterar a tabela. Para isso, o objeto queryInterface possui funÃ§Ãµes especÃ­ficas, que permitem criar uma nova coluna, remover uma coluna ou mesmo mudar o tipo de uma coluna que jÃ¡ existe. Nesse caso, o queryInterface abstrai o que a funÃ§Ã£o ALTER TABLE faz no SQL. Deseja saber mais sobre ALTER TABLE e estÃ¡ com sua gestÃ£o de tempo em dia? Consulte o conteÃºdo adicional sobre o assunto.

Lembre-se que a tabela Users tem que estar criada para que os passos a seguir sejam executados com sucesso, portanto, se vocÃª reverteu a migration que a criava, refaÃ§a-a com o comando npx sequelize db:migrate.

* Para criar uma outra migration para adicionar a coluna phoneNum na sua tabela Users, vocÃª deve criar um novo arquivo com o seguinte comando:

EX:

npx sequelize migration:generate --name add-column-phone-table-users

Com isso, um novo arquivo [timestamp]-add-column-phone-table-users.js serÃ¡ criado.

* Agora podemos inserir a funÃ§Ã£o queryInterface.addColumn() no escopo Up para adicionar uma nova coluna Ã  nossa tabela Users, e adicionar a funÃ§Ã£o queryInterface.removeColumn() no escopo Down para remover a nova coluna da tabela. Veja como fazer isso a partir do cÃ³digo abaixo:

EX:

// src/migrations/[timestamp]-add-column-phone-table-users.js

'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
   await queryInterface.addColumn('Users', 'phoneNum', {
     type: Sequelize.STRING,
   });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('Users', 'phoneNum');
  }
};















