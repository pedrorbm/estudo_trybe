# ORM  = Mapeamento objeto-relacional ou ORM (Object-Relational Mapping) é uma técnica que permite fazer um mapeamento estrutural entre as entidades do banco de dados e os objetos que as representam no código JavaScript. O mapeamento objeto-relacional abstrai as diferenças entre os dois paradigmas, da aplicação e do banco de dados, como podemos ver na imagem a seguir (imagem armazenada na pasta orm-exemplo.png)

Com ORM não precisamos mais escrever uma query SQL “crua” para cada vez que formos inserir um registro na tabela. A própria biblioteca fica responsável por isso. Você apenas passa o objeto JavaScript para ela e ela insere os dados no banco de dados.

No Node.js, temos o Sequelize, uma biblioteca de ORM bem conhecida e com suporte aos bancos de dados PostgreSQL, MariaDB, MySQL, SQLite e Microsoft SQL Server. É justamente nessa biblioteca de ORM que vamos nos aprofundar no conteúdo.

* sequelize  = (imagem na pasta estapas-para-implementacao-do-sequelize.png)
Esse processo pode parecer complexo, mas o Sequelize possui muitas vantagens sobre a utilização de uma interface direta com o MySQL. Quando tentamos fazer a interação direta com o banco de dados, enfrentamos problemas como:

O JavaScript sozinho não possui um suporte eficiente para o SQL, você precisaria de um script SQL separado para criar seu database e tabelas.
As queries SQL precisam ser incorporadas (“embedadas”) no código do JavaScript para serem utilizadas.
Por causa dessas limitações, acabamos apenas incluindo boilerplates de SQL em vez de utilizar a Lógica de Negócio na nossa aplicação.
✏️Anote aí: boilerplates são trechos de código que podem ser reutilizados em muitos lugares com pouca ou nenhuma alteração.

Esses são alguns problemas que o Sequelize ajuda a resolver! Com ele, você pode evitar a criação de queries SQL para produzir as tabelas. Com o uso das models e migrations no Sequelize, o seu código se torna mais legível, extensível e de fácil manutenção.

Além disso, por meio do mapeamento por objetos relacionais, é possível criar as relações e associações entre as tabelas com o próprio JavaScript. E ainda, é possível migrar seu database para outro banco de dados sem precisar reescrever todo o código (por exemplo: mudar de MySQL para o SQL server).

* instalaçao do sequelize

EX:

npm install -E sequelize@6.3.4

* O próximo passo para utilizar o Sequelize é instalar um CLI, que é responsável por gerar e executar as operações. Além de instalar o CLI, também precisamos instalar o mysql2, uma dependência necessária para usarmos o MySQL com o Sequelize. Na pasta raiz da aplicação, rode os comandos: (OBS: FORA DA PASTA "./SRC")

EX:

npm install -D -E sequelize-cli@6.2.0

npm install -E mysql2@2.1.0

mkdir src

* Depois que instalamos o CLI, precisamos iniciar um projeto com o Sequelize. Para isso, vamos executar o seguinte comando dentro da pasta src:

EX:

cd src

npx sequelize-cli init

Esse comando vai criar as seguintes pastas:

config: contém um arquivo de configuração, com orientações para o CLI se conectar com o nosso banco de dados;

models: contém todos os modelos da nossa aplicação;

migrations: contém todos os arquivos de migração da nossa aplicação;

seeders: contém todos os arquivos de “seeds” (sementes que são usadas para popular o banco).

➡️ O arquivo .sequelizerc

O arquivo .sequelizerc é um arquivo de configuração do Sequelize. Esse arquivo é responsável por configurar o caminho das pastas migrations, models, seeders e config que o Sequelize irá procurar ao executar um comando.

Por padrão, ao rodar um comando Sequelize os arquivos dentro das pastas de migrations, models, seeders e config seriam procurados somente na camada em que estivéssemos executando o comando. No nosso caso, como estamos utilizando a pasta src para abrigar os arquivos do Sequelize, caso executássemos um comando diretamente na raiz da aplicação, iríamos nos deparar com um erro.

Podemos entrar na pasta src e executar estes comandos, como fizemos anteriormente, pois assim teremos êxito. Mas caso fosse uma aplicação maior, com mais camadas, aumentaríamos a complexidade de subir e configurar a aplicação.

É neste momento que entra em cena o arquivo .sequelizerc. Dessa forma, podemos construir um código com uma arquitetura mais organizada. ⭐

* Antes de configurar esse arquivo, volte para a pasta raiz da aplicação com o seguinte comando:

EX:

cd ..

* Agora crie um arquivo com o nome .sequelizerc com o seguinte conteúdo: (O arquivo .sequelizerc é um arquivo de configuração do Sequelize e deve ser criado na pasta raiz. Nesse caso, a pasta app-with-sequelize.)

EX:

// app-with-sequelize/.sequelizerc

const path = require('path');

module.exports = {
  'config': path.resolve('src', 'config', 'config.js'),
  'models-path': path.resolve('src', 'models'),
  'seeders-path': path.resolve('src', 'seeders'),
  'migrations-path': path.resolve('src', 'migrations'),
};

Vamos entender melhor as informações deste arquivo:

path: é um módulo interno do Node que nos fornece alguns utilitários para trabalharmos com caminhos de arquivos e diretórios;

config: é um caminho para o arquivo de configuração;

models-path: é um caminho para o diretório de models;

seeders-path: é um caminho para o diretório de seeders;

migrations-path: é um caminho para o diretório de migrations.

* Agora precisamos configurar o arquivo config.json gerado pelo init do CLI. Ao alterar esse arquivo, estamos configurando o acesso da aplicação ao nosso banco de dados.

➡️ Note que o arquivo config.json, localizado no diretório ./src/config, contém informações sensíveis, como credenciais de acesso ao banco de dados, expostas no nosso código. Uma boa prática é substituir os valores por variáveis de ambiente, não expondo assim, informações sensíveis relacionados à configuração geral da aplicação. Então, vamos fazer isso do jeito certo!

➡️ Mudaremos o nome do nosso arquivo config.json para config.js

➡️ Retiraremos todo o conteúdo de config.js e substituiremos pelo código abaixo:

EX:

// src/config/config.js

const config = {
  username: process.env.MYSQL_USER,
  password: process.env.MYSQL_PASSWORD,
  database: process.env.MYSQL_DATABASE,
  host: process.env.MYSQL_HOST,
  dialect: 'mysql',
};

module.exports = {
  development: config,
  test: config,
  production: config,
};

Vamos entender melhor as informações que estamos passando:

username: usuário de acesso ao banco de dados;

password: senha de acesso ao banco de dados;

database: nome do banco de dados no qual queremos conectar;

host: servidor no qual estamos conectando - por ser local, utilizamos o endereço IP 127.0.0.1, ou seu alias localhost;

dialect: informa qual a biblioteca que o sequelize utiliza para se conectar ao banco de dados estamos utilizando. Nesse caso, mysql.

* Modifique o arquivo src/models/index.js para apontar para o arquivo config.js:

EX:

Para fazer isso, busque neste arquivo, a seguinte linha de código:

const config = require(__dirname + '/../config/config.json')[env]; // configuração antiga

Altere esta linha para ficar assim:

/ Praticamente é só mudar a extensão de .json para .js! /
const config = require(__dirname + '/../config/config.js')[env]; // configuração nova

* Antes de rodar os comandos Sequelize, precisamos garantir que temos uma instância do MySQL rodando.

Caso você já tenha um container com uma imagem do MySQL, pode utilizá-lo ou usar o comando abaixo no terminal para criar e rodar um:

⚠️ Garanta que a senha do banco esteja de acordo com a presente no .env. 😉

EX:

docker container run --name teste-sequelize -e MYSQL_ROOT_PASSWORD=root -d -p 3306:3306 mysql:8.0.29

*  Criação do banco de dados usando o CLI do Sequelize

➡️Agora que iniciamos uma aplicação do Sequelize e a nossa instância do MySQL está rodando, podemos criar o banco de dados orm_example (que nomeamos no .env) na raiz do projeto:

EX:

env $(cat .env) npx sequelize db:create

NOTA: o comando env $(cat .env) irá realizar a leitura das variáveis do arquivo .env e repassá-las para o próximo comando, disponibilizando assim os valores das variáveis de ambiente para o seu código através do process.env.NOME_DA_VARIAVEL.

De olho na dica 👀: O .sequelizerc procura os arquivos de configuração do Sequelize no diretório src. Por isso, é importante que você esteja na raiz do projeto quando for rodar os comandos do Sequelize.

* No seu terminal, o Sequelize vai avisar que o database foi criado. Você pode verificar isso no próprio MySQL utilizando os comandos abaixo:

➡️ Execute o container criado anteriormente com o comando:

EX:

docker exec -it container-mysql bash

➡️ Entre no terminal do mysql com o comando:

mysql -u root -p

➡️ Digite a sua senha de acesso ao mysql e em seguida rode o comando abaixo:

show databases;

➡️ Perceba que, a partir desses passos, o banco orm_example foi criado e você não precisou escrever nenhuma linha de SQL para isso. Essa é uma das primeiras vantagens que o Sequelize nos oferece.

# MODEL  = Os models são a essência do Sequelize. Um model é uma abstração que representa uma linha na tabela em seu banco de dados e passa várias informações ao Sequelize sobre essa entidade, como o nome e quais atributos (colunas) ela possui (e seus tipos de dados).

* Vamos dar um exemplo para ficar mais evidente! Queremos criar uma tabela users, que contém dados de várias pessoas usuárias.

O que fazemos primeiro é criar um model que vai representar uma pessoa em nossa aplicação, ou uma linha na tabela users no nosso banco (vamos ver a tabela sendo criada no próximo tópico).
Crie um arquivo user.model.js na pasta model com o seguinte conteúdo:

EX:

// src/models/user.model.js

const UserModel = (sequelize, DataTypes) => {
  const User = sequelize.define('User', {
    fullName: DataTypes.STRING,
    email: DataTypes.STRING,
  });

  return User;
};

module.exports = UserModel;

Perceba que adicionamos as colunas fullName e email no nosso model, ambas do tipo string.

Note também que o nome do arquivo model é user.model.js e que o nome da função definida nele também está no singular (User). Isso é uma convenção. Geralmente os models são nomeados no singular, já que representam um registro (o equivalente a uma linha) da tabela, enquanto as tabelas são nomeadas no plural. Como não explicitamos o nome da tabela no model, por padrão, o Sequelize coloca no plural o nome do model e o usa como nome da tabela. No nosso caso, o model se chama user e nossa tabela Users, portanto, funciona perfeitamente.

* Utilizando o build
Antes de usarmos as funções, vamos adicionar uma nova linha no nosso arquivo user.model.js. Ela vai ser responsável por sincronizar a model com os métodos do Sequelize:

EX:

// src/models/user.model.js
// const UserModel = (sequelize, DataTypes) => {
//  const User = sequelize.define('User', {
//    fullName: DataTypes.STRING,
//    email: DataTypes.STRING,
//  });
  (async () => {
    await sequelize.sync({ force: true });
    // As funções vão aqui
})();
//  return User;
// };
// module.exports = UserModel;

Note que o método sync está sendo chamado com o parâmetro force: true. Isso significa que, toda vez que o servidor for iniciado, a tabela será recriada. Isso é útil para testes, mas não deve ser usado em produção.

* Vamos então criar a nossa Model com o método build. O método build é útil para criar uma instância de um model, mas sem salvá-la no banco de dados. Podemos usar essa função quando queremos criar um objeto que vai armazenar dados temporários, por exemplo:

EX:

const sara = User.build({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara instanceof User); // true
console.log(sara.fullName); // "Sara Silva Santos"

Note que o código acima não é assíncrono, o que significa que o método build não se comunica com o banco de dados. Isso acontece por que essa função cria uma instância de um model, que representa os dados que irão ser salvos no banco de dados, mas não os salva. 

* Para salvar os dados no banco de dados, o método save deve ser utilizado:

EX:

await sara.save();
console.log('Pessoa salva no banco de dados!');

O método save é assíncrono, por isso ele deve ser utilizado com await.

* Criando com create
Uma forma mais simples de criar uma instância de um model e salvá-la no banco de dados é usando o método create, que combina o build e o save em uma única função:

EX:

const sara = await User.create({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara instanceof User); // true
console.log(sara.name); // "Sara Silva Santos"

Note que o método create é assíncrono, pois ele se comunica com o banco de dados para criar a instância do model.

* Modificando informações no banco de dados
Quando trocamos informações de um model, precisamos salvar essas alterações no banco de dados. Para isso, podemos usar o método save:

EX:

const sara = await User.create({
  fullName: 'Sara Silva Santos',
  email: 'sara.ss@trybe.com',
});

console.log(sara.fullName); // "Sara Silva Santos"

sara.fullName = "Jane Doe";

// O nome ainda está "Sara Silva Santos" no banco de dados!

await sara.save();

// Agora o nome foi atualizado para "Jane Doe" no banco de dados!

* Também é possível atualizar diversos campos de uma vez usando o método set:

EX:

const lucas = await User.create({
  fullName: 'Lucas Silva Santos',
  email: 'lucas.ss@trybe.com',
});

lucas.set({
  fullName: "Pedro Silva Santos",
  email: "pedro.ss@trybe.com"
});

// O nome ainda está "Lucas Silva Santos" no banco de dados!

await lucas.save();

// Agora o nome foi atualizado para "Pedro Silva Santos", e o email para pedro.ss@trybe.com no banco de dados!

Note que chamar a função save no arquivo, vai atualizar todos os campos que foram alterados, não apenas os que foram modificados através do método set. 

* Para atualizar apenas os campos específicos que foram modificados, podemos usar o método update:

EX:

const jane = await User.create({
fullName: "Jane Doe",
email: "jane.doe@trybe.com",
});

jane.email = "ada.doe@trybe.com";
await jane.update({ fullName: "Ada Joe" });

// O banco de dados agora tem "Ada Joe" para o nome, mas o email ainda é "jane.doe@trybe.com".

await jane.save();
// O banco de dados agora tem "ada.doe@trybe.com" para o email.

* Excluindo informações do banco de dados
Quando precisamos excluir um model do banco de dados, podemos usar o método destroy:

EX:

const mario = await User.create({ fullName: "Mario Bors" });

console.log(mario.fullName); // "Mario Bors"

await mario.destroy();

// Agora essa entrada não existe mais no banco de dados!

# MIGRATIONS  = Uma migration é uma forma de versionar o schema do banco de dados. Ou seja, cada migration conterá um pedaço de código que representa o histórico das alterações feitas no nosso banco de dados.

💪 Vamos trazer isso pra prática!

Imagine o seguinte: você escreve um código definindo como um banco de dados deve ser criado e esse código fica salvo em um arquivo na pasta migrations. Após um tempo, uma atualização é feita e uma coluna é acrescentada em uma tabela. O que você faz?

Você vai escrever o código em outro arquivo para acrescentar essa coluna, certo? Pense que, cada arquivo será marcado com uma estampa datetime, então ao longo do tempo esse código vai empilhando dezenas, às vezes centenas, de arquivos. Cada um desses arquivos marca uma versão do banco de dados e o seu histórico de mudanças e evoluções.

Quem clona um projeto pela primeira vez, roda suas migrations para configurar o banco de dados no formato mais recente enviado para a main (ou branch principal), sem ter que fazer mais nada. Aí sim é possível trabalhar localmente no banco de dados da aplicação sem medo de ele ser diferente da versão mais nova que encontramos na main.

Usando migrations, o mapeador objeto-relacional sabe exatamente quais alterações executar no banco de dados, tanto para criar algo novo quanto para restaurar o banco para uma versão mais antiga. Além disso, uma migration tem dois códigos conhecidos como Up e Down. Ou seja: toda migration, além de saber o que fazer para executar as mudanças no banco de dados (Up), também deve saber como reverter essas mudanças (Down). Isso significa que as migrations têm o poder de avançar ou reverter o seu banco de dados para qualquer um dos estados que ele já teve.

EX:

(imagem salva na pasta "exemplo-migrations.png")

*  Agora vamos gerar um novo arquivo, com apenas o “esqueleto” de uma migration, usando o seguinte comando no terminal:

EX:

npx sequelize migration:generate --name create-user

* Com isso, um novo arquivo [timestamp]-create-user.js será criado na pasta migrations contendo o seguinte código:

EX:

// src/migrations/[timestamp]-create-user.js

'use strict';

module.exports = {
  async up (queryInterface, Sequelize) {
    /**
     * Add altering commands here.
     *
     * Example:
     * await queryInterface.createTable('users', { id: Sequelize.INTEGER });
     */
  },

  async down (queryInterface, Sequelize) {
    /**
     * Add reverting commands here.
     *
     * Example:
     * await queryInterface.dropTable('users');
     */
  }
};

Ao serem criadas pelo Sequelize, os arquivos de migrations e seeds têm seus nomes iniciados por um timestamp, que é seguido pelo nome que nós definimos no comando, gerando ao final um arquivo de nome similar a 20220827010852-create-user.js.

* Agora vamos mexer apenas dentro das funções up e down. Repare que ambas as funções recebem dois parâmetros: um é o queryInterface, e o outro é o Sequelize. Ambos os parâmetros são objetos que armazenam dados e operações. O queryInterface é usado pela biblioteca para modificar o banco de dados, seguindo o “dialeto” do banco que estamos utilizando. O objeto Sequelize armazena os tipos de dados disponíveis no contexto do banco, por exemplo varchar, string, integer, date etc.

➡️ O objetivo da nossa migration é criar a tabela users com os seguintes campos e condições:

id: Identificador do item.

É uma chave primária;
Valor não pode ser nulo;
Possui incremento automático;
É do tipo Integer.
fullName: Nome completo da pessoa usuária da aplicação.

É do tipo String.
email: E-mail da pessoa usuária da aplicação.

É do tipo String.
createdAt: Data da criação do item.

Valor não pode ser nulo;
É do tipo Date.
updatedAt: Data da atualização do item.

Valor não pode ser nulo;
É do tipo Date.
Podemos criar a tabela Users através da função createTable do queryInterface. A função createTable recebe dois parâmetros:

O primeiro recebe uma string com o nome da tabela;
O segundo recebe um objeto com os campos, e suas condições, da tabela.
Lembra da convenção que mencionamos anteriormente, na qual o nome do model é no singular e o nome da tabela é no plural? É por esta razão que na função createTable o nome especificado será "Users". 😉

* Para começar, chamamos a função createTable passando o nome da tabela dentro do bloco de execução (up):

⚠️ Usamos o await porque a função createTable é assíncrona!

EX:

// src/migrations/[timestamp]-create-user.js

// 'use strict';

// module.exports = {
//   up: async (queryInterface, Sequelize) => {
       await queryInterface.createTable('Users', {});
//   },

//   down: async (queryInterface, Sequelize) => {
      /**
       * Add reverting commands here.
       *
       * Example:
       * await queryInterface.dropTable('users');
       */
//   }
// };

* Agora vamos adicionar todos os campos da nossa tabela e suas determinadas condições:

EX:

// src/migrations/[timestamp]-create-user.js

// 'use strict';

// module.exports = {
//   up: async (queryInterface, Sequelize) => {
       await queryInterface.createTable('Users', {
         id: {
           allowNull: false,
           autoIncrement: true,
           primaryKey: true,
           type: Sequelize.INTEGER
         },
         fullName: {
           type: Sequelize.STRING
         },
         email: {
           type: Sequelize.STRING
         },
         createdAt: {
           allowNull: false,
           type: Sequelize.DATE
         },
         updatedAt: {
           allowNull: false,
           type: Sequelize.DATE
         }
       });
//   },

//   down: async (queryInterface, Sequelize) => {
      /**
       * Add reverting commands here.
       *
       * Example:
       * await queryInterface.dropTable('users');
       */
//   }
// };

➡️ Percebeu que cada campo possui um objeto representando as propriedades daquele campo em específico? Veja o que são cada uma dessas propriedades:

allowNull: Define se o campo pode ou não receber um valor null;
autoIncrement: Define se o campo vai ter incremento automático;
primaryKey: Define se o campo é uma chave primária;
type: Define o tipo do campo, por exemplo STRING, INTEGER, DATE, etc.

* Agora vamos implementar o bloco de reversão (down) com um código que vai apenas apagar a tabela caso seja necessário desfazer a operação de execução (up). Assim escreveremos uma migration perfeitamente reversível!

EX:

// src/migrations/[timestamp]-create-user.js

//  'use strict';

//  module.exports = {
//    up: async (queryInterface, Sequelize) => {
//      ...
//    },
//    down: async (queryInterface, Sequelize) => {
        await queryInterface.dropTable('Users');
//    }
//  };

⚠️Importante: se o código da migration tiver erros, as suas migrations podem não executar corretamente os processos de criar ou desfazer uma nova versão do banco. É preciso ter bastante cuidado na hora de mexer no código de uma migration.

⚠️Importante: A execução de uma migration requer o uso das variáveis de ambiente, uma vez que será realizado um acesso ao banco de dados.

* Com a migration criada, basta executarmos o seguinte comando pelo CLI:

EX:

env $(cat .env) npx sequelize db:migrate

* Caso queira reverter uma migration use o seguinte comando:

EX:

env $(cat .env) npx sequelize db:migrate:undo

* Criando uma nova migration para alterar uma tabela já existente
Imagine agora, com base no modelo User, se for preciso salvar o telefone do usuário. O que pode vir à mente é que basta adicionar o novo atributo no modelo e na migration, como fizemos com o atributo email anteriormente, correto?

❌ Errado, essa é uma prática que não é escalável! Imagine que foi feito um deploy do seu código e a migration foi usada para criar o banco em ambiente de produção. Nesse caso, você teria que rodar o comando db:migrate:undo e recriar o banco para executar o comando db:migrate, para então recriar uma tabela. O problema disso é que ao rodar o undo você perde todos os dados salvos anteriormente na tabela, e isso é uma coisa que jamais deve ser feita. Anotou aí?

Então qual seria a forma correta de adicionar uma nova coluna em uma tabela já existente?

✔️ A resposta certa é: criar uma nova migration que permita alterar a tabela. Para isso, o objeto queryInterface possui funções específicas, que permitem criar uma nova coluna, remover uma coluna ou mesmo mudar o tipo de uma coluna que já existe. Nesse caso, o queryInterface abstrai o que a função ALTER TABLE faz no SQL. Deseja saber mais sobre ALTER TABLE e está com sua gestão de tempo em dia? Consulte o conteúdo adicional sobre o assunto.

Lembre-se que a tabela Users tem que estar criada para que os passos a seguir sejam executados com sucesso, portanto, se você reverteu a migration que a criava, refaça-a com o comando npx sequelize db:migrate.

* Para criar uma outra migration para adicionar a coluna phoneNum na sua tabela Users, você deve criar um novo arquivo com o seguinte comando:

EX:

npx sequelize migration:generate --name add-column-phone-table-users

Com isso, um novo arquivo [timestamp]-add-column-phone-table-users.js será criado.

* Agora podemos inserir a função queryInterface.addColumn() no escopo Up para adicionar uma nova coluna à nossa tabela Users, e adicionar a função queryInterface.removeColumn() no escopo Down para remover a nova coluna da tabela. Veja como fazer isso a partir do código abaixo:

EX:

// src/migrations/[timestamp]-add-column-phone-table-users.js

'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
   await queryInterface.addColumn('Users', 'phoneNum', {
     type: Sequelize.STRING,
   });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('Users', 'phoneNum');
  }
};

*  Em seguida rodamos o comando abaixo para executar a nossa nova migration:

EX:

env $(cat .env) npx sequelize db:migrate

* Também devemos alterar o model user.model.js para incluir a nova coluna phoneNum da seguinte forma:

EX:

// src/models/user.model.js

// const User = (sequelize, DataTypes) => {
//   const User = sequelize.define('User', {
//     fullName: DataTypes.STRING,
//     email: DataTypes.STRING,
       // aqui inserimos o datatype da coluna criada
       phoneNum: DataTypes.STRING,
//   });
// 
//   return User;
// };

// module.exports = User;

➡️ Pronto! Conseguimos criar uma migration para adição da coluna phoneNum na tabela Users. Desta maneira, se outra pessoa for alterar este projeto em outra máquina, ela pode executar as migrations e atualizar o banco de dados local com as modificações feitas por você!

# SEEDERS  = agora chegou o momento de aprender a popular nosso banco de dados utilizando o Seeders. Podemos configurar nosso banco para ser automaticamente criado e povoado.

* As seeds seguem a mesma linha das migrations, portanto primeiramente vamos precisar executar a criação de uma nova seed pelo CLI:

EX:

npx sequelize seed:generate --name users

Reparem que o arquivo foi criado dentro da pasta seeders com o mesmo formato do arquivo de uma migration. 

* Agora, devemos adicionar ao arquivo criado quais informações aquele seed vai gerar. O código abaixo vai adicionar dois usuários ao banco de dados:

EX:

// src/seeders/[timestamp]-users.js

'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => queryInterface.bulkInsert('Users',
    [
      {
        fullName: 'Leonardo',
        email: 'leo@test.com',
        // usamos a função CURRENT_TIMESTAMP do SQL para salvar a data e hora atual nos campos `createdAt` e `updatedAt`
        createdAt: Sequelize.literal('CURRENT_TIMESTAMP'),
        updatedAt: Sequelize.literal('CURRENT_TIMESTAMP'),
      },
      {
        fullName: 'JEduardo',
        email: 'edu@test.com',
        createdAt: Sequelize.literal('CURRENT_TIMESTAMP'),
        updatedAt: Sequelize.literal('CURRENT_TIMESTAMP'),
      },
    ], {}),

  down: async (queryInterface) => queryInterface.bulkDelete('Users', null, {}),
};

Na função acima, estamos utilizando o parâmetro recebido pela função queryInterface para conversar com o banco de dados. Dessa forma, conseguimos inserir os dados que queremos. Também estamos adicionando os dados, que estão na estrutura de uma array de objetos, na tabela users. O queryInterface tem a função bulkInsert, a qual estamos utilizando, que insere múltiplos dados na tabela.

Note que a seed segue o mesmo princípio de up e down, ou seja, devemos colocar também o que a seed deve fazer caso precise reverter a operação. Aqui, um código ruim pode quebrar o fluxo de uso/reversão dos seeds, então escreva com atenção!

* Para executar a seed, basta rodarmos o comando abaixo:

EX:

env $(cat .env) npx sequelize db:seed:all

* Para reverter o seed, use o seguinte comando:

EX:

env $(cat .env) npx sequelize db:seed:undo:all

# Implementando a listagem de pessoas usuárias

Caso precisemos buscar todas as pessoas usuárias, por exemplo, basta criarmos os diretórios e arquivos para nossos services e controllers e preenchê-los como no código abaixo:

EX: SERVICE

// src/services/user.service.js

const { User } = require('../models');

/* Esta função usa o método findAll do Sequelize para buscar todas as linhas da tabela Users
Equivale a fazer a query: SELECT * FROM Users */
const getAll = async () => {
  const users = await User.findAll();

  return users;
};

module.exports = {
  getAll,
};

EX: CONTROLLER

// src/controllers/user.controller.js

const UserService = require('../services/user.service');

const getAll = async (_req, res) => {
  try {
    const users = await UserService.getAll();
    return res.status(200).json(users);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: 'Ocorreu um erro' });
  }
};

module.exports = {
  getAll,
};

Note que não precisamos escrever uma query SQL para buscar os dados, pois o Sequelize abstrai isso para nós. Ele oculta essa complexidade e nos provê uma forma menos trabalhosa de escrever esse código.

Repare que estamos importando o modelo que criamos do arquivo index.js da pasta models, e não diretamente do arquivo user.models.js. Quando executamos o comando npx sequelize init, o arquivo index.js é gerado dentro da pasta models.

O código desse arquivo index.js é responsável por:

Realizar a conexão com o banco de dados, por meio do arquivo config.json ou config.js;
Coletar todos os modelos definidos dentro da pasta models e;
Caso necessário, associar um modelo a algum outro.

* Agora precisamos criar nossos arquivos app.js e server.js com os código logo abaixo dentro da pasta src. Teste e veja o comportamento de uma aplicação utilizando o Sequelize.

EX:

// src/app.js

const express = require('express');

const User = require('./controllers/user.controller');

const app = express();

app.use(express.json());

app.get('/user', User.getAll);

module.exports = app;

EX:

// src/server.js

const app = require('./app');

const PORT = process.env.PORT || 3001;

app.listen(PORT, () => {
  console.log(`Escutando na porta ${PORT}`);
});

* Antes de executar a aplicação, precisamos adicionar o Express e o nodemon como dependências da nossa aplicação:

EX:

npm install -E express@4.17
npm install -D -E nodemon@2.0.15

* Agora, altere a chave no package.json a chave main para que aponte para o arquivo server.js: e adicione o script dev para rodar sua aplicação.

EX:

//  {
//  ...
  "main": "src/server.js",
//  ...
  "scripts": {
    "dev": "nodemon src/server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
//  ...
//  }

Agora você pode executar o comando "env $(cat .env) npm run dev" e testar fazer uma requisição para URL http://localhost:3001/user. Como acabamos de criar o banco de dados e a tabela Users nas lições anteriores, a resposta da requisição será um array com duas pessoas usuárias, essas pessoas são as que foram inseridas graças ao Seeder que foi criado e executado anteriormente.

* Implementando os demais endpoints do CRUD de pessoas usuárias
O caso que mostramos acima foi para buscar todas as pessoas usuárias, mas conseguimos realizar todas as outras operações de consulta, inserção e deleção também:

EX: SERVICE

// src/services/user.service.js

// const { User } = require('../models/');

// const getAll = async () => {
//   const users = await User.findAll();

//   return users;
// };

/* Esta função usa o método findByPk do Sequelize para buscar um usuário pelo id.
Equivale a fazer a query: SELECT * FROM Users WHERE id=? */
const getById = async (id) => {
  const user = await User.findByPk(id);

  return user;
};

/* Esta função usa o método findOne do Sequelize combinado 
com a chave where para buscar por id e email. 
Equivale a fazer a query: SELECT * FROM Users WHERE id=? AND email=? */
const getByIdAndEmail = async (id, email) => {
  const user = await User.findOne({ where: { id, email } });

  return user;
};

/* Esta função usa o método create do Sequelize para inserir um objeto na tabela Users
Equivale a fazer a query: INSERT INTO Users (full_name, email) VALUES (?, ?) */
const createUser = async (fullName, email) => {
  const newUser = await User.create({ fullName, email });

  return newUser;
};

/* Esta função usa o método update do Sequelize para atualizar um objeto na tabela Users
Equivale a fazer a query: UPDATE Users SET full_name=?, email=? WHERE id=?*/
const updateUser = async (id, fullName, email) => {
  const [updatedUser] = await User.update(
    { fullName, email },
    { where: { id } },
  );

  console.log(updatedUser); // confira o que é retornado quando o user com o id é ou não encontrado;
  return updatedUser;
};

/* Esta função usa o método destroy do Sequelize para remover um objeto na tabela Users
Equivale a fazer a query: DELETE FROM Users WHERE id=?*/
const deleteUser = async (id) => {
  const user = await User.destroy(
    { where: { id } },
  );

  console.log(user); // confira o que é retornado quando o user com o id é ou não encontrado;
  return user;
};

module.exports = {
  getAll,
  getById,
  getByIdAndEmail,
  createUser,
  updateUser,
  deleteUser,
};

EX: CONTROLLER

// src/controllers/user.controller.js

// const UserService = require('../services/user.service');

const error500Message = 'Algo deu errado';

// const getAll = async (_req, res) => {
//   try {
//     const users = await UserService.getAll();
//     return res.status(200).json(users);
//   } catch (e) {
//     console.log(e.message);
//     res.status(500).json({ message: 'Ocorreu um erro' });
//   }
// };

const getById = async (req, res) => {
  try {
    const { id } = req.params;
    const user = await UserService.getById(id);

    if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });

    return res.status(200).json(user);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

const getByIdAndEmail = async (req, res) => {
  try {
    const { id } = req.params;
    const { email } = req.query;
    const user = await UserService.getByIdAndEmail(id, email);

    if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });

    return res.status(200).json(user);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

const createUser = async (req, res) => {
  try {
    const { fullName, email } = req.body;
    const newUser = await UserService.createUser(fullName, email);

    return res.status(201).json(newUser);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

const updateUser = async (req, res) => {
  try {
    const { fullName, email } = req.body;
    const { id } = req.params;
    const updatedUser = await UserService.updateUser(id, fullName, email);

    if (!updatedUser) return res.status(404).json({ message: 'Usuário não encontrado' });

    return res.status(200).json({ message: 'Usuário atualizado com sucesso!' });
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

const deleteUser = async (req, res) => {
  try {
    const { id } = req.params;
    await UserService.deleteUser(id);

    return res.status(200).json({ message: 'Usuário excluído com sucesso!' });
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: error500Message });
  }
};

module.exports = {
  getAll,
  getById,
  getByIdAndEmail,
  createUser,
  updateUser,
  deleteUser,
};

EX: APP

// src/app.js

// const express = require('express');

// const User = require('./controllers/user.controller');

// const app = express();

// app.use(express.json());

// app.get('/user', User.getAll);

// Este endpoint usa o método findByPk do Sequelize para buscar um usuário pelo id.
app.get('/user/:id', User.getById);

// Este endpoint usa o método findOne do Sequelize para buscar um usuário pelo id e email.
// URL a ser utilizada para o exemplo "http://localhost:3001/user/search/1?email=leo@test.com"
app.get('/user/search/:id', User.getByIdAndEmail);

// Este endpoint usa o método create do Sequelize para salvar um usuário no banco.
app.post('/user', User.createUser);

// Este endpoint usa o método update do Sequelize para alterar um usuário no banco.
app.put('/user/:id', User.updateUser);

// Este endpoint usa o método destroy do Sequelize para remover um usuário no banco.
app.delete('/user/:id', User.deleteUser);

// module.exports = app;

* Testes
Para testarmos os models criados com o Sequelize, seguiremos os mesmos conceitos vistos anteriormente: vamos isolar as operações de IO e utilizaremos bibliotecas específicas para nos ajudar com os stubs e asserções.

* Antes de começar a realizar os testes, vamos instalar nossas dependências de desenvolvimento como nas aulas anteriores:

EX:

npm i mocha@10.0.0 chai@4.3.4 sinon@14.0.0 chai-http@4.3.0 -D -E

* Agora vamos alterar a linha abaixo em nosso package.json para executar nossos testes com o comando npm test, como nas aulas anteriores:

EX:

// package.json

"scripts": {
  ...
  "test": "mocha tests/**/*$NAME*.test.js --exit"
},

* Para testar um model com Sequelize, podemos utilizar bibliotecas específicas para nos ajudar nessa tarefa. Uma bastante utilizada é a Sequelize Test Helpers. Vamos ver um exemplo de como podemos utilizá-la:

Use o comando abaixo para instalar a biblioteca Sequelize Test Helpers:

EX:

npm i sequelize-test-helpers@1.4.3 -D -E

* Crie o arquivo abaixo na raiz do projeto e depois rode npm test:

EX:

// tests/unit/models/user.test.js

const {
  sequelize,
  dataTypes,
  checkModelName,
  checkPropertyExists,
} = require('sequelize-test-helpers');

const UserModel = require('../../../src/models/user.model');

describe('O model de User', () => {
  const User = UserModel(sequelize, dataTypes);
  const user = new User();

  describe('possui o nome "User"', () => {
    checkModelName(User)('User');
  });

  describe('possui as propriedades "fullName" e "email"', () => {
    ['fullName', 'email'].forEach(checkPropertyExists(user));
  });
});

É possível fazer essas asserções diretamente, porém esse módulo já possui diversas funções prontas para facilitar a escrita dos testes.


# PRIMARY KEY, FOREIGN KEY E JOINS NO SEQUELIZE:(MODIFICANDO NO TESTE PROJETO "APP-WITH" DA PASTA COM A TABELA "employees").

# RELACIONAMENTO 1:1

* Agora vamos criar as migrations e para criar a migration que será responsável pela tabela Employees, basta utilizar o comando:

EX:

npx sequelize migration:generate --name create-employees

Lembre-se que todas as migrations e seeds, quando criadas pelos comandos do Sequelize, têm um timestamp antes do nome do arquivo, lembre-se disso ao procurá-las!

* Abra a migration e substitua o código existente pelo seguinte código:

EX:

// src/migrations/[timestamp]-create-employee.js

module.exports = {
  up: async (queryInterface, Sequelize) => {
    return queryInterface.createTable('employees', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      firstName: {
        allowNull: false,
        type: Sequelize.STRING,
        field: 'first_name',
      },
      lastName: {
        allowNull: false,
        type: Sequelize.STRING,
        field: 'last_name',
      },
      age: {
        allowNull: false,
        type: Sequelize.INTEGER,
      },
    });
  },

  down: async (queryInterface, _Sequelize) => {
    return queryInterface.dropTable('employees');
  },
};

* Agora vamos criar a migration responsável pela tabela Addresses utilizando o comando:

EX:

npx sequelize migration:generate --name create-addresses

* Abra a migration e substitua seu conteúdo presente pelo seguinte código:

EX:

// src/migrations/[timestamp]-create-addresses.js

module.exports = {
  up: async (queryInterface, Sequelize) => {
    return queryInterface.createTable('addresses', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      city: {
        allowNull: false,
        type: Sequelize.STRING,
      },
      street: {
        allowNull: false,
        type: Sequelize.STRING,
      },
      number: {
        allowNull: false,
        type: Sequelize.INTEGER,
      },
      employeeId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        // Configuram o que deve acontecer ao atualizar ou excluir um usuário
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
        field: 'employee_id',
        // Informa que o campo é uma Foreign Key (Chave estrangeira)
        references: {
          // Informa a tabela da referência da associação
          model: 'employees',
          // Informa a coluna da referência que é a chave correspondente
          key: 'id',
        },
      },
    });
  },

  down: async (queryInterface, _Sequelize) => {
    return queryInterface.dropTable('addresses');
  },
};

Repare que, agora, temos algumas informações novas sendo passadas para o Sequelize no momento de adicionar a coluna employeeId. Esses dados informam ao Sequelize que aquele campo deve ser uma _foreign key_. Vamos passar por cada um deles:

references.model: indica qual tabela nossa foreign key está referenciando.
references.key: indica qual coluna da tabela estrangeira deve ser utilizada para nossa foreign key.
onUpdate e onDelete: configura o que deve acontecer ao atualizar ou excluir um usuário. Nesse caso, todos os endereços daquele usuário serão alterados ou excluídos.
Essa migration cria uma foreign key na tabela addresses, que relaciona o campo employee_id dessa tabela ao campo id da tabela employees.

* Vamos executar o seguinte comando para gerar as migrations:

EX:

env $(cat .env) npx sequelize db:migrate

Ok, mas como criamos essa associação no sequelize? 🤔

Com as migrations criadas, vamos para os models criar essas associações!

* Dentro da pasta models, crie o arquivo employee.model.js, que conterá a seguinte estrutura:

EX:

// src/models/employee.model.js

module.exports = (sequelize, DataTypes) => {
  const Employee = sequelize.define('Employee', {
    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    firstName: DataTypes.STRING,
    lastName: DataTypes.STRING,
    age: DataTypes.INTEGER,
  },
  {
    timestamps: false, // remove a obrigatoriedade de utilizar os campos `createdAt` e `updatedAt`
    tableName: 'employees',
    underscored: true,
  });

  Employee.associate = (models) => {
    Employee.hasOne(models.Address,
      { foreignKey: 'employeeId', as: 'addresses' });
  };

  return Employee;
};

A função Employee.associate = (models) => {} que criamos é onde declararemos as associações daquele model. No nosso caso, estamos dizendo que a tabela Employees possui um Address, referenciado pela foreign key employee_id, o model Employee deve chamá-la de addresses (note a letra minúscula), como definido na propriedade as.

Essa função é chamada pelo arquivo src/models/index.js, criado pelo comando npx sequelize-cli init que você executou ao começar o exemplo.

Os métodos de criação de associações que o Sequelize disponibiliza são:

hasOne
belongsTo
hasMany
belongsToMany
No caso de relacionamentos 1:1, utilizamos os métodos hasOne e belongsTo. A tradução literal desses métodos facilita o seu entendimento.

hasOne = tem um belongsTo = pertencente a

* No model Address, por sua vez, temos que fazer o caminho inverso, declarando que o address pertence a Employee. Fazemos isso da seguinte forma:

EX:

// src/models/address.model.js

module.exports = (sequelize, DataTypes) => {
  const Address = sequelize.define('Address', {
    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    city: DataTypes.STRING,
    street: DataTypes.STRING,
    number: DataTypes.INTEGER,
    employeeId: { type: DataTypes.INTEGER, foreignKey: true },
    // A declaração da Foreign Key é opcional no model
  },
  {
    timestamps: false,
    tableName: 'addresses',
    underscored: true,
  });

  Address.associate = (models) => {
// define o tipo de relacionamento
    Address.belongsTo(models.Employee,
    // define qual a foreign key a ser criada
      { foreignKey: 'employeeId', as: 'employees' });
  };

  return Address;
};

👀 De olho na dica: 👀

Note que apesar do uso da Foreign Key ser opcional no model, é importante deixar explícito dentro da função associate qual o relacionamento será feito, e qual Foreign Key vai ser criada quando queremos criar uma Foreign Key.

* Validando relacionamentos 1:1
Agora, vamos validar o relacionamento. Para isso, precisaremos criar seeders para inserirmos dados nas tabelas e um servidor para responder as requisições.

Para criar os dois seeders, utilize os comandos abaixo:

EX:

npx sequelize seed:generate --name employees
npx sequelize seed:generate --name addresses

* Depois, abra o arquivo employees dentro da pasta seeders e copie o código a seguir:

EX:

// src/seeders/[timestamp]-employees.js

module.exports = {
  up: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkInsert('employees',
      [
        {
          first_name: 'Marcos',
          last_name: 'Zuck',
          age: 49,
        },
        {
          first_name: 'Fred',
          last_name: 'Mercúrio',
          age: 19,
        },
        {
          first_name: 'Ayrton',
          last_name: 'Keno',
          age: 51,
        },
        {
          first_name: 'Robin',
          last_name: 'Mathias',
          age: 63,
        },
      ],
      {},
    );
  },

  down: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkDelete('employees', null, {});
  },
};

* O arquivo addresses da pasta seeds deve conter o seguinte código:

EX:

// src/seeders/[timestamp]-addresses.js

module.exports = {
  up: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkInsert('addresses',
      [
        {
          city: 'Belo Horizonte',
          street: 'Rua Flórida',
          number: 1080,
          employee_id: 1,
        },
        {
          city: 'São Paulo',
          street: 'Avenida Paulista',
          number: 1980,
          employee_id: 2,
        },
        {
          city: 'Fortaleza',
          street: 'Rua das Enseadas',
          number: 95,
          employee_id: 3,
        },
        {
          city: 'Belo Horizonte',
          street: 'Rua Andaluzita',
          number: 131,
          employee_id: 4,
        },
        {
          city: 'Curitiba',
          street: 'Rua Fria',
          number: 101,
          employee_id: 4,
        },
      ],
      {},
    );
  },

  down: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkDelete('addresses', null, {});
  },
};

* Depois, utilize o comando abaixo para executar os seeders:

EX:

env $(cat .env) npx sequelize db:seed:all

Existe uma possibilidade de você se deparar com o erro “Cannot add or update a child row: a foreign key constraint fails”. Isso acontece porque precisamos que a seed de employees rode primeiro que a de addresses, de forma de que a segunda possa pegar a chave que usa como foreign key da primeira.

Contudo, como criamos as seeds juntas, as timestamps de ambas são iguais e elas acabam sendo executadas na ordem alfabética: primeiro addresses, depois employees, causando o erro. Para resolver isso de forma simples, basta renomear a seed de employees, tornando o número da timestamp menor que o de address e rodar o comando acima novamente.

* Por último, vamos criar o servidor para testarmos nossas associations. A grande diferença quando vamos fazer uma requisição que necessite da utilização de uma association com o Sequelize, é o campo include. Esse campo diz ao Sequelize quais serão as configurações da requisição. A propriedade model se refere a qual tabela será utilizada. Já a propriedade as deve ser igual à que declaramos no momento da criação da associação no respectivo model.

Para finalmente podermos rodar nossa aplicação precisamos de mais alguns arquivos. Por isso, dentro de src criaremos os diretórios Services e Controllers e os preencheremos da seguinte forma:

EX:

// src/services/employee.service.js

const { Address, Employee } = require('../models/');

const getAll = async () => {
  const users = await Employee.findAll({
    include: { model: Address, as: 'addresses' },
  });

  return users;
};

module.exports = { getAll };

EX:

// src/controllers/employee.controller.js

const EmployeeService = require('../services/employee.service');

const getAll = async (_req, res) => {
  try {
    const employees = await EmployeeService.getAll();
    return res.status(200).json(employees);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: 'Ocorreu um erro' });
  }
};

module.exports = {
  getAll,
};

* Agora, precisamos criar mais dois arquivos, dentro da pasta src, o app.js e o server.js. Seu preenchimento deve ficar assim:

EX:

// src/app.js

const express = require('express');

const employee = require('./controllers/employee.controller');

const app = express();

app.use(express.json());

app.get('/employees', employee.getAll);

module.exports = app;

EX:

// src/server.js

const app = require('./app');

const PORT = process.env.PORT || 3001;

app.listen(PORT, () => {
  console.log(`Escutando na porta ${PORT}`);
});
Por fim, vamos fazer algumas pequenas alterações no package.json: definir nosso arquivo principal e criar um script para rodar a aplicação com o nodemon.

EX:

// package.json
{
  // ...
  "main": "src/server.js",
  "scripts": {
    "dev": "nodemon src/server.js"
  },
  // ...
}

Agora, inicie o servidor com "env $(cat .env) npm run dev", faça uma requisição do tipo GET para o endpoint localhost:3001/employees e verifique a resposta, na qual em cada um dos empregados (employees), aparecerá o respectivo endereço (address).

esse é o relacionamento 1:1, agora vamos para o 1:N.

# RELACIONAMENTO 1:N, OU SEJ A 1 PARA MUITOS.

* No caso dos relacionamentos 1:N, não há grande diferença na maneira como criamos as associações. Caso cada employee possuísse vários address, bastaria declarar seu model da seguinte forma:

EX:

// src/models/employee.model.js

//  module.exports = (sequelize, DataTypes) => {
//  const Employee = sequelize.define('Employee', {
//  ...
//  });

//  Employee.associate = (models) => {
    Employee.hasMany(models.Address,
//      { foreignKey: 'employeeId', as: 'addresses' });
//  };

//  return Employee;
//  };

hasMany: tem muitos

Mudamos apenas o método de declaração da associação para hasMany, indicando que cada employee pode possuir muitos addresses. Faça uma nova requisição para o endpoint localhost:3000/employees e observe o id 4 no resultado e veja a diferença que ocorre quando é usado hasOne e/ou hasMany.

No model addresses, por sua vez, não há necessidade de alterarmos nada, pois cada address continua pertencendo a apenas um employee, o que justifica o uso do método belongsTo.

* para funcionar primeiro tem que dropar a tabela (cuidado com os dados, se tiver tudo nos seed pode ir tranquilo como é o caso desse exemplo), criar ela novamente, depois coloca as migrations e depois as seeds.

EX:

env $(cat .env) npx sequelize db:drop

env $(cat .env) npx sequelize db:create

env $(cat .env) npx sequelize db:migrate

env $(cat .env) npx sequelize db:seed:all

* Agora, veremos os dois métodos de utilização dos relacionamentos:

Eager loading, ou carregamento antecipado;
Lazy loading, ou carregamento tardio.

Nesse caso, vamos aprender a utilizar cada um desses dois modos e como eles acontecem no código, usando o relacionamento 1:N visto há pouco.

* Eager loading

* Esse método carrega todos os dados na mesma request. Logo, ao utilizar eager loading, todas as informações são trazidas, independente se vamos usá-las ou não. Este modo é útil para cenários em que sabemos, já de antemão, que sempre vamos precisar de todos os dados das entidades envolvidas.

Antes de prosseguirmos, vamos alterar o schema do banco de dados para que as tabelas tenham uma relação 1:N. Para isso, utilizaremos os seeders já criados.

* Abra o arquivo [timestamp]-employees.js dentro da pasta seeders, apague tudo que havíamos colocado antes e copie o código abaixo:

EX:

// src/seeders/[timestamp]-employees.js

module.exports = {
  up: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkInsert('employees',
      [
        { first_name: 'Marcos', last_name: 'Zuck', age: 49 },
        { first_name: 'Fred', last_name: 'Mercurio', age: 19 },
        { first_name: 'Ayrton', last_name: 'Keno', age: 51 },
        { first_name: 'Robin', last_name: 'Mathias', age: 63 },
        { first_name: 'Antonio', last_name: 'Augusto', age: 18 },
      ],
      {},
    );
  },

  down: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkDelete('employees', null, {});
  },
};

* Depois, abra o arquivo [timestamp]-addresses.js dentro da pasta seeders, limpe-o e copie o código abaixo:

EX:

// src/seeders/[timestamp]-addresses.js

module.exports = {
  up: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkInsert('addresses',
      [
        {
          city: 'Belo Horizonte',
          street: 'Rua Florida',
          number: 1080,
          employee_id: 1,
        },
        {
          city: 'São Paulo',
          street: 'Avenida Paulista',
          number: 1980,
          employee_id: 2,
        },
        {
          city: 'Fortaleza',
          street: 'Rua das Enseadas',
          number: 95,
          employee_id: 3,
        },
        {
          city: 'Belo Horizonte',
          street: 'Rua Andaluzita',
          number: 131,
          employee_id: 4,
        },
        {
          city: 'Belo Horizonte',
          street: 'Rua Vicente Alvarenga',
          number: 80,
          employee_id: 1,
        },
        {
          city: 'Curitiba',
          street: 'Rua Fria',
          number: 101,
          employee_id: 5,
        },
      ],
      {},
    );
  },

  down: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkDelete('addresses', null, {});
  },
};

* Finalmente, utilize o comando abaixo para remover as tabelas antigas, depois recriá-las e, por último, executar os seeders:

EX:

env $(cat .env) npx sequelize db:migrate:undo:all
env $(cat .env) npx sequelize db:migrate
env $(cat .env) npx sequelize db:seed:all

* Agora, vamos ver como utilizar o Eager loading na prática. Vamos voltar ao arquivo src/app.js e criar mais uma rota:

EX:

// src/app.js

// const express = require('express');
// const employee = require('./controllers/employee.controller');

// const app = express();

// app.use(express.json());

app.get('/employees/:id', employee.getById);
// app.get('/employees', employee.getAll);

// module.exports = app;

* Com a nova rota já adicionada, vamos voltar ao arquivo src/controllers/employee.controller.js e adicionar o método getById:

EX:

// src/controllers/employee.controller.js

// const EmployeeService = require('../services/employee.service');

// const getAll = async (_req, res) => {
//   ...
// };

const getById = async (req, res) => {
  try {
    const { id } = req.params;
    const employee = await EmployeeService.getById(id);

    if (!employee) {
      return res.status(404).json({ message: 'Pessoa colaboradora não encontrada' });
    }

    return res.status(200).json(employee);
  } catch (e) {
    console.log(e);
    res.status(500).json({ message: 'Ocorreu um erro' });
  };
}

// module.exports = {
//   getAll,
  getById
// };

* Por fim, criaremos o método getById, agora no arquivo src/services/employee.service.js

EX:

// src/services/employee.service.js

// const { Address, Employee } = require('../models/');

// const getAll = async () => {
//   ...
// };

const getById = async (id) => {
  const employee = await Employee.findOne({
      where: { id },
      include: [{ model: Address, as: 'addresses' }],
    });
  return employee;
}

// module.exports = {
//   getAll,
  getById
// };

Agora, faça uma requisição do tipo GET para o endpoint http://localhost:3001/employees/1 e veja como o resultado é retornado.

* Além das propriedades que já citamos, o campo include pode manipular os dados que serão retornados. Por exemplo, se não quisermos o acesso ao número do endereço, bastaria alterar o código, adicionando a propriedade attributes e dentro dela o que queremos fazer:

EX:

// src/services/employee.service.js

// ...

// const getAll = async () => {
//   ...
// };

// const getById = async (id) => {
//   const employee = await Employee.findOne({
//       where: { id },
       include: [{
         model: Address, as: 'addresses', attributes: { exclude: ['number'] },
       }],
//   });
//   return employee;
// }

// ...

Dessa maneira, o campo number será excluído do retorno da requisição.

* lazy loading

Agora vamos ver como funciona a outra forma de carregar dados de associações: o lazy loading. Esse método consiste, basicamente, em não especificar uma propriedade includes no momento de realizar a query no banco. Dessa forma, cria-se a possibilidade de termos dois usos para o mesmo endpoint.

Para utilizarmos duas ações diferentes em um endpoint, usaremos a query string includeAddresses, na qual, caso o parâmetro dela seja true, os endereços daquele funcionário também serão retornados.

* Antes, vamos voltar a função getById de employee como estava anteriormente:

EX:

// src/services/employee.service.js

// ...

const getById = async (id) => {
  const employee = await Employee.findOne({
    where: { id },
  });
  return employee;
}

// ...

* Agora, vamos criar uma função getAllByEmployeeId para address que tem como responsabilidade buscar todos os endereços de acordo com o employee_id:

Precisaremos criar o arquivo address.service.js, que terá o seguinte código:

EX:

// src/services/address.service.js

const { Address } = require('../models/');

const getAllByEmployeeId = async (employeeId) => {
  const addresses = await Address.findAll({ where: { employeeId } });

  return addresses;
};

module.exports = {
  getAllByEmployeeId,
}

Por fim, importamos o service que acabamos de criar para que possamos usá-lo no Controller:

EX:

// src/controllers/employee.controller.js

const AddressService = require('../services/address.service');

//  ...

const getById = async (req, res) => {
//   try {
//     const { id } = req.params;
//     const employee = await EmployeeService.getById(id);

//     if (!employee) {
//       return res.status(404).json({ message: 'Pessoa colaboradora não encontrada' });
//     }

    if (req.query.includeAddresses === 'true') {
      const addresses = await AddressService.getAllByEmployeeId(id);
      return res.status(200).json({ employee, addresses });
    }

//     return res.status(200).json(employee);
//   } catch (e) {
//     console.log(e);
//     res.status(500).json({ message: 'Ocorreu um erro' });
//   };
// }

// ...

Reinicie a aplicação e realize uma requisição do tipo GET para o endpoint http://localhost:3001/employees/1?includeAddresses=true. Depois, altere para ?includeAddresses=false ou retire o ?includeAddresses=true e veja seu retorno.

Como presenciamos, o lazy loading é muito útil em situações em que não sabemos se vamos, de fato, precisar buscar todas as informações de uma só vez. Aqui, se tivéssemos utilizado o eager loading, teríamos buscado os dados das pessoas colaboradoras mesmo quando includeAddresses não era informado, e precisaríamos excluir a chave addresses do resultado do banco. Com o lazy loading, podemos carregar apenas os dados do funcionário e dos endereços apenas quando necessário, economizando recursos do banco.





















