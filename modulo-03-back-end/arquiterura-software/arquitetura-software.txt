# ARQUITERURA DE SOFTWARE  = Precisamos, em suma, criar padr√µes de organiza√ß√£o para nossa aplica√ß√£o. Em Ci√™ncia da Computa√ß√£o, chamamos isso de Arquitetura de Software. √â um campo de estudo rico em an√°lises e experimentos com diferentes organiza√ß√µes de aplica√ß√£o. Em Desenvolvimento Web, um modelo se destaca em popularidade e reconhecida efic√°cia, e iremos estud√°-lo nesta se√ß√£o.

# Iremos nos aprofundar em cada camada no momento oportuno. Por enquanto, segue uma resumo das responsabilidades de cada uma das camadas:

* Model: agrupa as fun√ß√µes que lidam com a leitura ou escrita de dados. Essa camada deve ser a √∫nica a ter acesso direto a ferramentas de armazenamento de dados, que podem ser desde um SGBD (MySQL, Postgres, etc.), sistema de arquivos (arquivos .csv, .json) ou mesmo outras APIs RESTful.

* Service: agrupa as fun√ß√µes que definem as regras de neg√≥cio da aplica√ß√£o. Para entender o que √© uma regra de neg√≥cio, imagine uma aplica√ß√£o que gerencia o almoxarifado de uma empresa. Cada vez que algu√©m solicita algum item do almoxarifado, √© feito uma checagem para saber se a quantidade atual deste item est√° abaixo de uma quantidade m√≠nima pr√©-determinada, e caso esteja, deve ser enviado um e-mail para o setor de compras solicitando uma reposi√ß√£o no estoque. A camada Service deve conter fun√ß√µes que s√£o geradas ao transcrever fluxos como deste exemplo em forma de c√≥digo.

* Controller: agrupa as fun√ß√µes que determinam como uma aplica√ß√£o interage com o mundo exterior, ou seja, com quem a usa - um cliente, que pode ser ruma requisi√ß√£o feita de aplica√ß√£o Front-end ou uma outra API. No contexto de uma API RESTful, as fun√ß√µes presentes nessa camada lidam com requisi√ß√µes HTTP e devem devolver uma resposta. Para isso, essa camada valida o formato dos dados recebidos e interage com as demais camadas para aplicar alguma regra de neg√≥cio ou acessar dados.

# CAMADA MODEL  = a camada de Model √© a respons√°vel por obter os dados da base e oferec√™-los de forma simples para o restante da aplica√ß√£o, respons√°vel por leitura, escrita e modelagem de dados.

* primeiro vamos criar dentro da pasta "src" a pasta "models" e dentro dessa pasta vai conter o arquivo "connection.js" que faz a liga√ß√£o com o banco de dados e os arquivos que cont√©m as fun√ß√µes que faz requisi√ß√µes ao banco de dados seguindo a nomeclatura "nomeDaTabela.model.js", cada tabela vai ter seu arquivo model.

* arquivo "connection.js" que fica dentro da pasta src/models.

EX:

const mysql = require('mysql2/promise');

const connection = mysql.createPool({
  host: process.env.MYSQL_HOST || 'localhost',
  port: process.env.MYSQL_PORT || 33060,
  user: process.env.MYSQL_USER || 'root',
  password: process.env.MYSQL_PASSWORD || 'password',
  database: 'trybecardb',
});

module.exports = connection;

* arquivo "nomeDaTabela.model.js" que fica dentro da pasta src/models.

EX:

const camelize = require('camelize');
const connection = require('./connection');

const findAll = async () => {
  const [passengers] = await connection.execute('SELECT * FROM passengers');
  return camelize(passengers);
};

const findById = async (passengerId) => {
  const [[passenger]] = await connection
    .execute('SELECT * FROM passengers WHERE id = ?', [passengerId]);
  return camelize(passenger);
};

module.exports = { findAll, findById };

* arquivo de rota que fica na pasta "routes", como ele chama a fun√ß√£o que est√° no arquivo "nomeDaTabela.model.js" para dar a resposta do express.

EX:

const express = require('express');
const passengerModel = require('../models/passenger.model');

const router = express.Router();
router.use(express.json());

router.get('/', async (req, res) => {
  const passengers = await passengerModel.findAll();
  if (!passengers) return res.status(404).json({ message: 'Passengers not found' });
  res.status(200).json(passengers);
});

router.get('/:id', async (req, res) => {
  const { id } = req.params;
  const passenger = await passengerModel.findById(Number(id));
  if (!passenger) return res.status(404).json({ message: 'Passenger not found' });
  res.status(200).json(passenger);
});

module.exports = router;

* camelize  = biblioteca que converte as palvras de snake case(actor_id) para camel case(actorId).

EX:

const camelize = require('camelize');

const a = 'actor_id'
camelize(a)  = 'actorId'

* na hora que for exportar uma fun√ß√£o de um arquivo model pega s√≥ o arquivo e coloca a fun√ß√£o depois.

EX:

const express = require('express');
const passengerModel = require('../models/passenger.model');

const router = express.Router();
router.use(express.json());

router.get('/', async (req, res) => {
  const passengers = await passengerModel.findAll();  = aqui deixa o nome para ter uma refer√™ncia.
  if (!passengers) return res.status(404).json({ message: 'Passengers not found' });
  res.status(200).json(passengers);
});

* arquivo "docker-compose.yml".

EX:

version: '3'

services:
  # Servi√ßo que ir√° rodar o node
  node:
    image: node:16.14
    container_name: trybecar
    # Mesmo que `docker run -t`
    tty: true
    # Mesmo que `docker run -i`
    stdin_open: true
    command: bash
    restart: always
    working_dir: /home/node/app
    volumes:
      - ./:/home/node/app
    depends_on:
      - database
    ports:
      # Exp√µe a porta padr√£o da aplica√ß√£o: altere aqui caso use outra porta
      - 3001:3001
    environment:
      MYSQL_USER: root
      MYSQL_PASSWORD: password
      MYSQL_PORT: 3306
      MYSQL_HOST: database # Nome do service que ser√° utilizado para o banco de dados
      PORT: 3001

# node: [...]

# Servi√ßo que ir√° rodar o banco de dados
  database:
    image: mysql:8.0.29
    container_name: trybecar_db
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: trybecardb
    ports:
      - 33060:3306
    volumes:
      - ./:/docker-entrypoint-initdb.d
      
# REFATORAR UMA APLICA√á√ÉO PARA A CAMADA MODEL E TESTES.

* Primeira etapa: Identificar queries SQL que fazem parte das rotas;
* Segunda etapa: Criar nossa camada model, com diret√≥rios, arquivos e suas respectivas fun√ß√µes;
* Terceira etapa: Construir testes de unidade para verificar se o comportamento das funcionalidades criadas, se mantiveram!;
* Quarta etapa: Atualizar o arquivo src/app.js, refletindo nossa modulariza√ß√£o.

* exemplos de fun√ß√µes que ajudam a tornar c√≥digos SQL mais flex√≠veis sem ficar mudando direto caso adicione mais colunas.(fica na pasta "src/utils")

EX:

const snakeize = require('snakeize');

const getFormattedColumnNames = (object) => Object.keys(snakeize(object)).join(',');  = faz com que pegue todas as chaves do objeto em formato de snakeize(pedro_roberto) e entre cada um deles adicionar uma v√≠rgula.

const getFormattedPlaceholders = (object) => Object.keys(object).map(() => '?').join(',');  = faz com que em cada chave que tenha coloque uma interroga√ß√£o no lugar e depois uma v√≠rgula.

module.exports = {
  getFormattedColumnNames,
  getFormattedPlaceholders,
};

* criar um arquivo "index.js" dentro do "src/models" e nele colocar os models j√° com os nomes, pois quando for chamar a fun√ß√£o j√° vem modificada.

EX:

const passengerModel = require('./passenger.model');
const travelModel = require('./travel.model');

module.exports = {
  passengerModel,
  travelModel,
};

* mocks. "tests/unit/mocks/nomeArquivo.mock.js"

EX:

const travelFromDB = {
  id: 42,
  driver_id: null,
  starting_address: 'starting street',
  ending_address: 'end street',
  request_date: '2023-05-29T19:56:25.000Z',
  travel_status_id: 1,
  status: 'Aguardando Motorista',
  address: null,
  stop_order: null,
};

const travelFromModel = {
  id: 42,
  driverId: null,
  startingAddress: 'starting street',
  endingAddress: 'end street',
  requestDate: '2023-05-29T19:56:25.000Z',
  travelStatusId: 1,
  status: 'Aguardando Motorista',
  waypoints: [],
};

const travelWithWaypointsFromDB = [
  {
    id: 1,
    driver_id: null,
    starting_address: 'Rua dos caramelos',
    ending_address: 'Rua Mariana Alvarez Dutra',
    request_date: '2023-05-29T19:56:52.000Z',
    travel_status_id: 1,
    status: 'Aguardando Motorista',
    address: 'Rua Quatro de Mar√ßo',
    stop_order: 1,
  },
  {
    id: 1,
    driver_id: null,
    starting_address: 'Rua dos caramelos',
    ending_address: 'Rua Mariana Alvarez Dutra',
    request_date: '2023-05-29T19:56:52.000Z',
    travel_status_id: 1,
    status: 'Aguardando Motorista',
    address: 'Rua Sete de Setembro',
    stop_order: 2,
  },
];

const travelWithWaypointsFromModel = {
  id: 1,
  driverId: null,
  startingAddress: 'Rua dos caramelos',
  endingAddress: 'Rua Mariana Alvarez Dutra',
  requestDate: '2023-05-29T19:56:52.000Z',
  travelStatusId: 1,
  status: 'Aguardando Motorista',
  waypoints: [
    { address: 'Rua Quatro de Mar√ßo', stopOrder: 1 },
    { address: 'Rua Sete de Setembro', stopOrder: 2 },
  ],
};

O travelFromDB, simula o retorno do banco de dados e o travelFromModel, simula o retorno do banco de dados depois de passar na fun√ß√£o camelize(). Ambos s√£o diferentes e nosso c√≥digo refatorado trata tudo isso üëç Abaixo vamos escrever o teste de unidade que utiliza esses mocks!

* teste unit√°rio. "tests/unit/models/nomeArquivo.model.test.js"

EX:

const { expect } = require('chai');
const sinon = require('sinon');
const connection = require('../../../src/models/connection');
const { travelModel } = require('../../../src/models');
const {
  travelFromDB,
  travelFromModel,
  travelWithWaypointsFromDB,
  travelWithWaypointsFromModel,
} = require('../mocks/travel.mock');

describe('Realizando testes - TRAVEL MODEL:', function () {
  it('Recuperando travel por id sem waypoints com sucesso', async function () {
    sinon.stub(connection, 'execute').resolves([[travelFromDB]]);

    const inputData = 42;
    const travel = await travelModel.findById(inputData);

    expect(travel).to.be.an('object');
    expect(travel).to.be.deep.equal(travelFromModel);
  });

  it('Recuperando travel por id com waypoints com sucesso', async function () {
    sinon.stub(connection, 'execute').resolves([travelWithWaypointsFromDB]);

    const inputData = 1;
    const travel = await travelModel.findById(inputData);

    expect(travel).to.be.an('object');
    expect(travel).to.be.deep.equal(travelWithWaypointsFromModel);
  });

  afterEach(function () {
    sinon.restore();
  });
});

* cobertura de teste.

EX:

npm install -D -E nyc@15.1.0

"scripts": {
    "test:coverage": "nyc --all --include src/models --include src/services --include src/controllers mocha tests/unit/**/*.js --exit"
  },
  
npm run test:coverage

A tabela traz as porcentagem de c√≥digo do programa que foi executado ao rodar os testes. para cada coluna temos:

File: nome do arquivo do projeto.
Stmts: instru√ß√µes do c√≥digo.
Branch: estruturas de controle (por exemplo: ramifica√ß√µes de uma estrutura if/else).
Funcs: fun√ß√µes, m√©todos ou sub-rotinas.
Lines: linha do arquivo.
As informa√ß√µes mais importantes que conseguimos tirar dessa tabela s√£o:

Na coluna % Stmts temos a informa√ß√£o da porcentagem de instru√ß√µes, do respectivo arquivo, que foram cobertos pelo teste.
De olho na dica üëÄ: este valor √© utilizado pelo avaliador para definir se um requisito do projeto foi aprovado ou n√£o.

Na coluna % Lines (porcentagem de linhas de c√≥digo) da linha All files(todos os arquivos) temos a informa√ß√£o do total de n√∫mero de linhas da nossa aplica√ß√£o que nossos testes est√£o cobrindo, nesse caso 76,19%
Na coluna Uncovered Line #s (n√∫mero das linhas de c√≥digos que n√£o est√£o cobertas) da linha passenger.model.js temos a informa√ß√£o de exatamente quais s√£o as linhas de c√≥digo do arquivo passenger.model.js que ainda n√£o est√£o cobertas, nesse caso o intervalo come√ßando na linha 21 e indo at√© a linha 32 representado por 21-32







