# ARQUITERURA DE SOFTWARE  = Precisamos, em suma, criar padrÃµes de organizaÃ§Ã£o para nossa aplicaÃ§Ã£o. Em CiÃªncia da ComputaÃ§Ã£o, chamamos isso de Arquitetura de Software. Ã‰ um campo de estudo rico em anÃ¡lises e experimentos com diferentes organizaÃ§Ãµes de aplicaÃ§Ã£o. Em Desenvolvimento Web, um modelo se destaca em popularidade e reconhecida eficÃ¡cia, e iremos estudÃ¡-lo nesta seÃ§Ã£o.

# Iremos nos aprofundar em cada camada no momento oportuno. Por enquanto, segue uma resumo das responsabilidades de cada uma das camadas:

* Model: agrupa as funÃ§Ãµes que lidam com a leitura ou escrita de dados. Essa camada deve ser a Ãºnica a ter acesso direto a ferramentas de armazenamento de dados, que podem ser desde um SGBD (MySQL, Postgres, etc.), sistema de arquivos (arquivos .csv, .json) ou mesmo outras APIs RESTful.

* Service: agrupa as funÃ§Ãµes que definem as regras de negÃ³cio da aplicaÃ§Ã£o. Para entender o que Ã© uma regra de negÃ³cio, imagine uma aplicaÃ§Ã£o que gerencia o almoxarifado de uma empresa. Cada vez que alguÃ©m solicita algum item do almoxarifado, Ã© feito uma checagem para saber se a quantidade atual deste item estÃ¡ abaixo de uma quantidade mÃ­nima prÃ©-determinada, e caso esteja, deve ser enviado um e-mail para o setor de compras solicitando uma reposiÃ§Ã£o no estoque. A camada Service deve conter funÃ§Ãµes que sÃ£o geradas ao transcrever fluxos como deste exemplo em forma de cÃ³digo.

* Controller: agrupa as funÃ§Ãµes que determinam como uma aplicaÃ§Ã£o interage com o mundo exterior, ou seja, com quem a usa - um cliente, que pode ser ruma requisiÃ§Ã£o feita de aplicaÃ§Ã£o Front-end ou uma outra API. No contexto de uma API RESTful, as funÃ§Ãµes presentes nessa camada lidam com requisiÃ§Ãµes HTTP e devem devolver uma resposta. Para isso, essa camada valida o formato dos dados recebidos e interage com as demais camadas para aplicar alguma regra de negÃ³cio ou acessar dados.

# CAMADA MODEL  = a camada de Model Ã© a responsÃ¡vel por obter os dados da base e oferecÃª-los de forma simples para o restante da aplicaÃ§Ã£o, responsÃ¡vel por leitura, escrita e modelagem de dados.

* primeiro vamos criar dentro da pasta "src" a pasta "models" e dentro dessa pasta vai conter o arquivo "connection.js" que faz a ligaÃ§Ã£o com o banco de dados e os arquivos que contÃ©m as funÃ§Ãµes que faz requisiÃ§Ãµes ao banco de dados seguindo a nomeclatura "nomeDaTabela.model.js", cada tabela vai ter seu arquivo model.

* arquivo "connection.js" que fica dentro da pasta src/models.

EX:

const mysql = require('mysql2/promise');

const connection = mysql.createPool({
  host: process.env.MYSQL_HOST || 'localhost',
  port: process.env.MYSQL_PORT || 33060,
  user: process.env.MYSQL_USER || 'root',
  password: process.env.MYSQL_PASSWORD || 'password',
  database: 'trybecardb',
});

module.exports = connection;

* arquivo "nomeDaTabela.model.js" que fica dentro da pasta src/models.

EX:

const camelize = require('camelize');
const connection = require('./connection');

const findAll = async () => {
  const [passengers] = await connection.execute('SELECT * FROM passengers');
  return camelize(passengers);
};

const findById = async (passengerId) => {
  const [[passenger]] = await connection
    .execute('SELECT * FROM passengers WHERE id = ?', [passengerId]);
  return camelize(passenger);
};

module.exports = { findAll, findById };

* arquivo de rota que fica na pasta "routes", como ele chama a funÃ§Ã£o que estÃ¡ no arquivo "nomeDaTabela.model.js" para dar a resposta do express.

EX:

const express = require('express');
const passengerModel = require('../models/passenger.model');

const router = express.Router();
router.use(express.json());

router.get('/', async (req, res) => {
  const passengers = await passengerModel.findAll();
  if (!passengers) return res.status(404).json({ message: 'Passengers not found' });
  res.status(200).json(passengers);
});

router.get('/:id', async (req, res) => {
  const { id } = req.params;
  const passenger = await passengerModel.findById(Number(id));
  if (!passenger) return res.status(404).json({ message: 'Passenger not found' });
  res.status(200).json(passenger);
});

module.exports = router;

* camelize  = biblioteca que converte as palvras de snake case(actor_id) para camel case(actorId).

EX:

const camelize = require('camelize');

const a = 'actor_id'
camelize(a)  = 'actorId'

* na hora que for exportar uma funÃ§Ã£o de um arquivo model pega sÃ³ o arquivo e coloca a funÃ§Ã£o depois.

EX:

const express = require('express');
const passengerModel = require('../models/passenger.model');

const router = express.Router();
router.use(express.json());

router.get('/', async (req, res) => {
  const passengers = await passengerModel.findAll();  = aqui deixa o nome para ter uma referÃªncia.
  if (!passengers) return res.status(404).json({ message: 'Passengers not found' });
  res.status(200).json(passengers);
});

* arquivo "docker-compose.yml".

EX:

version: '3'

services:
  # ServiÃ§o que irÃ¡ rodar o node
  node:
    image: node:16.14
    container_name: trybecar
    # Mesmo que `docker run -t`
    tty: true
    # Mesmo que `docker run -i`
    stdin_open: true
    command: bash
    restart: always
    working_dir: /home/node/app
    volumes:
      - ./:/home/node/app
    depends_on:
      - database
    ports:
      # ExpÃµe a porta padrÃ£o da aplicaÃ§Ã£o: altere aqui caso use outra porta
      - 3001:3001
    environment:
      MYSQL_USER: root
      MYSQL_PASSWORD: password
      MYSQL_PORT: 3306
      MYSQL_HOST: database # Nome do service que serÃ¡ utilizado para o banco de dados
      PORT: 3001

# node: [...]

# ServiÃ§o que irÃ¡ rodar o banco de dados
  database:
    image: mysql:8.0.29
    container_name: trybecar_db
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: trybecardb
    ports:
      - 33060:3306
    volumes:
      - ./:/docker-entrypoint-initdb.d
      
# REFATORAR UMA APLICAÃ‡ÃƒO PARA A CAMADA MODEL E TESTES.

* Primeira etapa: Identificar queries SQL que fazem parte das rotas;
* Segunda etapa: Criar nossa camada model, com diretÃ³rios, arquivos e suas respectivas funÃ§Ãµes;
* Terceira etapa: Construir testes de unidade para verificar se o comportamento das funcionalidades criadas, se mantiveram!;
* Quarta etapa: Atualizar o arquivo src/app.js, refletindo nossa modularizaÃ§Ã£o.

* exemplos de funÃ§Ãµes que ajudam a tornar cÃ³digos SQL mais flexÃ­veis sem ficar mudando direto caso adicione mais colunas.(fica na pasta "src/utils")

EX:

const snakeize = require('snakeize');

const getFormattedColumnNames = (object) => Object.keys(snakeize(object)).join(',');  = faz com que pegue todas as chaves do objeto em formato de snakeize(pedro_roberto) e entre cada um deles adicionar uma vÃ­rgula.

const getFormattedPlaceholders = (object) => Object.keys(object).map(() => '?').join(',');  = faz com que em cada chave que tenha coloque uma interrogaÃ§Ã£o no lugar e depois uma vÃ­rgula.

module.exports = {
  getFormattedColumnNames,
  getFormattedPlaceholders,
};

* criar um arquivo "index.js" dentro do "src/models" e nele colocar os models jÃ¡ com os nomes, pois quando for chamar a funÃ§Ã£o jÃ¡ vem modificada.

EX:

const passengerModel = require('./passenger.model');
const travelModel = require('./travel.model');

module.exports = {
  passengerModel,
  travelModel,
};

* mocks. "tests/unit/mocks/nomeArquivo.mock.js"

EX:

const travelFromDB = {
  id: 42,
  driver_id: null,
  starting_address: 'starting street',
  ending_address: 'end street',
  request_date: '2023-05-29T19:56:25.000Z',
  travel_status_id: 1,
  status: 'Aguardando Motorista',
  address: null,
  stop_order: null,
};

const travelFromModel = {
  id: 42,
  driverId: null,
  startingAddress: 'starting street',
  endingAddress: 'end street',
  requestDate: '2023-05-29T19:56:25.000Z',
  travelStatusId: 1,
  status: 'Aguardando Motorista',
  waypoints: [],
};

const travelWithWaypointsFromDB = [
  {
    id: 1,
    driver_id: null,
    starting_address: 'Rua dos caramelos',
    ending_address: 'Rua Mariana Alvarez Dutra',
    request_date: '2023-05-29T19:56:52.000Z',
    travel_status_id: 1,
    status: 'Aguardando Motorista',
    address: 'Rua Quatro de MarÃ§o',
    stop_order: 1,
  },
  {
    id: 1,
    driver_id: null,
    starting_address: 'Rua dos caramelos',
    ending_address: 'Rua Mariana Alvarez Dutra',
    request_date: '2023-05-29T19:56:52.000Z',
    travel_status_id: 1,
    status: 'Aguardando Motorista',
    address: 'Rua Sete de Setembro',
    stop_order: 2,
  },
];

const travelWithWaypointsFromModel = {
  id: 1,
  driverId: null,
  startingAddress: 'Rua dos caramelos',
  endingAddress: 'Rua Mariana Alvarez Dutra',
  requestDate: '2023-05-29T19:56:52.000Z',
  travelStatusId: 1,
  status: 'Aguardando Motorista',
  waypoints: [
    { address: 'Rua Quatro de MarÃ§o', stopOrder: 1 },
    { address: 'Rua Sete de Setembro', stopOrder: 2 },
  ],
};

O travelFromDB, simula o retorno do banco de dados e o travelFromModel, simula o retorno do banco de dados depois de passar na funÃ§Ã£o camelize(). Ambos sÃ£o diferentes e nosso cÃ³digo refatorado trata tudo isso ðŸ‘ Abaixo vamos escrever o teste de unidade que utiliza esses mocks!

* teste unitÃ¡rio. "tests/unit/models/nomeArquivo.model.test.js"

EX:

const { expect } = require('chai');
const sinon = require('sinon');
const connection = require('../../../src/models/connection');
const { travelModel } = require('../../../src/models');
const {
  travelFromDB,
  travelFromModel,
  travelWithWaypointsFromDB,
  travelWithWaypointsFromModel,
} = require('../mocks/travel.mock');

describe('Realizando testes - TRAVEL MODEL:', function () {
  it('Recuperando travel por id sem waypoints com sucesso', async function () {
    sinon.stub(connection, 'execute').resolves([[travelFromDB]]);

    const inputData = 42;
    const travel = await travelModel.findById(inputData);

    expect(travel).to.be.an('object');
    expect(travel).to.be.deep.equal(travelFromModel);
  });

  it('Recuperando travel por id com waypoints com sucesso', async function () {
    sinon.stub(connection, 'execute').resolves([travelWithWaypointsFromDB]);

    const inputData = 1;
    const travel = await travelModel.findById(inputData);

    expect(travel).to.be.an('object');
    expect(travel).to.be.deep.equal(travelWithWaypointsFromModel);
  });

  afterEach(function () {
    sinon.restore();
  });
});

* cobertura de teste.

EX:

npm install -D -E nyc@15.1.0

"scripts": {
    "test:coverage": "nyc --all --include src/models --include src/services --include src/controllers mocha tests/unit/**/*.js --exit"
  },
  
npm run test:coverage

A tabela traz as porcentagem de cÃ³digo do programa que foi executado ao rodar os testes. para cada coluna temos:

File: nome do arquivo do projeto.
Stmts: instruÃ§Ãµes do cÃ³digo.
Branch: estruturas de controle (por exemplo: ramificaÃ§Ãµes de uma estrutura if/else).
Funcs: funÃ§Ãµes, mÃ©todos ou sub-rotinas.
Lines: linha do arquivo.
As informaÃ§Ãµes mais importantes que conseguimos tirar dessa tabela sÃ£o:

Na coluna % Stmts temos a informaÃ§Ã£o da porcentagem de instruÃ§Ãµes, do respectivo arquivo, que foram cobertos pelo teste.
De olho na dica ðŸ‘€: este valor Ã© utilizado pelo avaliador para definir se um requisito do projeto foi aprovado ou nÃ£o.

Na coluna % Lines (porcentagem de linhas de cÃ³digo) da linha All files(todos os arquivos) temos a informaÃ§Ã£o do total de nÃºmero de linhas da nossa aplicaÃ§Ã£o que nossos testes estÃ£o cobrindo, nesse caso 76,19%
Na coluna Uncovered Line #s (nÃºmero das linhas de cÃ³digos que nÃ£o estÃ£o cobertas) da linha passenger.model.js temos a informaÃ§Ã£o de exatamente quais sÃ£o as linhas de cÃ³digo do arquivo passenger.model.js que ainda nÃ£o estÃ£o cobertas, nesse caso o intervalo comeÃ§ando na linha 21 e indo atÃ© a linha 32 representado por 21-32

# CAMADA SERVICE  = ela liga a camada model com a camada controller, nela fica as regras de negÃ³cios. Em resumo, a camada de serviÃ§o Ã© essencial para o desenvolvimento de software robusto e confiÃ¡vel. Ela centraliza a lÃ³gica de negÃ³cios e as validaÃ§Ãµes de dados, promovendo a modularidade, reutilizaÃ§Ã£o de cÃ³digo e facilidade de manutenÃ§Ã£o. Ao adotar uma abordagem em camadas e incluir a camada de serviÃ§o, estamos construindo uma base sÃ³lida para o sistema, garantindo sua eficiÃªncia, escalabilidade e capacidade de adaptaÃ§Ã£o a mudanÃ§as futuras.

Agora, o que uma boa camada de Service nÃ£o deve fazer? ðŸ¤”

NÃ£o deve ter nenhum tipo de informaÃ§Ã£o sobre o acesso a camada de dados (Model);

Exemplo: nÃ£o ter nenhuma query SQL. ðŸ™
NÃ£o deve receber nada relacionado ao HTTP, seja o request ou o response.

A camada Controller, que serÃ¡ explorada mais adiante, deve mandar apenas o necessÃ¡rio para a camada de Service.

* primeiro criar uma pasta chamada "services" dentro de "src" e nela criar um arquivo que faÃ§a sentido estilo a camada model que seria "nomeDoArquivo.service.js" e "index.js"

EX: DENTRO DO ARQUIVO "nomeDoArquivo.service.js"

const { carModel } = require('../models');

const createCar = async ({ model, licensePlate, year, color, driverId }) => {
  const carId = await carModel.insert({ model, licensePlate, year, color, driverId });
  const newCar = { id: carId, model, licensePlate, year, color, driverId };
  return { status: 'SUCCESSFUL', data: newCar };
};


DENTRO DO ARQUIVO "index.js"


const carService = require('./car.service');

module.exports = {
  carService,
};

* dentro da pasta "services" criar tambÃ©m outra pasta chamada "validations" e dentro de validations criar dois arquivos "schemas.js" e "validationsInputValues.js"

EX: DENTRO DO ARQUIVO "schemas.js"

const Joi = require('joi');  = biblioteca que faz as validaÃ§Ãµes.

const addCarSchema = Joi.object({
  model: Joi.string().min(3),  = o valor da chave model tem que ser do tipo string e no mÃ­nino 3 caracteres.
  color: Joi.string().min(2),
  licensePlate: Joi.string().length(7),
  year: Joi.number().integer(),
  driverId: Joi.number(),
});

module.exports = { addCarSchema };


DENTRO DO ARQUIVO "validationsInputValues.js"


const { addCarSchema } = require('./schemas');

const validateNewCar = ({ model, licensePlate, year, color, driverId }) => {
  const { error } = addCarSchema
    .validate({ model, licensePlate, year, color, driverId });   = o ".validate" serve para fazer a validaÃ§Ã£o que estÃ¡ no arquivo "scheme.js"
  if (error) return { status: 'INVALID_VALUE', message: error.message };  = se tiver erro vai retornar esse erro.
};

module.exports = {
  validateNewCar,
};


* agora completar o arquivo "nomeDoArquivo.service.js" para adicionar a validaÃ§Ã£o.

EX: TRECHO PARA ADICIONAR.

const { validateNewCar } = require('./validations/validationsInputValues');

  
  const error = validateNewCar({ model, color, year, licensePlate, driverId });
  if (error) return { status: error.status, data: { message: error.message } };
  

COMO FICA COMPLETO O ARQUIVO: ADICIONANDO MAIS UMA NOVA FUNÃ‡ÃƒO QUE Ã‰ PARA VER SE O DRIVER EXISTE OU SEJA AO MOTORISTA.


const { carModel, driverModel } = require('../models');
const { validateNewCar } = require('./validations/validationsInputValues');

const createCar = async ({ model, licensePlate, year, color, driverId }) => {
  const error = validateNewCar({ model, color, year, licensePlate, driverId });
  if (error) return { status: error.status, data: { message: error.message } };
	
  const driver = await driverExists(driverId);
  if (!driver) return { status: 'NOT_FOUND', data: { message: 'Driver not found' } };
  
  const carId = await carModel.insert({ model, licensePlate, year, color, driverId });
  const newCar = { id: carId, model, licensePlate, year, color, driverId };
  return { status: 'SUCCESSFUL', data: newCar };
};

const driverExists = async (driverId) => {
  const driver = await driverModel.findById(driverId);
  return driver || false;
};


* implementando o arquivo service no endpoint.

EX:

app.post('/cars', async (req, res) => {
  const { model, licensePlate, year, color, driverId } = req.body;
  const serviceResponse = await carService.createCar({
    model, 
    licensePlate, 
    year, 
    color, 
    driverId,
  });

  if (serviceResponse.status !== 'SUCCESSFUL') {
    return res.status(400).json(serviceResponse.data);  = aqui acessa a chave data
  }
  return res.status(201).json(serviceResponse.data);  = aqui acessa a chave data
});


* agora com funÃ§Ã£o de requisiÃ§Ã£o GET.

EX: NO ARQUIVO "nomeDoArquivo.service.js"

const findAll = async () => {
  const cars = await carModel.findAll();
  return { status: 'SUCCESSFUL', data: cars };
};


NO ARQUIVO DO ENDPOINT


app.get('/cars', async (_req, res) => {
  const serviceResponse = await carService.findAll();
  if (serviceResponse.status !== 'SUCCESSFUL') {
    return res.status(400).json(serviceResponse.data);
  }
  return res.status(200).json(serviceResponse.data);
});

  
  








