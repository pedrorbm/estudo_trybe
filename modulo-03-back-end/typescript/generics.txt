# GENERICS  = imagine uma fun√ß√£o que lida de forma transparente, ou seja, sem voc√™ precisar mud√°-la, que seja aplic√°vel para qualquer tipo de p√£o ou produto e que tanto seus par√¢metros quanto seu retorno sejam do tipo desejado. Nessa fun√ß√£o, n√£o √© necess√°rio mudar par√¢metros, adicionar ifs ou mesmo escrever fun√ß√µes novas, s√≥ chamar com o novo tipo. Esse √© o poder dos Generics no TypeScript!

EX:

// Aqui temos a nossa fun√ß√£o com um tipo gen√©rico. 
// Repare que esse tipo, como qualquer outro, pode vir como um array nos par√¢metros.
function countBreads<Type>(breads: Type[]): number {
  return breads.length;
}

Ap√≥s voc√™ escrever a fun√ß√£o gen√©rica countBreads, voc√™ pode escolher cham√°-la de duas maneiras.

A primeira √© deixando expl√≠cito qual √© o tipo de Type, logo ap√≥s o nome da fun√ß√£o e antes dos ().

EX:

// Assim chamamos nossa fun√ß√£o com o tipo string.
// Ela tipar√° o par√¢metro como um array de strings.

const myBreadsAsStrings = ['P√£o de sal', 'P√£o doce'];
console.log(countBreads<string>(myBreadsAsStrings));

// Assim √© como chamamos nossa fun√ß√£o com dois objetos do tipo 'CommonBread'.

// type CommonBread = { ... };
// const paoDeSal: CommonBread = { ... };
// const paoDoce: CommonBread = { ... };

// Aqui, nossa fun√ß√£o tipar√° o par√¢metro como um array de CommonBread.
const myBreads = [paoDeSal, paoDoce];
console.log(countBreads<CommonBread>(myBreads));
Acesse o exemplo acima aqui.

Note que, para tipos gen√©ricos, a infer√™ncia de tipos ainda funciona ‚Äì se voc√™ n√£o declara explicitamente o tipo de um valor, o TypeScript d√° seu melhor palpite e o atribui √†quele valor sempre que poss√≠vel.

Para o c√≥digo ficar leg√≠vel e os erros ficarem mais f√°ceis de rastrear, a tipagem deve ser sempre expl√≠cita, mas √© importante saber que o TypeScript tem essa funcionalidade. Caso um valor fique sem tipagem e tudo siga funcionado, ainda assim pode ser por isso üòâ.

* E se voc√™ tem uma fun√ß√£o com mais par√¢metros e deseja que ela seja gen√©rica? Voc√™ pode garantir a tipagem gen√©rica de ambos os par√¢metros tamb√©m. 

EX:

function sendAlertAboutAllergens<BreadType, AllergensType>(
  breads: BreadType[],
  allergens: AllergensType[],
): string {
  return `Aten√ß√£o! ${breads.join(' e ')} t√™m como alerg√™nicos: ${allergens.join(', ')}`;
}

console.log(sendAlertAboutAllergens<string, string>(['P√£o de sal', 'P√£o doce'], ['Gluten']));

const allergensIds = [123, 445, 221];
console.log(sendAlertAboutAllergens<string, number>(['P√£o de sal', 'P√£o doce'], allergensIds));
Note a sintaxe ‚Äì √© simples tiparmos a fun√ß√£o com m√∫ltiplos tipos gen√©ricos.

* Como tipar, de forma gen√©rica, fun√ß√µes que retornam Promises
O exemplo abaixo √© uma forma de ilustrar o uso de Generics com o m√≥dulo axios, mas √© um c√≥digo que n√£o ser√° necess√°rio ser executado!

Por fim, uma dica valiosa! Observe a requisi√ß√£o para uma API feita com uma biblioteca externa, a axios:

EX:

import axios from 'axios';

async function fetchApi(endpoint: string) {
  const { data } = await axios.get(`http://localhost:3001/${endpoint}`);
  return data;
}

fetchApi('breads')

Ao colocar o mouse sobre a chamada da fun√ß√£o (√∫ltima linha), no TypeScript Playground, voc√™ vai notar que o retorno da fun√ß√£o ser√° do tipo Promise<any>, como na imagem abaixo:

Retorno da promise any
Mensagem do VSCode com o retorno da fun√ß√£o sendo Promise<any>
Anota a√≠ üìù: Promise<seu tipo aqui> √© um tipo nativo do TypeScript que utiliza a estrutura dos Generics. √â um c√≥digo que s√≥ pode ser usado apropriadamente com Generics!

Esse tipo de implementa√ß√£o n√£o informa a estrutura de dados que voc√™ vai receber. Ser√° que √© a lista de p√£es? A de farinhas de trigo? Ou literalmente qualquer outra coisa? N√≥s perdemos nossa tipagem a√≠!

* O Generics pode auxiliar nessas situa√ß√µes. Veja a implementa√ß√£o a seguir:

O c√≥digo a seguir n√£o √© funcional, apenas exemplificativo, portanto, n√£o √© necess√°rio execut√°-lo.

EX:

// import axios from 'axios';

type Bread = {
  name: string,
  ingredients: string[],
  gluten: boolean,
};

type Flour = {
  brand: string,
  description: string,
  gluten: boolean,
};

async function fetchApi<ResponseType>(endpoint: string): Promise<ResponseType> {
  const { data } = await axios.get<ResponseType>(`http://localhost:3001/${endpoint}`);
  return data;
}

fetchApi<Bread[]>('breads');
fetchApi<Flour[]>('flours');

Dessa forma, √© poss√≠vel utilizar uma biblioteca externa, como a axios, utilizando uma fun√ß√£o gen√©rica e cuidando da seguran√ßa em rela√ß√£o √† tipagem.


