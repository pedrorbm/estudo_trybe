# TypeScript = serve para definir qual o tipo de ums variÃ¡vel, parÃ¢metro de uma funÃ§Ã£o, resultado de uma funÃ§Ã£o, entre outros. Ela vai definir o tipo de cada um. Ele tambÃ©m analisa todos os tipos de dados para ver se estÃ¡ certo, antes de rodar o cÃ³digo.

* Tipagem  = Tipar um dado Ã© dizer explicitamente qual tipo de valor ele contÃ©m. Seja um nÃºmero, uma string ou tantos outros. Ã‰ possÃ­vel usar a definiÃ§Ã£o de tipos em:

variÃ¡veis.
parÃ¢metros de funÃ§Ãµes.
retorno de funÃ§Ãµes.

EX:

let firstName = 'Julia';
console.log(typeof(firstName));  = 'String'

* compilador e transpilador

* Compilador Ã© um programa que traduz um cÃ³digo escrito em uma linguagem de alto nÃ­vel (mais prÃ³xima da humana) para um cÃ³digo equivalente escrito em uma linguagem de baixo nÃ­vel (mais prÃ³xima da linguagem da mÃ¡quina). Depois dessa traduÃ§Ã£o, o cÃ³digo pode ser executado.

O TypeScript Ã© compilado antes de ser executado. JÃ¡ o JavaScript pula essa etapa e Ã© executado direto. Por isso, somente rodando que o JavaScript consegue encontrar seus erros.

* Transpilador, por outro lado, Ã© um programa que traduz um cÃ³digo escrito em uma linguagem de alto nÃ­vel para um cÃ³digo equivalente em outra linguagem de alto nÃ­vel ou em uma versÃ£o diferente da mesma linguagem.

Ã‰ possÃ­vel ver referÃªncias ao TypeScript como uma linguagem transpilada por ela ser â€œtraduzidaâ€ para JS, ambas linguagens de alto nÃ­vel. Contudo, alÃ©m da documentaÃ§Ã£o da linguagem tratar esse processo como compilaÃ§Ã£o, o TS tem um compilador, o TSC (TypeScript Compiler), e Ã© essa abordagem adotada aqui.

# TSC - TypeScript Compiler

Resumindo o que vocÃª estudou atÃ© aqui, o TypeScript Ã© uma linguagem estaticamente tipada e tem o TSC como responsÃ¡vel por compilar o cÃ³digo TS em JS, fazendo as verificaÃ§Ãµes de tipo no meio tempo.

Agora, veja como isso funciona jÃ¡ em sua mÃ¡quina! Primeiramente, em um diretÃ³rio vazio, crie um arquivo hello.ts e adicione a ele apenas o seguinte cÃ³digo:

EX:

console.log('Hello, TypeScript!');

Para executÃ¡-lo, Ã© necessÃ¡rio instalar o Typescript, seja globalmente, seja no projeto atual. Para instalar no projeto, basta inicializar o package.json e instalar o Typescript:

EX:

npm init -y
npm i typescript@4.4

* Com o Typescript instalado, podemos rodar seu executÃ¡vel chamado tsc:

EX:

npx tsc hello.ts

Ao rodar esse comando, o conteÃºdo do arquivo hello.ts serÃ¡ verificado e, caso nenhum problema seja encontrado, um arquivo serÃ¡ criado com o nome hello.js, contendo o cÃ³digo compilado para JS.

Caso haja erro, como os problemas com tipo jÃ¡ mencionados, o compilador apontarÃ¡ uma mensagem de erro no terminal, e o arquivo .js nÃ£o serÃ¡ gerado.

Para rodar o arquivo gerado utilizando o Node, basta executar node hello.js no terminal.

TambÃ©m, Ã© possÃ­vel instalar o compilador TypeScript globalmente, mas Ã© recomendÃ¡vel instalÃ¡-lo localmente em cada projeto, jÃ¡ com a versÃ£o adequada, para evitar possÃ­veis conflitos de versÃ£o.

* ts-node

Uma opÃ§Ã£o para otimizar esse processo Ã© usar o ts-node, que, em linhas gerais, vai compilar seu cÃ³digo TypeScript em JavaScript e executÃ¡-lo usando o Node com um Ãºnico comando. Outra vantagem desse executÃ¡vel Ã© que ele faz esse processo sem gerar um arquivo .js para cada arquivo .ts de sua aplicaÃ§Ã£o.

Instale o ts-node como uma dependÃªncia de desenvolvimento para que ele fique registrado em seu package.json. Para isso, basta entrar no diretÃ³rio com seu arquivo hello.ts e executar o comando:

EX:

npm i --save-dev ts-node

* Em seguida, vocÃª pode deletar o arquivo hello.js criado pelo tsc e utilizar o seguinte comando para executar seu cÃ³digo:

EX:

ts-node hello.ts

* tsconfig

O arquivo tsconfig.json Ã© o arquivo de configuraÃ§Ã£o de um projeto em TypeScript. Nele, estÃ£o especificadas as opÃ§Ãµes de configuraÃ§Ã£o que definirÃ£o como seu cÃ³digo serÃ¡ compilado.

Utilize o tsc para gerar o tsconfig.json. Para isso, a partir de um diretÃ³rio vazio, execute o comando:

EX:

tsc --init
Use o comando npx tsc --init caso queira utilizar o tsc como um executÃ¡vel npx.

Um arquivo tsconfig.json serÃ¡ gerado no diretÃ³rio com o seguinte conteÃºdo:

EX:

{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */

    /* Projects */
    [...]
    /* Language and Environment */
    "target": "es2016",                                  /* Set the JavaScript language version for emitted JavaScript and include
    [...]

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    "rootDir": "./",                                     /* Specify the root folder within your source files. */
    [...]

    /* JavaScript Support */
    [...]

    /* Emit */
    "outDir": "./",                                      /* Specify an output folder for all emitted files. */
    [...]

    /* Interop Constraints */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules.
    [...]

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    [...]
  }
}

AlÃ©m de fornecer as principais configuraÃ§Ãµes (com comentÃ¡rios sobre o que fazem e quais sÃ£o os valores aceitos), o arquivo gerado tem uma URL explicando mais sobre o arquivo tsconfig.json.

Vamos analisar o que jÃ¡ vem configurado no arquivo tsconfig.json e o que vocÃª precisa para criar o primeiro projeto em Typescript?

module: especifica o â€œsistema de mÃ³duloâ€ a ser utilizado no cÃ³digo JavaScript. Leia a documentaÃ§Ã£o se quiser se aprofundar, mas aqui serÃ¡ requerido â€˜CommonJSâ€™ quase sempre.

target: define a versÃ£o do JavaScript para qual o cÃ³digo serÃ¡ compilado. Exemplo: ES6.

rootDir: define a raiz dos arquivos do projeto. Ã‰ comum utilizar â€œ./srcâ€ aqui, jÃ¡ que Ã© onde os cÃ³digos-fonte costumam ficar.

outDir: define a pasta de saÃ­da do cÃ³digo compilado. Pode-se agrupar os arquivos .js gerados durante a compilaÃ§Ã£o em um diretÃ³rio nomeado a seu critÃ©rio, mas Ã© comum usar â€œ./distâ€ ou â€œ./buildâ€.

esModuleInterop: permite a compilaÃ§Ã£o de mÃ³dulos ES6 para CommonJS. Ã‰ isso que possibilita a vocÃª usar a sintaxe de importaÃ§Ã£o padrÃ£o do TypeScript com mÃ³dulos do ECMAScript, por exemplo.
strict: ativa a verificaÃ§Ã£o estrita (mais rigorosa) de tipo.

include: inclui os arquivos ou diretÃ³rios mencionados na compilaÃ§Ã£o, como â€œsrc/â€œ.

exclude: exclui os arquivos ou diretÃ³rios mencionados na compilaÃ§Ã£o, por exemplo â€œbuildâ€ ou â€œnode_modulesâ€.

Falaremos de outras configuraÃ§Ãµes Ã  medida que vocÃª for usÃ¡-las, mas, caso queira saber mais a respeito disso, acesse o link que vem no arquivo recÃ©m-criado! ğŸ˜‰

# Tipos primitivos
Em JavaScript, um valor que nÃ£o Ã© um objeto nem uma funÃ§Ã£o Ã© de um tipo primitivo. Os mais comuns em JavaScript sÃ£o:

string: uma sequÃªncia de quaisquer caracteres que pertenÃ§am ao padrÃ£o UTF-16 Unicode.
number: recebe valores numÃ©ricos, sejam eles inteiros ou fraÃ§Ãµes.
boolean: recebe verdadeiro (true) ou falso (false).
null: representa a ausÃªncia intencional de um valor. Ã‰ como dizer â€œaqui nÃ£o hÃ¡ valor e isso Ã© propositalâ€.
undefined: representa a ausÃªncia de um valor cujo tipo nÃ£o foi explicitado no cÃ³digo.

Todos esses tipos primitivos tÃªm um valor correspondente em TypeScript (com os mesmos nomes). Contudo, o TypeScript tem um tipo adicional chamado any.

* any

Esse tipo Ã© um coringa. Ao utilizÃ¡-lo, vocÃª afirma â€œeu nÃ£o sei qual Ã© o tipo desse valor e nÃ£o me importo com issoâ€. Ã‰ uma forma de desabilitar as checagens de tipo e sinalizar para o TypeScript que vocÃª nÃ£o quer que ele faÃ§a a verificaÃ§Ã£o de tipagens para aquele valor.

Como qualquer coringa, Ã© preciso usÃ¡-lo com responsabilidade - a tipagem estÃ¡tica do TypeScript estÃ¡ aÃ­ por um motivo, entÃ£o nÃ£o a dispense sem ter muita convicÃ§Ã£o do que estÃ¡ fazendo.

* No implict any

Quando o TypeScript, por alguma razÃ£o, nÃ£o consegue identificar o tipo de um valor, o tipo any Ã© inferido e atribuÃ­do a ele por padrÃ£o. No geral, nÃ£o queremos que isso aconteÃ§a, e sim queremos garantir que as checagens de tipo sejam feitas e que todos os tipos sejam identificados.

EntÃ£o, Ã© comum que a regra noImplicitAny esteja habilitada nas configuraÃ§Ãµes de projetos (arquivo tsconfig.json), pois isso faz com que o compilador sinalize qualquer any implÃ­cito como erro - quer dizer que ele nÃ£o sabe qual Ã© aquele tipo e precisa saber.

* unknown

Muitas vezes, ao consumir APIs externas, por exemplo, nÃ£o se sabe qual tipo de valor serÃ¡ retornado. Nesses casos, usar o tipo any poderia parecer uma escolha natural, mas o TypeScript oferece uma alternativa mais segura: o unknown!

Ao contrÃ¡rio do any, aqui vocÃª estÃ¡ dizendo â€œeu nÃ£o sei qual Ã© o tipo desse valor, mas me importo bastante com issoâ€! Desse modo, o compilador obrigarÃ¡ vocÃª a determinar o tipo de qualquer valor unknown antes de usÃ¡-lo, o que garante tipagem mais segura para sua aplicaÃ§Ã£o.

O prÃ³ximo passo, entÃ£o, Ã© como dizer ao TypeScript qual o tipo de uma variÃ¡vel!

* VariÃ¡veis
Para fazer anotaÃ§Ãµes de tipo em variÃ¡veis, vocÃª precisa apenas colocar : apÃ³s o nome da variÃ¡vel e, em seguida, escrever seu tipo. Por exemplo:

EX:

const firstName: string = "Joel";
const age: number = 38;
const brazilian: boolean = false;

* FunÃ§Ãµes
Quando se tratam de funÃ§Ãµes, hÃ¡ valores de entrada (parÃ¢metros) e saÃ­da (retorno) para tipar! Ã‰ importante explicitar, sobretudo, o tipo dos valores de entrada, pois uma funÃ§Ã£o pode ser chamada com qualquer valor e, por isso, o TypeScript nÃ£o consegue inferir seu tipo durante a compilaÃ§Ã£o.

Exemplo de anotaÃ§Ã£o de tipo em parÃ¢metros:

EX:

function greet(name: string) {
  console.log(`OlÃ¡, ${name.toUpperCase()}!`);
}

Se vocÃª executar a funÃ§Ã£o acima no Typescript Playground usando uma string como argumento, verÃ¡ que tudo funcionarÃ¡ perfeitamente. No entanto, se vocÃª tentar passar um nÃºmero, por exemplo, receberÃ¡ o erro â€œArgument of type â€˜numberâ€™ is not assignable to parameter of type â€˜stringâ€™.â€.

Exemplo de anotaÃ§Ã£o de tipo em retornos:

EX:

function getFavoriteNumber(): number {
  return 26;
}

* Agora, talvez vocÃª esteja se perguntando:

â€œCerto, mas e quando a funÃ§Ã£o nÃ£o retorna nenhum valor?â€ ğŸ¤”

Nesse caso, o tipo de retorno serÃ¡ void!

A funÃ§Ã£o greet, apresentada acima, Ã© um exemplo de funÃ§Ã£o que nÃ£o tem um valor de retorno, pois apenas imprime algo no console. Vamos tipar seu retorno explicitamente:

EX:

function greet(name: string): void {
  console.log(`OlÃ¡, ${name.toUpperCase()}!`);
}

Anota aÃ­ ğŸ“: A anotaÃ§Ã£o de tipo em retornos aparece apÃ³s a lista de parÃ¢metros da funÃ§Ã£o.

Como ocorre com as variÃ¡veis, a especificaÃ§Ã£o de tipo do retorno nÃ£o Ã© sempre necessÃ¡ria, pois o TypeScript pode inferir o tipo do retorno com base nas declaraÃ§Ãµes de retorno da prÃ³pria funÃ§Ã£o. No caso do exemplo acima, se vocÃª remover o tipo do retorno, o TS vai inferir que o retorno Ã© void, uma vez que nÃ£o hÃ¡ nenhum valor retornado.

Algumas bases de cÃ³digo vÃ£o preferir explicitar sempre todos os tipos, sejam de retorno ou outros valores, para fins de documentaÃ§Ã£o, a fim de prevenir alteraÃ§Ãµes acidentais ou mesmo por preferÃªncias pessoais. O princÃ­pio â€œExplÃ­cito Ã© melhor que implÃ­citoâ€ Ã© adotado por muitas organizaÃ§Ãµes.

* Que erros a tipagem previne?
Conforme mencionado anteriormente, a tipagem estÃ¡tica pode prevenir alguns erros de forma mais eficiente do que documentaÃ§Ã£o ou testes automatizados. Para ilustrar esse ponto, considere o seguinte cÃ³digo em JavaScript:

EX:

let sum = (a, b) => a + b
sum(1, '2')

A tipagem estÃ¡tica impede o erro de acontecer. No JavaScript, a funÃ§Ã£o acima retorna '12', e cabe a vocÃª descobrir, depois de algo explodir em algum lugar lÃ¡ na frente, que o problema era aqui.

ğŸ’­ Pare e reflita: vocÃª jÃ¡ viveu uma situaÃ§Ã£o onde a tipagem estÃ¡tica de valores teria evitado horas de trabalho desperdiÃ§adas?

* Listas e objetos
Comumente, arrays (listas) e objetos sÃ£o utilizados em cÃ³digos JavaScript. Em TypeScript, nÃ£o serÃ¡ diferente. Como vocÃª pode tipÃ¡-los?

* object type
Em TypeScript, o tipo objeto Ã© basicamente qualquer valor que nÃ£o seja um tipo primitivo (string, number, bigint, boolean, symbol, null, ou undefined) e que tenha propriedades. Para tipar um objeto, Ã© necessÃ¡rio apenas listar suas propriedades e seus tipos, como no exemplo a seguir.

EX:

function printPersonalInfo(data: { name: string; birthYear: number }) {
  console.log(`${data.name} was born in ${data.birthYear}.`);
}
printPersonalInfo({ name: 'Rogerinho', birthYear: 1978 });
De olho na dica ğŸ‘€: VocÃª pode usar tanto vÃ­rgula quanto ponto e vÃ­rgula para separar propriedades escritas em uma sÃ³ linha.

VocÃª nÃ£o precisa tipar cada propriedade, mas, caso vocÃª nÃ£o o faÃ§a, o TypeScript assumirÃ¡ que elas sÃ£o do tipo any.

VocÃª lembra qual problema isso pode causar? ğŸ¤” Vai ferir uma configuraÃ§Ã£o, que jÃ¡ comentamos, chamada noImplicitAny! Caso vocÃª cometa esse erro no futuro, lembre-se de que nÃ³s avisamos! ğŸ˜œ

* TambÃ©m, Ã© possÃ­vel especificar o tipo dos elementos de um array, o que Ã© tipar o array em si. Para isso, basta inserir os colchetes depois do tipo dos elementos do array:

EX:

const evenNumbers: number[] = [2, 4, 6];
const vowel: string[] = ['a', 'e', 'i', 'o', 'u'];
const booleanValues: boolean[] = [true, false];

* Portanto, nÃ£o Ã© possÃ­vel adicionar novos elementos a um array se eles nÃ£o corresponderem aos tipos previamente determinados.

EX:

evenNumbers.push(8) // Funciona
evenNumbers.push('8') // Erro

Outra sintaxe possÃ­vel para fazer a mesma tipagem Ã© Array<number>. VocÃª estudarÃ¡ mais a respeito dessa sintaxe quando estiver no conteÃºdo sobre Generics! ğŸ˜‰

* CombinaÃ§Ã£o de tipos
AtÃ© o momento, foi visto como tipar variÃ¡veis, parÃ¢metros e retorno de funÃ§Ãµes com tipos. Contudo, no JavaScript, temos lÃ³gicas em que variÃ¡veis que precisam receber tipos de valores diferentes. Para esses casos, o TypeScript tambÃ©m tem soluÃ§Ã£o.

* Union Types
Essa estrutura Ã© formada por dois ou mais tipos que podem ser atribuÃ­dos Ã quele dado:

EX:

function printId(id: number | string) {
  console.log(`Your ID is: ${id}`);
}

printId(101);
printId("202");

No Typescript Playground, chame a funÃ§Ã£o acima com um nÃºmero ou uma string como argumento. Note que tudo funcionarÃ¡ perfeitamente. Contudo, se tentÃ¡ssemos chamar a funÃ§Ã£o com um argumento boolean, um erro seria disparado. FaÃ§a o teste!

AtenÃ§Ã£o! Em casos assim, vocÃª nÃ£o pode chamar na variÃ¡vel um mÃ©todo que nÃ£o existe para todos os tipos que ela pode ter. Um exemplo Ã© o toUpperCase(), que Ã© um mÃ©todo do tipo string e nÃ£o existe no tipo number. Para o id acima, chamar o toUpperCase() resultarÃ¡ em erro.

EX:

function printId(id: number | string) {
  console.log(id.toUpperCase());
}

printId(101);

Execute esse exemplo no TS Playground e veja o que acontece.

* No entanto, se vocÃª ainda precisar chamar um mÃ©todo assim, basta verificar o tipo do valor antes da chamada. Desse modo, vai funcionar.

EX:

function printId(id: number | string) {
  if (typeof id === "string") {
    return console.log(id.toUpperCase());
  }
  return console.log(id);
}

printId(101);

* Type Aliases
Olha quanta coisa vocÃª jÃ¡ consegue fazer sÃ³ com as anotaÃ§Ãµes de tipo! Legal demais, nÃ©?! ğŸ¤©

E no caso de haver vÃ¡rios elementos que vocÃª precisa tipar da mesma forma? SerÃ¡ necessÃ¡rio continuar especificando o tipo em cada um deles ou hÃ¡ modos melhores de fazer isso? ğŸ¤”

Falaremos disso agora!

* Type Alias Ã© um modo de reunirmos alguns tipos especÃ­ficos e chamÃ¡-los por um â€œapelidoâ€. Para isso, utiliza-se a seguinte sintaxe:

EX:

type PersonalInfo = {
  name: string;
  birthYear: number;
};

* Agora, vocÃª pode utilizar o tipo criado para definir os parÃ¢metros da funÃ§Ã£o printPersonalInfo (criada anteriormente na liÃ§Ã£o sobre type annotations):

EX:

function printPersonalInfo(data: PersonalInfo) {
  console.log(`${data.name} was born in ${data.birthYear}.`);
}

printPersonalInfo({ name: 'Rogerinho', birthYear: 1978});

* VocÃª pode usar type aliases para dar â€œapelidosâ€ a quaisquer tipos que vocÃª queira, utilizando inclusive uniÃ£o de tipos para isso. Por exemplo:

EX:

type PersonalInfo = {
  name: string;
  birthYear: number | string;
};

Outro exemplo:

EX:

type ID = number | string;

* Type Annotation vs InferÃªncia de tipos
Agora que vocÃª jÃ¡ sabe como fazer anotaÃ§Ãµes de tipo e jÃ¡ viu que nem sempre Ã© necessÃ¡rio explicitar essa informaÃ§Ã£o, talvez tenha surgido a seguinte dÃºvida: â€œAfinal, quando usar type annotations e quando deixar o TypeScript inferir um tipo?â€

Em linhas gerais, Ã© possÃ­vel saber qual Ã© o tipo simplesmente lendo a linha, sem precisar explicitÃ¡-lo. Isso sÃ³ deixaria o cÃ³digo mais verboso e nÃ£o melhoraria a legibilidade. Portanto, Ã© desnecessÃ¡rio tipar variÃ¡veis e objetos simples, com valores inicializados como string, number ou boolean, por exemplo.

Por outro lado, quando trabalhar com valores complexos, como objetos e funÃ§Ãµes, faÃ§a anotaÃ§Ãµes de tipos. Como jÃ¡ mencionado, retornos de funÃ§Ãµes sÃ£o valores importantes de serem tipados, a fim de certificar-se de que ele serÃ¡ o que vocÃª determinou. AlÃ©m disso, na construÃ§Ã£o de APIs pÃºblicas, tipar os valores de entrada e de saÃ­da de funÃ§Ãµes pode ajudar outras pessoas a entender como utilizar sua API corretamente.

* O objeto abaixo contÃ©m um exemplo de valores facilmente inferidos pelo TypeScript e, portanto, Ã© desnecessÃ¡rio fazer anotaÃ§Ãµes.

EX:

const person = {
  fistName: 'Frodo',
  lastName: 'Baggins',
  age: 52,
}

console.log(typeof person.fistName); // "string"

* Primeiro programa em TypeScript
Finalmente chegou o momento de vocÃª escrever seu primeiro programa, do zero, utilizando o TypeScript e rodando em sua mÃ¡quina!

ğŸ¬ Caso vocÃª prefira consumir o conteÃºdo em vÃ­deo, ele estÃ¡ disponÃ­vel no final desta liÃ§Ã£o! ğŸ˜‰

* ConfiguraÃ§Ã£o inicial (setup)
Crie um diretÃ³rio chamado aprendendo-ts. Nele, vocÃª vai inicializar seu projeto TypeScript.

EX:

mkdir aprendendo-ts && cd aprendendo-ts

* A seguir, vocÃª vai inicializar seu projeto Node e instalar o TypeScript, o ts-node e o mÃ³dulo npm com a configuraÃ§Ã£o base do tsconfig para o Node 16 (ou superior).

EX:

npm init -y
Copiar
npm install -D ts-node typescript@4.4

* A prÃ³xima etapa Ã© criar o arquivo tsconfig.json:

EX:

tsc --init

* Garanta que seu arquivo tsconfig.json tenha as seguintes configuraÃ§Ãµes:

EX:

{
  "compilerOptions": {
    "target": "es2016",                                 
    "module": "commonjs",
    "rootDir": "./",
    "outDir": "./dist",
    "preserveConstEnums": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}

* Agora, instale o pacote npm com as definiÃ§Ãµes de tipos para o Node.js.

EX:

npm install -D @types/node@16.11

* Projeto GitHub Rockstars
VocÃª recebeu a missÃ£o de fazer uma pequena aplicaÃ§Ã£o para ajudar no recrutamento de pessoas desenvolvedoras! Com base em uma lista estÃ¡tica de perfis do GitHub, deverÃ£o ser extraÃ­das algumas informaÃ§Ãµes:

Listar todas as pessoas.
Filtrar pessoas com base em determinada quantidade de repositÃ³rios.
Descobrir se uma pessoa Ã© a mais ativa da lista.

* Para comeÃ§ar, crie sua estrutura de diretÃ³rios:

EX:

mkdir src && cd src
mkdir types && touch types/User.ts
touch data.ts myFunctions.ts index.ts 

O diretÃ³rio types concentrarÃ¡ todos os type aliases utilizados no projeto. A princÃ­pio, vocÃª terÃ¡ apenas um para User. Os arquivos data.ts, myFunctions.ts e index.ts conterÃ£o, respectivamente, a lista estÃ¡tica de perfis, as funÃ§Ãµes que a aplicaÃ§Ã£o deve fazer e as chamadas dessas funÃ§Ãµes.

* ApÃ³s a execuÃ§Ã£o dos comandos acima, a estrutura de arquivos e diretÃ³rios do seu projeto serÃ¡ assim:

EX:

.
â””â”€â”€ aprendendo-ts/
    â”œâ”€â”€ src/
    â”‚   â””â”€â”€ index.ts
    â”‚   â””â”€â”€ data.ts
    â”‚   â””â”€â”€ myFunctions.ts
    â”‚   â””â”€â”€ types/
    â”‚       â””â”€â”€ User.ts
    â””â”€â”€ package-lock.json
    â””â”€â”€ package.json
    â””â”€â”€ tsconfig.json
    â””â”€â”€ node_modules
    
* ImplementaÃ§Ã£o
Com tudo devidamente configurado, vocÃª vai iniciar a implementaÃ§Ã£o de seu cÃ³digo, lembrando-se de que suas funÃ§Ãµes utilizam uma lista de perfis do GitHub para fazer as operaÃ§Ãµes. Desse modo, o primeiro passo serÃ¡ definir um type alias para as propriedades que cada perfil da lista deve ter, que sÃ£o nome, URL do perfil e quantidade de repositÃ³rios.

Como este Ã© o tipo principal utilizado em toda a sua aplicaÃ§Ã£o, Ã© essencial se lembrar de exportÃ¡-lo! ğŸ˜‰

EX:

// ./src/types/User.ts

export type User = {
  id: string | number;
  name: string;
  profileURL: string;
  repositories: number;
};

* Agora, vocÃª pode criar sua lista definida com o tipo User.

Note que jÃ¡ vocÃª precisarÃ¡ importar o type alias criado hÃ¡ pouco!

EX:

// ./src/data.ts

import { User } from './types/User';

const users: User[] = [
  {
    id: 1,
    name: 'JoÃ£o Paulo Aramuni',
    profileURL: 'https://github.com/joaopauloaramuni',
    repositories: 19,
  },
  {
    id: '2',
    name: 'Rafaella Ballerini',
    profileURL: 'https://github.com/rafaballerini',
    repositories: 47,
  },
  {
    id: 3,
    name: 'Capi Etheriel',
    profileURL: 'https://github.com/barraponto',
    repositories: 340,
  },
];

export default users;

* Com esses dois arquivos de base feitos, inicie a escrita de suas funÃ§Ãµes! ğŸ˜

Sua primeira funÃ§Ã£o receberÃ¡ uma lista de perfis do GitHub, como a definida no arquivo data.ts, e retornarÃ¡ uma lista contendo apenas os valores da propriedade name:

Lembre-se de que, para usar o tipo User, Ã© necessÃ¡rio importÃ¡-lo neste arquivo.

O linter irÃ¡ sugerir utilizar o export default, mas a partir do momento que adicionarmos as novas funÃ§Ãµes, esse aviso sumirÃ¡!

EX:

// ./src/myFunctions.ts

import { User } from './types/User';

export const getUserNames = (userList: User[]): string[] => userList.map((user: User) => user.name);

* A segunda funÃ§Ã£o receberÃ¡ uma lista do tipo User e um nÃºmero. AlÃ©m disso, ela verificarÃ¡ quais perfis da lista recebida tÃªm, no mÃ­nimo, o nÃºmero de repositÃ³rios igual ao do passado como argumento, retornando uma lista com os perfis que satisfizerem a verificaÃ§Ã£o.

EX:

// ./src/myFunctions.ts

// ...

export const getUsersByRepoQuantity = (users: User[], repos: number): string[] => users
  .filter((user) => user.repositories >= repos).map((user) => user.name);
  
* Por fim, haverÃ¡ uma funÃ§Ã£o que serÃ¡ responsÃ¡vel por verificar se uma pessoa Ã© a mais ativa da lista de usuÃ¡rias do GitHub. Essa validaÃ§Ã£o serÃ¡ feita com base na comparaÃ§Ã£o da quantidade de repositÃ³rios que cada pessoa possui. SerÃ¡ considerada a pessoa mais ativa, neste exemplo, a que tiver o maior nÃºmero de repositÃ³rios. Por isso, a funÃ§Ã£o receberÃ¡ o nome de uma pessoa do tipo User e uma lista, tambÃ©m do tipo User, em que a pessoa esteja incluÃ­da. O retorno da funÃ§Ã£o deve ser um boolean (true ou false).

EX:

// ./src/myFunctions.ts

// ...

export const IsMostActiveUser = (name: string, users: User[]): boolean => {
  const mostActiveUser = users.reduce(
    (prev, curr) => 
      (prev.repositories > curr.repositories ? prev : curr),
  );
  return mostActiveUser.name === name;
};

Utilizando as funÃ§Ãµes criadas

* A primeira parte do trabalho estÃ¡ feita, mas agora vocÃª precisa fazer algumas chamadas para as funÃ§Ãµes criadas, a fim de testar se tudo estÃ¡ funcionando corretamente. FaÃ§a essas chamadas no arquivo index.ts.

EX:

// ./index.ts

import * as Functions from './myFunctions';
import users from './data';

console.log(`Lista de pessoas usuÃ¡rias do Github: ${Functions.getUserNames(users)}.`);

console.log(
  `Pessoas com pelo menos 20 repositÃ³rios: ${Functions.getUsersByRepoQuantity(users, 20)}.`,
);

console.log(
  `Essa Ã© a conta mais ativa da lista? ${Functions.IsMostActiveUser('JoÃ£o Paulo Aramuni', users)}.`,
);

* Em seguida, execute seu programa com o ts-node:

EX:

ts-node index.ts
A saÃ­da esperada Ã©:

EX:

Lista de pessoas usuÃ¡rias do GitHub: JoÃ£o Paulo Aramuni, Rafaella Ballerini, Capi Etheriel.
Pessoas com pelo menos 20 repositÃ³rios: Rafaella Ballerini, Capi Etheriel.
Essa Ã© a conta mais ativa da lista? false.



