# TypeScript = serve para definir qual o tipo de ums vari√°vel, par√¢metro de uma fun√ß√£o, resultado de uma fun√ß√£o, entre outros. Ela vai definir o tipo de cada um. Ele tamb√©m analisa todos os tipos de dados para ver se est√° certo, antes de rodar o c√≥digo.

* Tipagem  = Tipar um dado √© dizer explicitamente qual tipo de valor ele cont√©m. Seja um n√∫mero, uma string ou tantos outros. √â poss√≠vel usar a defini√ß√£o de tipos em:

vari√°veis.
par√¢metros de fun√ß√µes.
retorno de fun√ß√µes.

EX:

let firstName = 'Julia';
console.log(typeof(firstName));  = 'String'

* compilador e transpilador

* Compilador √© um programa que traduz um c√≥digo escrito em uma linguagem de alto n√≠vel (mais pr√≥xima da humana) para um c√≥digo equivalente escrito em uma linguagem de baixo n√≠vel (mais pr√≥xima da linguagem da m√°quina). Depois dessa tradu√ß√£o, o c√≥digo pode ser executado.

O TypeScript √© compilado antes de ser executado. J√° o JavaScript pula essa etapa e √© executado direto. Por isso, somente rodando que o JavaScript consegue encontrar seus erros.

* Transpilador, por outro lado, √© um programa que traduz um c√≥digo escrito em uma linguagem de alto n√≠vel para um c√≥digo equivalente em outra linguagem de alto n√≠vel ou em uma vers√£o diferente da mesma linguagem.

√â poss√≠vel ver refer√™ncias ao TypeScript como uma linguagem transpilada por ela ser ‚Äútraduzida‚Äù para JS, ambas linguagens de alto n√≠vel. Contudo, al√©m da documenta√ß√£o da linguagem tratar esse processo como compila√ß√£o, o TS tem um compilador, o TSC (TypeScript Compiler), e √© essa abordagem adotada aqui.

# TSC - TypeScript Compiler

Resumindo o que voc√™ estudou at√© aqui, o TypeScript √© uma linguagem estaticamente tipada e tem o TSC como respons√°vel por compilar o c√≥digo TS em JS, fazendo as verifica√ß√µes de tipo no meio tempo.

Agora, veja como isso funciona j√° em sua m√°quina! Primeiramente, em um diret√≥rio vazio, crie um arquivo hello.ts e adicione a ele apenas o seguinte c√≥digo:

EX:

console.log('Hello, TypeScript!');

Para execut√°-lo, √© necess√°rio instalar o Typescript, seja globalmente, seja no projeto atual. Para instalar no projeto, basta inicializar o package.json e instalar o Typescript:

EX:

npm init -y
npm i typescript@4.4

* Com o Typescript instalado, podemos rodar seu execut√°vel chamado tsc:

EX:

npx tsc hello.ts

Ao rodar esse comando, o conte√∫do do arquivo hello.ts ser√° verificado e, caso nenhum problema seja encontrado, um arquivo ser√° criado com o nome hello.js, contendo o c√≥digo compilado para JS.

Caso haja erro, como os problemas com tipo j√° mencionados, o compilador apontar√° uma mensagem de erro no terminal, e o arquivo .js n√£o ser√° gerado.

Para rodar o arquivo gerado utilizando o Node, basta executar node hello.js no terminal.

Tamb√©m, √© poss√≠vel instalar o compilador TypeScript globalmente, mas √© recomend√°vel instal√°-lo localmente em cada projeto, j√° com a vers√£o adequada, para evitar poss√≠veis conflitos de vers√£o.

* ts-node

Uma op√ß√£o para otimizar esse processo √© usar o ts-node, que, em linhas gerais, vai compilar seu c√≥digo TypeScript em JavaScript e execut√°-lo usando o Node com um √∫nico comando. Outra vantagem desse execut√°vel √© que ele faz esse processo sem gerar um arquivo .js para cada arquivo .ts de sua aplica√ß√£o.

Instale o ts-node como uma depend√™ncia de desenvolvimento para que ele fique registrado em seu package.json. Para isso, basta entrar no diret√≥rio com seu arquivo hello.ts e executar o comando:

EX:

npm i --save-dev ts-node

* Em seguida, voc√™ pode deletar o arquivo hello.js criado pelo tsc e utilizar o seguinte comando para executar seu c√≥digo:

EX:

ts-node hello.ts

* tsconfig

O arquivo tsconfig.json √© o arquivo de configura√ß√£o de um projeto em TypeScript. Nele, est√£o especificadas as op√ß√µes de configura√ß√£o que definir√£o como seu c√≥digo ser√° compilado.

Utilize o tsc para gerar o tsconfig.json. Para isso, a partir de um diret√≥rio vazio, execute o comando:

EX:

tsc --init
Use o comando npx tsc --init caso queira utilizar o tsc como um execut√°vel npx.

Um arquivo tsconfig.json ser√° gerado no diret√≥rio com o seguinte conte√∫do:

EX:

{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */

    /* Projects */
    [...]
    /* Language and Environment */
    "target": "es2016",                                  /* Set the JavaScript language version for emitted JavaScript and include
    [...]

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    "rootDir": "./",                                     /* Specify the root folder within your source files. */
    [...]

    /* JavaScript Support */
    [...]

    /* Emit */
    "outDir": "./",                                      /* Specify an output folder for all emitted files. */
    [...]

    /* Interop Constraints */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules.
    [...]

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    [...]
  }
}

Al√©m de fornecer as principais configura√ß√µes (com coment√°rios sobre o que fazem e quais s√£o os valores aceitos), o arquivo gerado tem uma URL explicando mais sobre o arquivo tsconfig.json.

Vamos analisar o que j√° vem configurado no arquivo tsconfig.json e o que voc√™ precisa para criar o primeiro projeto em Typescript?

module: especifica o ‚Äúsistema de m√≥dulo‚Äù a ser utilizado no c√≥digo JavaScript. Leia a documenta√ß√£o se quiser se aprofundar, mas aqui ser√° requerido ‚ÄòCommonJS‚Äô quase sempre.

target: define a vers√£o do JavaScript para qual o c√≥digo ser√° compilado. Exemplo: ES6.

rootDir: define a raiz dos arquivos do projeto. √â comum utilizar ‚Äú./src‚Äù aqui, j√° que √© onde os c√≥digos-fonte costumam ficar.

outDir: define a pasta de sa√≠da do c√≥digo compilado. Pode-se agrupar os arquivos .js gerados durante a compila√ß√£o em um diret√≥rio nomeado a seu crit√©rio, mas √© comum usar ‚Äú./dist‚Äù ou ‚Äú./build‚Äù.

esModuleInterop: permite a compila√ß√£o de m√≥dulos ES6 para CommonJS. √â isso que possibilita a voc√™ usar a sintaxe de importa√ß√£o padr√£o do TypeScript com m√≥dulos do ECMAScript, por exemplo.
strict: ativa a verifica√ß√£o estrita (mais rigorosa) de tipo.

include: inclui os arquivos ou diret√≥rios mencionados na compila√ß√£o, como ‚Äúsrc/‚Äú.

exclude: exclui os arquivos ou diret√≥rios mencionados na compila√ß√£o, por exemplo ‚Äúbuild‚Äù ou ‚Äúnode_modules‚Äù.

Falaremos de outras configura√ß√µes √† medida que voc√™ for us√°-las, mas, caso queira saber mais a respeito disso, acesse o link que vem no arquivo rec√©m-criado! üòâ

# Tipos primitivos
Em JavaScript, um valor que n√£o √© um objeto nem uma fun√ß√£o √© de um tipo primitivo. Os mais comuns em JavaScript s√£o:

string: uma sequ√™ncia de quaisquer caracteres que perten√ßam ao padr√£o UTF-16 Unicode.
number: recebe valores num√©ricos, sejam eles inteiros ou fra√ß√µes.
boolean: recebe verdadeiro (true) ou falso (false).
null: representa a aus√™ncia intencional de um valor. √â como dizer ‚Äúaqui n√£o h√° valor e isso √© proposital‚Äù.
undefined: representa a aus√™ncia de um valor cujo tipo n√£o foi explicitado no c√≥digo.

Todos esses tipos primitivos t√™m um valor correspondente em TypeScript (com os mesmos nomes). Contudo, o TypeScript tem um tipo adicional chamado any.

* any

Esse tipo √© um coringa. Ao utiliz√°-lo, voc√™ afirma ‚Äúeu n√£o sei qual √© o tipo desse valor e n√£o me importo com isso‚Äù. √â uma forma de desabilitar as checagens de tipo e sinalizar para o TypeScript que voc√™ n√£o quer que ele fa√ßa a verifica√ß√£o de tipagens para aquele valor.

Como qualquer coringa, √© preciso us√°-lo com responsabilidade - a tipagem est√°tica do TypeScript est√° a√≠ por um motivo, ent√£o n√£o a dispense sem ter muita convic√ß√£o do que est√° fazendo.

* No implict any

Quando o TypeScript, por alguma raz√£o, n√£o consegue identificar o tipo de um valor, o tipo any √© inferido e atribu√≠do a ele por padr√£o. No geral, n√£o queremos que isso aconte√ßa, e sim queremos garantir que as checagens de tipo sejam feitas e que todos os tipos sejam identificados.

Ent√£o, √© comum que a regra noImplicitAny esteja habilitada nas configura√ß√µes de projetos (arquivo tsconfig.json), pois isso faz com que o compilador sinalize qualquer any impl√≠cito como erro - quer dizer que ele n√£o sabe qual √© aquele tipo e precisa saber.

* unknown

Muitas vezes, ao consumir APIs externas, por exemplo, n√£o se sabe qual tipo de valor ser√° retornado. Nesses casos, usar o tipo any poderia parecer uma escolha natural, mas o TypeScript oferece uma alternativa mais segura: o unknown!

Ao contr√°rio do any, aqui voc√™ est√° dizendo ‚Äúeu n√£o sei qual √© o tipo desse valor, mas me importo bastante com isso‚Äù! Desse modo, o compilador obrigar√° voc√™ a determinar o tipo de qualquer valor unknown antes de us√°-lo, o que garante tipagem mais segura para sua aplica√ß√£o.

O pr√≥ximo passo, ent√£o, √© como dizer ao TypeScript qual o tipo de uma vari√°vel!

* Vari√°veis
Para fazer anota√ß√µes de tipo em vari√°veis, voc√™ precisa apenas colocar : ap√≥s o nome da vari√°vel e, em seguida, escrever seu tipo. Por exemplo:

EX:

const firstName: string = "Joel";
const age: number = 38;
const brazilian: boolean = false;

* Fun√ß√µes
Quando se tratam de fun√ß√µes, h√° valores de entrada (par√¢metros) e sa√≠da (retorno) para tipar! √â importante explicitar, sobretudo, o tipo dos valores de entrada, pois uma fun√ß√£o pode ser chamada com qualquer valor e, por isso, o TypeScript n√£o consegue inferir seu tipo durante a compila√ß√£o.

Exemplo de anota√ß√£o de tipo em par√¢metros:

EX:

function greet(name: string) {
  console.log(`Ol√°, ${name.toUpperCase()}!`);
}

Se voc√™ executar a fun√ß√£o acima no Typescript Playground usando uma string como argumento, ver√° que tudo funcionar√° perfeitamente. No entanto, se voc√™ tentar passar um n√∫mero, por exemplo, receber√° o erro ‚ÄúArgument of type ‚Äònumber‚Äô is not assignable to parameter of type ‚Äòstring‚Äô.‚Äù.

Exemplo de anota√ß√£o de tipo em retornos:

EX:

function getFavoriteNumber(): number {
  return 26;
}

* Agora, talvez voc√™ esteja se perguntando:

‚ÄúCerto, mas e quando a fun√ß√£o n√£o retorna nenhum valor?‚Äù ü§î

Nesse caso, o tipo de retorno ser√° void!

A fun√ß√£o greet, apresentada acima, √© um exemplo de fun√ß√£o que n√£o tem um valor de retorno, pois apenas imprime algo no console. Vamos tipar seu retorno explicitamente:

EX:

function greet(name: string): void {
  console.log(`Ol√°, ${name.toUpperCase()}!`);
}

Anota a√≠ üìù: A anota√ß√£o de tipo em retornos aparece ap√≥s a lista de par√¢metros da fun√ß√£o.

Como ocorre com as vari√°veis, a especifica√ß√£o de tipo do retorno n√£o √© sempre necess√°ria, pois o TypeScript pode inferir o tipo do retorno com base nas declara√ß√µes de retorno da pr√≥pria fun√ß√£o. No caso do exemplo acima, se voc√™ remover o tipo do retorno, o TS vai inferir que o retorno √© void, uma vez que n√£o h√° nenhum valor retornado.

Algumas bases de c√≥digo v√£o preferir explicitar sempre todos os tipos, sejam de retorno ou outros valores, para fins de documenta√ß√£o, a fim de prevenir altera√ß√µes acidentais ou mesmo por prefer√™ncias pessoais. O princ√≠pio ‚ÄúExpl√≠cito √© melhor que impl√≠cito‚Äù √© adotado por muitas organiza√ß√µes.

* Que erros a tipagem previne?
Conforme mencionado anteriormente, a tipagem est√°tica pode prevenir alguns erros de forma mais eficiente do que documenta√ß√£o ou testes automatizados. Para ilustrar esse ponto, considere o seguinte c√≥digo em JavaScript:

EX:

let sum = (a, b) => a + b
sum(1, '2')

A tipagem est√°tica impede o erro de acontecer. No JavaScript, a fun√ß√£o acima retorna '12', e cabe a voc√™ descobrir, depois de algo explodir em algum lugar l√° na frente, que o problema era aqui.

üí≠ Pare e reflita: voc√™ j√° viveu uma situa√ß√£o onde a tipagem est√°tica de valores teria evitado horas de trabalho desperdi√ßadas?

* Listas e objetos
Comumente, arrays (listas) e objetos s√£o utilizados em c√≥digos JavaScript. Em TypeScript, n√£o ser√° diferente. Como voc√™ pode tip√°-los?

* object type
Em TypeScript, o tipo objeto √© basicamente qualquer valor que n√£o seja um tipo primitivo (string, number, bigint, boolean, symbol, null, ou undefined) e que tenha propriedades. Para tipar um objeto, √© necess√°rio apenas listar suas propriedades e seus tipos, como no exemplo a seguir.

EX:

function printPersonalInfo(data: { name: string; birthYear: number }) {
  console.log(`${data.name} was born in ${data.birthYear}.`);
}
printPersonalInfo({ name: 'Rogerinho', birthYear: 1978 });
De olho na dica üëÄ: Voc√™ pode usar tanto v√≠rgula quanto ponto e v√≠rgula para separar propriedades escritas em uma s√≥ linha.

Voc√™ n√£o precisa tipar cada propriedade, mas, caso voc√™ n√£o o fa√ßa, o TypeScript assumir√° que elas s√£o do tipo any.

Voc√™ lembra qual problema isso pode causar? ü§î Vai ferir uma configura√ß√£o, que j√° comentamos, chamada noImplicitAny! Caso voc√™ cometa esse erro no futuro, lembre-se de que n√≥s avisamos! üòú

* Tamb√©m, √© poss√≠vel especificar o tipo dos elementos de um array, o que √© tipar o array em si. Para isso, basta inserir os colchetes depois do tipo dos elementos do array:

EX:

const evenNumbers: number[] = [2, 4, 6];
const vowel: string[] = ['a', 'e', 'i', 'o', 'u'];
const booleanValues: boolean[] = [true, false];

* Portanto, n√£o √© poss√≠vel adicionar novos elementos a um array se eles n√£o corresponderem aos tipos previamente determinados.

EX:

evenNumbers.push(8) // Funciona
evenNumbers.push('8') // Erro

Outra sintaxe poss√≠vel para fazer a mesma tipagem √© Array<number>. Voc√™ estudar√° mais a respeito dessa sintaxe quando estiver no conte√∫do sobre Generics! üòâ

* Combina√ß√£o de tipos
At√© o momento, foi visto como tipar vari√°veis, par√¢metros e retorno de fun√ß√µes com tipos. Contudo, no JavaScript, temos l√≥gicas em que vari√°veis que precisam receber tipos de valores diferentes. Para esses casos, o TypeScript tamb√©m tem solu√ß√£o.

* Union Types
Essa estrutura √© formada por dois ou mais tipos que podem ser atribu√≠dos √†quele dado:

EX:

function printId(id: number | string) {
  console.log(`Your ID is: ${id}`);
}

printId(101);
printId("202");

No Typescript Playground, chame a fun√ß√£o acima com um n√∫mero ou uma string como argumento. Note que tudo funcionar√° perfeitamente. Contudo, se tent√°ssemos chamar a fun√ß√£o com um argumento boolean, um erro seria disparado. Fa√ßa o teste!

Aten√ß√£o! Em casos assim, voc√™ n√£o pode chamar na vari√°vel um m√©todo que n√£o existe para todos os tipos que ela pode ter. Um exemplo √© o toUpperCase(), que √© um m√©todo do tipo string e n√£o existe no tipo number. Para o id acima, chamar o toUpperCase() resultar√° em erro.

EX:

function printId(id: number | string) {
  console.log(id.toUpperCase());
}

printId(101);

Execute esse exemplo no TS Playground e veja o que acontece.

* No entanto, se voc√™ ainda precisar chamar um m√©todo assim, basta verificar o tipo do valor antes da chamada. Desse modo, vai funcionar.

EX:

function printId(id: number | string) {
  if (typeof id === "string") {
    return console.log(id.toUpperCase());
  }
  return console.log(id);
}

printId(101);

* Type Aliases
Olha quanta coisa voc√™ j√° consegue fazer s√≥ com as anota√ß√µes de tipo! Legal demais, n√©?! ü§©

E no caso de haver v√°rios elementos que voc√™ precisa tipar da mesma forma? Ser√° necess√°rio continuar especificando o tipo em cada um deles ou h√° modos melhores de fazer isso? ü§î

Falaremos disso agora!

* Type Alias √© um modo de reunirmos alguns tipos espec√≠ficos e cham√°-los por um ‚Äúapelido‚Äù. Para isso, utiliza-se a seguinte sintaxe:

EX:

type PersonalInfo = {
  name: string;
  birthYear: number;
};

* Agora, voc√™ pode utilizar o tipo criado para definir os par√¢metros da fun√ß√£o printPersonalInfo (criada anteriormente na li√ß√£o sobre type annotations):

EX:

function printPersonalInfo(data: PersonalInfo) {
  console.log(`${data.name} was born in ${data.birthYear}.`);
}

printPersonalInfo({ name: 'Rogerinho', birthYear: 1978});

* Voc√™ pode usar type aliases para dar ‚Äúapelidos‚Äù a quaisquer tipos que voc√™ queira, utilizando inclusive uni√£o de tipos para isso. Por exemplo:

EX:

type PersonalInfo = {
  name: string;
  birthYear: number | string;
};

Outro exemplo:

EX:

type ID = number | string;

* Type Annotation vs Infer√™ncia de tipos
Agora que voc√™ j√° sabe como fazer anota√ß√µes de tipo e j√° viu que nem sempre √© necess√°rio explicitar essa informa√ß√£o, talvez tenha surgido a seguinte d√∫vida: ‚ÄúAfinal, quando usar type annotations e quando deixar o TypeScript inferir um tipo?‚Äù

Em linhas gerais, √© poss√≠vel saber qual √© o tipo simplesmente lendo a linha, sem precisar explicit√°-lo. Isso s√≥ deixaria o c√≥digo mais verboso e n√£o melhoraria a legibilidade. Portanto, √© desnecess√°rio tipar vari√°veis e objetos simples, com valores inicializados como string, number ou boolean, por exemplo.

Por outro lado, quando trabalhar com valores complexos, como objetos e fun√ß√µes, fa√ßa anota√ß√µes de tipos. Como j√° mencionado, retornos de fun√ß√µes s√£o valores importantes de serem tipados, a fim de certificar-se de que ele ser√° o que voc√™ determinou. Al√©m disso, na constru√ß√£o de APIs p√∫blicas, tipar os valores de entrada e de sa√≠da de fun√ß√µes pode ajudar outras pessoas a entender como utilizar sua API corretamente.

* O objeto abaixo cont√©m um exemplo de valores facilmente inferidos pelo TypeScript e, portanto, √© desnecess√°rio fazer anota√ß√µes.

EX:

const person = {
  fistName: 'Frodo',
  lastName: 'Baggins',
  age: 52,
}

console.log(typeof person.fistName); // "string"

* Primeiro programa em TypeScript
Finalmente chegou o momento de voc√™ escrever seu primeiro programa, do zero, utilizando o TypeScript e rodando em sua m√°quina!

üé¨ Caso voc√™ prefira consumir o conte√∫do em v√≠deo, ele est√° dispon√≠vel no final desta li√ß√£o! üòâ

* Configura√ß√£o inicial (setup)
Crie um diret√≥rio chamado aprendendo-ts. Nele, voc√™ vai inicializar seu projeto TypeScript.

EX:

mkdir aprendendo-ts && cd aprendendo-ts

* A seguir, voc√™ vai inicializar seu projeto Node e instalar o TypeScript, o ts-node e o m√≥dulo npm com a configura√ß√£o base do tsconfig para o Node 16 (ou superior).

EX:

npm init -y
Copiar
npm install -D ts-node typescript@4.4

* A pr√≥xima etapa √© criar o arquivo tsconfig.json:

EX:

tsc --init

* Garanta que seu arquivo tsconfig.json tenha as seguintes configura√ß√µes:

EX:

{
  "compilerOptions": {
    "target": "es2016",                                 
    "module": "commonjs",
    "rootDir": "./",
    "outDir": "./dist",
    "preserveConstEnums": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}

* Agora, instale o pacote npm com as defini√ß√µes de tipos para o Node.js.

EX:

npm install -D @types/node@16.11

* Projeto GitHub Rockstars
Voc√™ recebeu a miss√£o de fazer uma pequena aplica√ß√£o para ajudar no recrutamento de pessoas desenvolvedoras! Com base em uma lista est√°tica de perfis do GitHub, dever√£o ser extra√≠das algumas informa√ß√µes:

Listar todas as pessoas.
Filtrar pessoas com base em determinada quantidade de reposit√≥rios.
Descobrir se uma pessoa √© a mais ativa da lista.

* Para come√ßar, crie sua estrutura de diret√≥rios:

EX:

mkdir src && cd src
mkdir types && touch types/User.ts
touch data.ts myFunctions.ts index.ts 

O diret√≥rio types concentrar√° todos os type aliases utilizados no projeto. A princ√≠pio, voc√™ ter√° apenas um para User. Os arquivos data.ts, myFunctions.ts e index.ts conter√£o, respectivamente, a lista est√°tica de perfis, as fun√ß√µes que a aplica√ß√£o deve fazer e as chamadas dessas fun√ß√µes.

* Ap√≥s a execu√ß√£o dos comandos acima, a estrutura de arquivos e diret√≥rios do seu projeto ser√° assim:

EX:

.
‚îî‚îÄ‚îÄ aprendendo-ts/
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ data.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ myFunctions.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ types/
    ‚îÇ       ‚îî‚îÄ‚îÄ User.ts
    ‚îî‚îÄ‚îÄ package-lock.json
    ‚îî‚îÄ‚îÄ package.json
    ‚îî‚îÄ‚îÄ tsconfig.json
    ‚îî‚îÄ‚îÄ node_modules
    
* Implementa√ß√£o
Com tudo devidamente configurado, voc√™ vai iniciar a implementa√ß√£o de seu c√≥digo, lembrando-se de que suas fun√ß√µes utilizam uma lista de perfis do GitHub para fazer as opera√ß√µes. Desse modo, o primeiro passo ser√° definir um type alias para as propriedades que cada perfil da lista deve ter, que s√£o nome, URL do perfil e quantidade de reposit√≥rios.

Como este √© o tipo principal utilizado em toda a sua aplica√ß√£o, √© essencial se lembrar de export√°-lo! üòâ

EX:

// ./src/types/User.ts

export type User = {
  id: string | number;
  name: string;
  profileURL: string;
  repositories: number;
};

* Agora, voc√™ pode criar sua lista definida com o tipo User.

Note que j√° voc√™ precisar√° importar o type alias criado h√° pouco!

EX:

// ./src/data.ts

import { User } from './types/User';

const users: User[] = [
  {
    id: 1,
    name: 'Jo√£o Paulo Aramuni',
    profileURL: 'https://github.com/joaopauloaramuni',
    repositories: 19,
  },
  {
    id: '2',
    name: 'Rafaella Ballerini',
    profileURL: 'https://github.com/rafaballerini',
    repositories: 47,
  },
  {
    id: 3,
    name: 'Capi Etheriel',
    profileURL: 'https://github.com/barraponto',
    repositories: 340,
  },
];

export default users;

* Com esses dois arquivos de base feitos, inicie a escrita de suas fun√ß√µes! üòé

Sua primeira fun√ß√£o receber√° uma lista de perfis do GitHub, como a definida no arquivo data.ts, e retornar√° uma lista contendo apenas os valores da propriedade name:

Lembre-se de que, para usar o tipo User, √© necess√°rio import√°-lo neste arquivo.

O linter ir√° sugerir utilizar o export default, mas a partir do momento que adicionarmos as novas fun√ß√µes, esse aviso sumir√°!

EX:

// ./src/myFunctions.ts

import { User } from './types/User';

export const getUserNames = (userList: User[]): string[] => userList.map((user: User) => user.name);

* A segunda fun√ß√£o receber√° uma lista do tipo User e um n√∫mero. Al√©m disso, ela verificar√° quais perfis da lista recebida t√™m, no m√≠nimo, o n√∫mero de reposit√≥rios igual ao do passado como argumento, retornando uma lista com os perfis que satisfizerem a verifica√ß√£o.

EX:

// ./src/myFunctions.ts

// ...

export const getUsersByRepoQuantity = (users: User[], repos: number): string[] => users
  .filter((user) => user.repositories >= repos).map((user) => user.name);
  
* Por fim, haver√° uma fun√ß√£o que ser√° respons√°vel por verificar se uma pessoa √© a mais ativa da lista de usu√°rias do GitHub. Essa valida√ß√£o ser√° feita com base na compara√ß√£o da quantidade de reposit√≥rios que cada pessoa possui. Ser√° considerada a pessoa mais ativa, neste exemplo, a que tiver o maior n√∫mero de reposit√≥rios. Por isso, a fun√ß√£o receber√° o nome de uma pessoa do tipo User e uma lista, tamb√©m do tipo User, em que a pessoa esteja inclu√≠da. O retorno da fun√ß√£o deve ser um boolean (true ou false).

EX:

// ./src/myFunctions.ts

// ...

export const IsMostActiveUser = (name: string, users: User[]): boolean => {
  const mostActiveUser = users.reduce(
    (prev, curr) => 
      (prev.repositories > curr.repositories ? prev : curr),
  );
  return mostActiveUser.name === name;
};

Utilizando as fun√ß√µes criadas

* A primeira parte do trabalho est√° feita, mas agora voc√™ precisa fazer algumas chamadas para as fun√ß√µes criadas, a fim de testar se tudo est√° funcionando corretamente. Fa√ßa essas chamadas no arquivo index.ts.

EX:

// ./index.ts

import * as Functions from './myFunctions';
import users from './data';

console.log(`Lista de pessoas usu√°rias do Github: ${Functions.getUserNames(users)}.`);

console.log(
  `Pessoas com pelo menos 20 reposit√≥rios: ${Functions.getUsersByRepoQuantity(users, 20)}.`,
);

console.log(
  `Essa √© a conta mais ativa da lista? ${Functions.IsMostActiveUser('Jo√£o Paulo Aramuni', users)}.`,
);

* Em seguida, execute seu programa com o ts-node:

EX:

ts-node index.ts
A sa√≠da esperada √©:

EX:

Lista de pessoas usu√°rias do GitHub: Jo√£o Paulo Aramuni, Rafaella Ballerini, Capi Etheriel.
Pessoas com pelo menos 20 reposit√≥rios: Rafaella Ballerini, Capi Etheriel.
Essa √© a conta mais ativa da lista? false.



