# Recursividade:

* Defini√ß√£o de recursividade

Durante seu cotidiano enquanto pessoa programadora, ser√° demandado que voc√™ resolva problemas. Dito isso, podemos utilizar o m√©todo da recursividade para a resolu√ß√£o de problemas grandes.

Anota a√≠ üñä: Uma fun√ß√£o que chama a si mesma √© chamada de recursiva. O processo para executar tal fun√ß√£o recursiva √© chamado de recursividade.

Um problema submetido a uma solu√ß√£o recursiva, ser√° quebrado em subproblemas menores at√© chegar a tal ponto que torna-se poss√≠vel solucion√°-lo trivialmente. Podemos fazer a analogia com as chamadas bonecas russas, que dentro de si tem diversas outras bonecas, cada vez menores.

A fun√ß√£o countdown abaixo tem como objetivo fazer uma contagem regressiva partindo de n at√© zero.

EX:

def countdown(n):
    print(n)
    countdown(n - 1)  # chamada recursiva

countdown(5)

Observe que dentro da implementa√ß√£o desta solu√ß√£o, a fun√ß√£o chama ela mesma.

Voc√™ pode estar se perguntando: ‚ÄúO que √© isso!? ‚Äú ü§î

Resposta: Isso √© uma chamada recursiva! Lembre-se que a recurs√£o √© quando uma fun√ß√£o chama ela mesma. Se voc√™ executar esse c√≥digo, ele ficar√° em loop infinito!

‚ö†Ô∏è Aviso: Caso tenha executado o c√≥digo anterior, aperte Ctrl+C para parar a execu√ß√£o.

Quando estamos escrevendo uma fun√ß√£o recursiva, precisamos informar nossa condi√ß√£o de parada ou caso base da recurs√£o. Nesse sentido, podemos separar uma fun√ß√£o recursiva em:

Caso base e Caso recursivo
O caso recursivo √© a chamada da pr√≥pria fun√ß√£o novamente.

Ent√£o, como seria a corre√ß√£o desse c√≥digo para que ele funcione de acordo com esperado?ü§î Observe a resposta abaixo:

EX:

def countdown(n):
    if n == 0: # caso base
        print("FIM!")
    else:
        print(n)
        countdown(n - 1) # caso recursivo

countdown(5)

Pronto! Agora a fun√ß√£o funciona corretamente!

Anota a√≠ üñä:

Se n √© igual a 0, escreva ‚ÄúFIM!‚Äù

Se n n√£o for igual a 0, escreva n e chame a fun√ß√£o novamente com n - 1

Como vimos acima, n√£o podemos construir um c√≥digo recursivo sem validar algumas condi√ß√µes. Sendo assim, vamos a tr√™s leis importantes:

1) Um algoritmo recursivo deve ter um caso base: quando falamos de recurs√£o, devemos sempre lembrar do caso base, pois sem ele nosso algoritmo ficar√° executando infinitamente.

O caso base √© a condi√ß√£o de parada do algoritmo recursivo, ele √© o menor subproblema do problema, tornando-o poss√≠vel de resolver de forma direta/trivial;

2) Um algoritmo recursivo deve mudar o seu estado e se aproximar do caso base: ap√≥s o in√≠cio da execu√ß√£o de um algoritmo recursivo, a cada nova chamada a ele mesmo, o seu estado deve se aproximar progressivamente do caso base.

Vamos imaginar a seguinte situa√ß√£o: queremos criar um c√≥digo que ir√° printar n√∫meros a partir de 0 e terminar em 10. O caso base do algoritmo √© 10, pois √© onde nossa fun√ß√£o recursiva deve parar a execu√ß√£o. A primeira chamada a fun√ß√£o ter√° o n√∫mero 0 passado de par√¢metro. A cada nova chamada √† fun√ß√£o, nosso estado deve incrementar o valor 1 ao valor do estado anterior, at√© chegar ao n√∫mero 10. Logo, o valor do estado na primeira chamada ser√° 0, na segunda chamada ser√° 1, na terceira chamada ser√° 2, e assim por diante at√© chegar ao valor do caso base;

3) Um algoritmo recursivo deve chamar a si mesmo, recursivamente: Essa lei √© a pr√≥pria defini√ß√£o de recurs√£o.


* Entendendo recursividade e colocando em pr√°tica

Antes de vermos como acontece a ‚Äúm√°gica‚Äù da recursividade, vamos ver como costuma ser uma estrutura b√°sica de uma fun√ß√£o recursiva:

EX:

Nome da fun√ß√£o e par√¢metro:
    Condi√ß√£o de parada

    Chamada de si mesma
    
Declaramos uma fun√ß√£o com um par√¢metro.

Dentro da fun√ß√£o criada, definimos qual √© a condi√ß√£o de parada da fun√ß√£o.
A condi√ß√£o de parada faz uma compara√ß√£o entre o valor da condi√ß√£o com o par√¢metro que a fun√ß√£o est√° recebendo. Caso a condi√ß√£o n√£o se satisfa√ßa, a fun√ß√£o √© chamada novamente com um novo par√¢metro. Caso contr√°rio a execu√ß√£o para na condi√ß√£o de parada.
Vamos ver como isso acontece na pr√°tica ? Mas antes, voc√™ se lembra das suas aulas de matem√°tica em que aprendeu sobre fatorial?

Voc√™ sabia que a fatorial √© uma fun√ß√£o recursiva? Vamos relembrar:

Fatorial de n √© o produto dos n√∫meros positivos consecutivos menores ou iguais a n.

Sua nota√ß√£o √©: n!

Sua defini√ß√£o:

0! = 1

n! = n x (n - 1) x (n - 2) ‚Ä¶ 2 x 1

Exemplo:

5! = 5 x 4 x 3 x 2 x 1 = 120

Certo! Agora que relembramos fatorial, vamos observar sua estrutura:

Se

5! = 5 x 4 x 3 x 2 x 1
e

4! = 4 x 3 x 2 x 1
Podemos reescrever 5! como 5! = 5 x 4!

Observando esse caso, vemos que a fun√ß√£o 5! possui uma chamada de outra fun√ß√£o fatorial dentro dela. Logo, temos uma recurs√£o!

Vamos escrever um c√≥digo para resolv√™-lo?

EX:

def factorial(n):
    if n <= 1: # caso base
        return 1
    else:
        return n * factorial(n - 1) # caso recursivo
        
O c√≥digo acima funciona da seguinte maneira:

A fun√ß√£o se chama recursivamente at√© chegar no caso base onde n √© igual a 1.

Voc√™ pode estar se perguntando: ‚Äú Mas por qu√™?‚Äù ü§î

Resposta: lembra da defini√ß√£o de fatorial? 0! √© 1, certo? 1! tamb√©m ser√° 1. Ent√£o o tornaremos como caso base. Quando a fun√ß√£o chegar no caso base, ela retornar√° 1 para a chamada anterior e far√° a multiplica√ß√£o com o n daquele contexto, que nesse caso ser√° o 2. Em outras palavras, quando a chamada retornar da recurs√£o acontecer√° return 2 * 1. Esse valor tamb√©m ser√° retornado para a fun√ß√£o que o chamou e assim acontecer√° at√© que todos os casos sejam satisfeitos.


* A pilha de chamadas:

Antes de falarmos sobre a pilha de chamadas, precisamos entender um pouco a estrutura de dados chamada Pilha. Para isso, vamos a uma breve introdu√ß√£o sobre seu conceito.

Imagine um conjunto de pratos que est√£o um sobre o outro, ou seja, empilhados. Quando queremos pegar um prato, vamos pegar o do topo da pilha, certo? Em outro momento, se voc√™ quiser adicionar outro prato √†quela pilha, voc√™ tamb√©m ir√° adicion√°-lo ao topo da pilha.

Logo, podemos observar que uma pilha tem duas a√ß√µes triviais:

Inserir (Push)

Retirar (Pop)

E todas essas a√ß√µes s√£o efetuadas no topo da pilha.

Push e pop na Pilha
Push e pop na Pilha.

Pois bem, a nossa pilha de chamadas funciona da mesma forma! Vamos conhec√™-la?

A pilha de chamadas,tamb√©m conhecida como call stack, organiza as sub-rotinas que est√£o executando no computador. Trazendo para o nosso contexto de recursividade, a pilha de chamadas registra a execu√ß√£o das fun√ß√µes, ou seja, qual est√° sendo executada, em que ponto ela deve retornar, qual √© a proxima a ser chamada, etc.

Resumindo, √© como se a pilha de chamadas operasse com contextos. Exemplo:

Uma fun√ß√£o A est√° sendo executada e durante a sua execu√ß√£o ela precisa do resultado do processamento de outra fun√ß√£o B a qual ela chama. Diante disso, a fun√ß√£o A ficar√° aguardando na pilha de chamadas enquanto a fun√ß√£o B executa. Quando B terminar, seu resultado voltar√° para Aque vai continuar sua execu√ß√£o.

Anota a√≠ üñä:

Toda vez que chamamos uma fun√ß√£o em um programa, o sistema operacional reserva mem√≥ria para as vari√°veis e par√¢metros da fun√ß√£o;

Sempre quando uma fun√ß√£o √© executada, ela √© guardada na pilha;

Quando a fun√ß√£o termina de ser executada, ela sai da pilha.

Vamos utilizar esse c√≥digo com recurs√£o e visualizar o funcionamento da pilha de chamadas:

EX:

def saudacao():
    print("Oi")

def despedida():
    print("Tchau")

def init():
    print("Inicio")
    saudacao()
    print("Fim")
    despedida()

init()

Vamos ver outro exemplo? Que tal o nosso fatorialmencionado anteriormente ?

De forma an√°loga, quando factorial √© chamada, um novo dado √© adicionado √† uma pilha. Ser√° adicionado √† pilha todos os valores executados, do 5 ao 1, quando chegamos no caso base. Quando a execu√ß√£o acaba, os dados s√£o retirados da pilha um a um de forma reversa (do 1 ao 5), multiplicando e retornando cada dado, at√© que a pilha esvazie e o processamento finalize.

Vamos praticar os conte√∫do visto at√© aqui por meio do exerc√≠cio!?

Exerc√≠cio de fixa√ß√£o:

Exerc√≠cio: Fa√ßa um algoritmo recursivo de soma. Esse algoritmo deve receber um n√∫mero de par√¢metro e deve somar todos os n√∫meros antecessores a ele.

EX:

def sum(n):
    if n == 0:
        return 0
    else:
        print(n)
        return n + sum(n - 1)
        
        
* Iterativo x Recursivo:

Agora, vamos ver que √© poss√≠vel ter fun√ß√µes tanto recursivas, quanto iterativas para o mesmo problema. Para isso, utilizaremos os exemplos que j√° usamos nesse conte√∫do.

Vamos come√ßar olhando para a fun√ß√£o recursiva de contagem regressiva. Conseguimos montar uma fun√ß√£o iterativa para ela? Sim! Vamos ver como fazer isso:

EX:

def iterative_countdown(n):
    while n > 0:
        print(n)
        n = n - 1
    print("FIM!")

iterative_countdown(5)

Vamos ver agora como fica o c√≥digo iterativo de c√°lculo de fatorial:

EX:

def iterative_factorial(n):
    fact = 1

    for i in range(1, n + 1):
        fact = fact * i

    return fact

iterative_factorial(5)

Como vimos anteriormente, escolher entre uma solu√ß√£o recursiva ou iterativa depende muito do que estamos buscando.

Escolher uma solu√ß√£o recursiva n√£o significa ganho de performance, muito pelo contr√°rio, grande parte das vezes, a solu√ß√£o iterativa ser√° mais perform√°tica.

Escolher a solu√ß√£o recursiva ter√° um ganho na diminui√ß√£o de complexidade do c√≥digo do seu projeto. Aqui, complexidade significa legibilidade. Ou seja, nosso c√≥digo fica mais simples, mais harmonioso, quando utilizamos a recursividade.


* √Årvore de Recurs√£o:

O m√©todo da √°rvore de recurs√£o pode ser utilizado para estimar o custo de um algoritmo. √â um modo de analisarmos seu custo, o que nos ajuda a decidir se tal solu√ß√£o recursiva vale a pena ou n√£o.

Podemos visualizar n√≠vel a n√≠vel da estrutura de um algoritmo recursivo por meio de uma √°rvore recursiva. No final, tem-se a estimativa de tempo do problema.

Vamos ver na pr√°tica como isso acontece:

EX:

def fibonacci(num):  # nome da fun√ß√£o e par√¢metro
    if (num <= 1):  # condi√ß√£o de parada
        return num
    else:
        return fibonacci(num - 2) + fibonacci(num - 1)  # chamada de si mesma com um novo valor
        
No exemplo acima, estamos fazendo um c√≥digo recursivo para c√°lculo de Fibonacci.

Cada n√≥ da √°rvore acima representa o custo da solu√ß√£o de um subproblema. Quando olhamos para a √°rvore como um todo, ou seja, quando expandimos ela, podemos somar todos os custos de cada n√≠vel dessa √°rvore e ent√£o ter√≠amos o resultado total do problema.

O problema come√ßa com apenas um n√≥ e vai decompondo at√© alcan√ßar os casos base, que s√£o as ‚Äúfolhas‚Äù da √°rvore. Folhas s√£o, basicamente, n√≥s da estrutura que n√£o possuem nenhum n√≥ abaixo deles.

Vamos ver agora, de forma interativa, como essa √°rvore chegou a esse resultado passo a passo:

De olho na dicaüëÄ: desenhe todas as recurs√µes do problema at√© chegar aos casos base e some as complexidades! Fique de olho nas propor√ß√µes! Se cada subproblema √© O(n) e voc√™ criou um para cada elemento da sua entrada de tamanho n, voc√™ tem a√≠ uma complexidade O(n * n), ou seja, uma complexidade quadr√°tica. Se, por outro lado, a cada subproblema voc√™ dividiu o tamanho do problema original por dois, voc√™ gerar√° log n subproblemas. Se cada um desses custa O(n), voc√™ teria uma complexidade O(n* log n)

A forma de traduzir a l√≥gica da √°rvore de recurs√£o para uma nota√ß√£o puramente matem√°tica se chama Teorema Mestre! N√£o √© o nosso escopo por agora, ok? Mas fique √† vontade para pesquisar a respeito e nos trazer todas as perguntas, se quiser!


# Estrat√©gias para solu√ß√£o de problemas

Bora ver os tipos de estrat√©gias:

* Iterativa

A solu√ß√£o iterativa √© caracterizada pela repeti√ß√£o de uma determinada opera√ß√£o, procurando resolver algum problema encontrando sucessivas aproxima√ß√µes, a partir de uma suposi√ß√£o inicial.

A ideia nesse tipo de processo √© repetir um determinado c√°lculo v√°rias vezes, obtendo-se a cada repeti√ß√£o, ou itera√ß√£o, um resultado mais preciso que aquele obtido na itera√ß√£o anterior.

A cada itera√ß√£o, utiliza-se o resultado da anterior como par√¢metro de entrada para o c√°lculo seguinte. O resultado √© uma sequ√™ncia de valores aproximados, n√£o exatos, mas que est√£o dentro de uma faixa de erro aceit√°vel.


* For√ßa bruta

A for√ßa bruta, tamb√©m conhecida como tentativa e erro ou busca exaustiva, √© a estrat√©gia mais trivial e intuitiva para solu√ß√£o de problemas. Ela consiste basicamente em enumerar todas as combina√ß√µes poss√≠veis para uma solu√ß√£o e avaliar se satisfazem o problema. Dessa forma, √© poss√≠vel escolher a melhor das solu√ß√µes,mas apesar de trivial, em alguns casos, a for√ßa bruta possui desempenho geralmente ruim.

Vamos exemplificar essa estrat√©gia, solucionando um problema chamado de problema da mochila:

Dada uma mochila com capacidade C, e n objetos com peso (i = 1‚Ä¶n), deve ser poss√≠vel preencher a mochila com o maior peso total, respeitando a capacidade C.

Suponha uma mochila com capacidade de 15kg e objetos de peso 12kg, 2kg, 4kg e 8kg.

Este problema possui mais que uma solu√ß√£o √≥tima, ou seja, possui solu√ß√µes √≥timas equivalentes:

EX:

Uma solu√ß√£o √≥tima: 12kg + 2kg = 14kg;

Outra solu√ß√£o √≥tima: 8kg + 2kg + 4kg = 14kg.

Solu√ß√µes vi√°veis seriam, entre outras:

EX:

- 12kg;

- 2kg;

- 4kg;

- 8kg;

- 2kg + 4kg.

# ...

No caso acima, as solu√ß√µes s√£o vi√°veis, por√©m n√£o s√£o √≥timas. Elas n√£o s√£o √≥timas, pois a mochila est√° sendo preenchida, mas n√£o est√° chegando mais pr√≥ximo poss√≠vel ao peso m√°ximo. Por exemplo, uma das solu√ß√µes que temos acima √© preencher a mochila com um objeto de 2kg apenas, sendo que a mochila suporta 15kg.

Observe mais uma poss√≠vel solu√ß√£o:

EX:

- 12 kg + 4 kg = 16kg.

O caso acima √© invi√°vel, pois o peso m√°ximo que a mochila comporta √© 15kg. Com isso, podemos concluir que o exemplo acima √© invi√°vel, pois ultrapassa os 15kg.

Um m√©todo baseado em tentativa e erro testaria todas as combina√ß√µes entre elementos checando:

Se a solu√ß√£o √© vi√°vel;

Se a solu√ß√£o possui valor melhor que outra encontrada anteriormente.

Para conseguir definir qual seria a melhor solu√ß√£o, todas devem ser enumeradas e registradas, e, ao final, os caminhos que n√£o chegaram a um solu√ß√£o final, devem ser retirados.


* Dividir e conquistar

A estrat√©gia dividir e conquistar, tamb√©m chamada de divis√£o e conquista, consiste em dividir o problema em partes menores, encontrar solu√ß√µes para as partes, e s√≥ ent√£o combinar as solu√ß√µes obtidas em uma solu√ß√£o global.

Usar essa estrat√©gia para resolver problemas, nos quais os subproblemas s√£o vers√µes menores do problema original, geralmente leva √† solu√ß√µes eficientes e harmoniosas, especialmente quando √© utilizado a recursividade.

A estrat√©gia emprega modulariza√ß√£o de programas e frequentemente conduz a um algoritmo simples e eficiente. Esta t√©cnica √© bastante utilizada em desenvolvimento de algoritmos paralelos, onde os subproblemas s√£o tipicamente independentes um dos outros, podendo assim serem resolvidos separadamente.

Anota a√≠ üñä: A modulariza√ß√£o de um programa consiste em dividi-lo em partes funcionais que conversam entre si, tornando o software mais eficiente.

A t√©cnica de Divis√£o e Conquista consistem em tr√™s passos:

Divis√£o: dividir a inst√¢ncia do problema original em duas ou mais inst√¢ncias menores, considerando-as como subproblemas;

Conquista: resolver cada subproblema recursivamente;

Combina√ß√£o: combinar as solu√ß√µes encontradas em cada subproblema, compondo uma solu√ß√£o para o problema original.
