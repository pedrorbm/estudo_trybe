# O que √© hashing em computa√ß√£o:

Para fazer a sua m√°gica, a hashmap utiliza um conceito muito popular em computa√ß√£o: hashing.

Hashing significa transformar um dado em uma representa√ß√£o num√©rica √∫nica. √â atribuir um id para um determinado dado, mas diferente de um id sequencial, a composi√ß√£o do dado influencia diretamente no id gerado. Para isso, precisamos submeter o dado a alguma transforma√ß√£o matem√°tica que considere a sua composi√ß√£o.

Um exemplo do uso de hashing √© a verifica√ß√£o da integridade de downloads. Ao realizar um download, existe a chance desse dado ser corrompido ou at√© mesmo alterado maliciosamente. Como forma de verificar se a c√≥pia que chegou at√© voc√™ √© exatamente a mesma c√≥pia que voc√™ tentou baixar, √© poss√≠vel comparar o resultado do hashing dos dois dados. Se forem iguais, o dado √© igual. Sen√£o, significa que algum detalhe desse dado est√° diferente. A opera√ß√£o matem√°tica se chama hash function e o resultado da opera√ß√£o, no caso da verifica√ß√£o de integridade, √© chamado de checksum (soma de verifica√ß√£o).

Por conferir essa seguran√ßa, o procedimento de hashing tem uso em criptografia, armazenamento de senhas e compress√£o de arquivos, por exemplo. Al√©m disso, √© usado na estrutura de dados hash map como forma de atribuir um endere√ßo √∫nico para cada dado que se deseja armazenar. Nesse caso, vamos chamar o resultado da hash function de address (endere√ßo).

Observa√ß√£o: Os procedimentos de hash utilizados nessa aula n√£o s√£o complexos o suficiente para serem utilizados em procedimentos de seguran√ßa. Busque conte√∫do especializado caso tenha interesse no assunto.


# Hashmap: usando hashing para estruturar dados:

A estrat√©gia de armazenamento de dados da hashmap √© submeter o dado a um procedimento matem√°tico (hash function) para obter um endere√ßo √∫nico onde ela ser√° guardada (address). Na rela√ß√£o chave-valor, o id num√©rico da classe Employee √© a chave e o objeto Employee inteiro √© o valor. A hash function vai ler o valor da chave para definir o endere√ßo do objeto como um todo.

Uma vez obtido o endere√ßo, basta armazenar o dado no local correto. Na imagem abaixo, esse endere√ßo √© o √≠ndice no vetor onde a informa√ß√£o est√° sendo guardada. O local de armazenamento √© comumente chamado de buckets (baldes), que √© onde vamos jogar os dados:

Vamos para a pr√°tica üí™

Lembra do aplicativo que precis√°vamos criar para controlar o cadastro de pessoas que trabalham em uma determinada empresa?

O pr√≥ximo passo no nosso problema √© localizar as informa√ß√µes da pessoa do identificador n√∫mero 14 para corrigir o nome. Para descobrir onde o objeto est√° armazenado, passamos a chave 14 para a mesma hash function, que resultar√° no endere√ßo do objeto. Da√≠, basta fazer as consultas ou atualiza√ß√µes necess√°rias.

Complexidade: Nesse exemplo, a execu√ß√£o da hash function, bem como a opera√ß√£o de acessar o endere√ßo para leitura ou escrita, tem complexidade O(1). Dessa forma, tanto inser√ß√£o como consulta t√™m complexidade constante. Cada dado que entra na hash function sai com seu respectivo endere√ßo. Por isso, hashmaps tamb√©m s√£o conhecidas como tabelas de espalhamento.


* Agora que entendemos bem como funciona o algoritmo de uma hashmap, vamos expressar esses conceitos no c√≥digo e treinar um pouco de implementa√ß√£o. Construiremos em conjunto uma classe hashmap simples, que consegue lidar com chaves num√©ricas no formato int, que √© o caso do nosso exemplo.

Para isso, vamos criar apenas um arquivo para ‚Äúcodarmos‚Äù duas classes que teremos. Crie o arquivo com o nome que preferir e acompanhe o passo a passo.

‚ö†Ô∏èAten√ß√£o: n√£o se esque√ßa de criar e ativar o ambiente isolado!

* class Employee

Para armazenar os dados da pessoa de forma agregada vamos criar a classe Employee:

EX:

class Employee:
    def __init__(self, id_num, name):
        self.id_num = id_num
        self.name = name
        
        
* Hash Function

Considerando que nossa chave s√£o inteiros, vamos usar a opera√ß√£o mod 10, ou resto da divis√£o inteira por 10, para definirmos o √≠ndice onde o dado vai ser armazenado. Cada n√∫mero que entra vai resultar em um endere√ßo de 0 a 9. O valor 10 foi escolhido por n√£o ser muito grande. Tanto a opera√ß√£o mod como o valor 10 s√£o escolhas ilustrativas e s√£o apenas um exemplo.

Vamos inicializar nossa classe HashMap e definir o m√©todo get_address():

EX:

# class Employee:
#     def __init__(self, id_num, name):
#         self.id_num = id_num
#         self.name = name


class HashMap:
    def get_address(self, id_num):
        return id_num % 10
        
        
* Buckets

Como nossa hash function resulta em endere√ßos de 0 a 9, uma lista com 10 posi√ß√µes √© suficiente. Vamos inicializar a lista j√° do tamanho que precisamos, preenchida com None. N√£o podemos preencher com um valor num√©rico, como por exemplo -1, pois isso causaria ambiguidade, afinal, se voc√™ quiser guardar o valor -1, n√£o daria para saber se isso √© o valor ou um indicativo de que o bucket est√° vazio. A lista buckets, √© um atributo da classe HashMap.

EX:

# ...


class HashMap:
    def __init__(self):
        self._buckets = [None for i in range(10)]

    # def get_address(self, id_num):
    #     return id_num % 10


* insert

Para povoar nossa hash, recebemos o objeto, computamos o seu address a partir da chave num√©rica, e armazenamos no local adequado.

EX:

# ...


class HashMap:
    # def __init__(self):
    #     self._buckets = [None for i in range(10)]

    # def get_address(self, id_num):
    #     return id_num % 10

    def insert(self, employee):
        address = self.get_address(employee.id_num)
        self._buckets[address] = employee


* get_value

Para acessar o dado de interesse, passamos a chave. A classe identifica o √≠ndice, onde a refer√™ncia para aquele objeto est√° armazenada, e retorna o valor que estiver no campo name.

EX:

# ...


class HashMap:
    # def __init__(self):
    #     self._buckets = [None for i in range(10)]

    # def get_address(self, id_num):
    #     return id_num % 10

    # def insert(self, employee):
    #     address = self.get_address(employee.id_num)
    #     self._buckets[address] = employee

    def get_value(self, id_num):
        address = self.get_address(id_num)
        return self._buckets[address].name
        
        
* has

Para consultar se uma determinada chave existe dentro da sua hash map, basta calcular o address. Al√©m disso, vamos nos certificar de que o conte√∫do da lista buckets n√£o √© None.

EX:

# ...


class HashMap:
    # def __init__(self):
    #     self._buckets = [None for i in range(10)]

    # def get_address(self, id_num):
    #     return id_num % 10

    # def insert(self, employee):
    #     address = self.get_address(employee.id_num)
    #     self._buckets[address] = employee

    # def get_value(self, id_num):
    #     address = self.get_address(id_num)
    #     return self._buckets[address].name

    def has(self, id_num):
        address = self.get_address(id_num)
        return self._buckets[address] is not None

Pronto! Nossa classe est√° pronta para ser utilizada no problema proposto com inser√ß√£o e consulta em O(1). Por√©m, ela n√£o tem um m√©todo para alterar valores.


# Colis√£o:

Quando duas chaves diferentes resultam no mesmo address
Voc√™ deve ter percebido um problema enorme com a implementa√ß√£o que fizemos: e quando duas chaves diferentes resultam no mesmo _address?_ Um exemplo simples s√£o as chaves 14 e 24. Ambas resultar√£o no address = 4. Esse fen√¥meno √© chamado de colis√£o e existem diversas t√©cnicas para lidar com esse problema. Vamos ver abaixo um pouco mais sobre uma delas.


* Separate Chaining

O jeito mais simples de resolver o problema da colis√£o √© cada bucket segurar uma lista. Da√≠, caso um elemento receba o mesmo endere√ßo, basta adicionar na lista. Isso faz com que cada bucket tenha seu pr√≥prio encadeamento de objetos.

O que ter√≠amos que fazer para alterar essa implementa√ß√£o? A lista buckets n√£o seria mais uma lista. Seria uma lista de listas. A inser√ß√£o, em vez de apenas colocar o objeto no endere√ßo, precisa adicionar √† lista que est√° nesse endere√ßo. Vamos ver como fica a implementa√ß√£o at√© aqui:

EX:

# class Employee:
#     def __init__(self, id_num, name):
#         self.id_num = id_num
#         self.name = name


class HashMap:
    # def __init__(self):
        self._buckets = [[] for i in range(10)]

    # def get_address(self, id_num):
    #     return id_num % 10

    # def insert(self, employee):
        # address = self.get_address(employee.id_num)
        self._buckets[address].append(employee)


# ...

üí° Repare que a inicializa√ß√£o da lista buckets e a forma como inserimos um dado no bucket est√£o um pouco diferentes do que fizemos anteriormente.

Como ficam as fun√ß√µes que precisam localizar o elemento exato? N√£o √© mais poss√≠vel simplesmente resgatar o que estiver no endere√ßo, pois o que est√° no endere√ßo √© uma lista de objetos. Ou seja, teremos que procurar o objeto dentro da lista.


* get_value

Ap√≥s obter o endere√ßo, vamos iterar sobre a lista at√© encontrarmos o item com o id_num procurado e retornar o nome. A mesma l√≥gica pode ser aplicada √†s demais fun√ß√µes e n√£o mostraremos aqui. Implemente-as caso queira treinar mais um pouco. üòâ

EX:

# ...


class HashMap:
    # def __init__(self):
    #     self._buckets = [[] for i in range(10)]

    # def get_address(self, id_num):
    #     return id_num % 10

    # def insert(self, employee):
    #     address = self.get_address(employee.id_num)
    #     self._buckets[address].append(employee)

    def get_value(self, id_num):
        address = self.get_address(id_num)
        for item in self._buckets[address]:
            if item.id_num == id_num:
                return item.name
        return None


# ...


* Complexidade

As inser√ß√µes continuam com complexidade O(1), mas todos os demais m√©todos agora iteram sobre uma lista de tamanho variado. Caso o item de interesse seja a primeira posi√ß√£o (melhor caso), teremos O(1), mas isso raramente vai acontecer na vida real. No pior caso, ser√° o √∫ltimo, resultando em uma complexidade proporcional ao tamanho da lista que est√° naquele endere√ßo, o que √© uma performance pior do que O(1).

‚ö†Ô∏è Com essa nova implementa√ß√£o, a fun√ß√£o update_value(), criada no exerc√≠cio de fixa√ß√£o 2, parar√° de funcionar. Isso acontece, pois, como explicado anteriormente, agora nosso bucket √© uma lista de listas. Dessa forma, se tentarmos atualizar algum valor, da forma antiga, vai dar erro. Para funcionar, ter√≠amos que fazer algumas altera√ß√µes, mas para meios did√°ticos n√£o vamos faz√™-las.

A complexidade n√£o era pra ser O(1)?

Percebemos que a decis√£o de combinar a hash function ‚Äúmod‚Äú com a forma de tratar colis√µes ‚Äúseparate chaining‚Äú, fez com que o acesso √† informa√ß√£o n√£o fosse exatamente O(1). Isso demonstra como a an√°lise de complexidade na vida real √© mais complicada do que na teoria. E o mais importante: demonstra como as decis√µes de implementa√ß√£o de cada estrutura de dados afetam a performance final.


* Open Addressing com Linear Probing

Existem outras t√©cnicas de tratamento de colis√£o, como a Open Addressing, onde o endere√ßo final n√£o √© conhecido e o hashcode √© utilizado apenas para iniciar a busca de um bucket vazio dentro da pr√≥pria lista de buckets. Essa busca por um espa√ßo vazio pode ser feita de diversas maneiras.

Quando a busca por um espa√ßo vazio √© feita olhando um √≠ndice ap√≥s o outro, √© chamada de Linear Probing, mas existem v√°rios outros m√©todos de busca pelo espa√ßo vazio, incluindo c√°lculos matem√°ticos mais complexos para ir ‚Äúsaltando‚Äù de √≠ndice em √≠ndice.

Anote a√≠: üìù

As decis√µes de implementa√ß√£o que precisamos tomar enquanto pessoas desenvolvedoras normalmente s√£o bem complexas e alvo de discuss√µes t√©cnicas, na tentativa de estabelecer as melhores combina√ß√µes. Mas n√£o se engane, quase nunca existe uma solu√ß√£o geral, do tipo one-size-fits-all, a famosa ‚Äúbala de prata‚Äù. Geralmente a melhor decis√£o depende do uso que voc√™ quer fazer da estrutura, restri√ß√µes de recurso computacional (tempo ou espa√ßo de mem√≥ria) e as caracter√≠sticas do dado a ser armazenado.

√â por isso que as linguagens geralmente fazem esse trabalho por voc√™ e te fornecem uma implementa√ß√£o pronta da estrutura de dados, com as melhores decis√µes que a equipe da linguagem tomou at√© agora. Em Python, a classe Dict implementa a hashmap. Em Java, existem duas classes com decis√µes diferentes de implementa√ß√£o: HashMap e HashTable.

Como pessoa desenvolvedora, √© importante que voc√™ saiba como a sua linguagem implementa a estrutura, assim √© poss√≠vel entender a real complexidade do seu c√≥digo. Muitas vezes temos recurso computacional suficiente para que essas diferen√ßas de implementa√ß√£o n√£o representem um problema. Mas quando lidamos com um volume muito alto de dados, ou quando temos poucos recursos computacionais dispon√≠veis, podemos ter problemas reais que afetam a experi√™ncia da pessoa usu√°ria.


# A classe Dict de Python

Dicion√°rios (Dict) s√£o estruturas de dados do tipo chave-valor que s√£o implementados como hashmaps por baixo dos panos. A combina√ß√£o de hash functions e tratamento de colis√µes do Dict garantem uma complexidade assint√≥tica de O(1) para inser√ß√£o de consulta. S√£o estruturas muito eficientes, vers√°teis e poderosas. O Dict considera verifica√ß√µes importantes como a exist√™ncia de apenas uma chave, bem como fornece diversos m√©todos convenientes para acesso e manipula√ß√£o dos dados.

A sintaxe para utiliza√ß√£o do Dict √© diferente do que usamos na classe HashMap que constru√≠mos. Daqui pra frente, vamos seguir apenas com o uso do Dict de Python, uma vez que √© mais eficiente e segura. Vamos ver como fica o nosso problema do cadastro, implementado com a classe Dict:

EX:

* Instanciando a classe Dict

employee_registry = {}


* Inserindo dados

# objeto[chave] = valor
employee_registry[14] = 'name1'
employee_registry[23] = 'name2'
employee_registry[10] = 'name3'
employee_registry[9] = 'name4'
print(employee_registry)


* Alterando o nome do id 10

# objeto[chave] = novo_valor
employee_registry[10] = 'name30'
print(f"Novo valor do id 10, ap√≥s a atualiza√ß√£o: {employee_registry[10]}")
Para executar o c√≥digo acima voc√™ pode criar um novo arquivo.


* apenas objetos imut√°veis podem ser utilizados como chave, ou seja, apenas aqueles objetos que depois de instanciados n√£o podem ser alterados. Isso varia de linguagem para linguagem. Em Python, os objetos imut√°veis s√£o:

EX:

- int;

- float;

- string;

- tuple;

- range;

- byte;

- frozenset.

üëÄ De olho na dica: n√£o se preocupe se voc√™ n√£o conhece ainda alguns desses objetos. Voc√™ sempre pode consultar na internet se o objeto que voc√™ quer usar como chave √© imut√°vel ou consultar a lista completa de objetos imut√°veis de Python.

* Agora vamos ver a sintaxe para as principais opera√ß√µes.

EX:

* Instancia√ß√£o do objeto vazio

dict1 = {}
dict2 = dict()


* Instancia√ß√£o com preenchimento inicial de dados

dict3 = {1: 'name1', 2: 'name2'}
print(f"Dicion√°rio 1: {dict1}")
print(f"Dicion√°rio 2: {dict2}")
print(f"Dicion√°rio 3: {dict3}")


* Inser√ß√£o e Altera√ß√£o

# Se a chave n√£o existir no dict, uma nova entrada ser√° criada
# Se j√° existir, o valor ser√° sobreposto
dict1[14] = 'name1'
print(f"Novo dicion√°rio 1, p√≥s inser√ß√£o/altera√ß√£o: {dict1}")


* Consulta e Remo√ß√£o

# Se a chave n√£o existir no dict, causa erro
name = dict1[14]
del dict1[14]
print(f"Dicion√°rio 1 p√≥s consulta e dele√ß√£o: {dict1}")

Outros m√©todos para a manipula√ß√£o de dados
Al√©m dessas opera√ß√µes, a classe Dict oferece v√°rios m√©todos convenientes para a manipula√ß√£o dos dados que podem ser consultados na documenta√ß√£o. Consultar a documenta√ß√£o √© uma das formas mais poderosas de se aprender sobre um aspecto da linguagem ou framework que voc√™ est√° utilizando.


# Exemplos de aplica√ß√µes que usam Hashmaps:

* Resolu√ß√£o DNS

Suponha que voc√™ queira acessar um website como o adit. O seu computador deve traduzir adit.io para a forma de um endere√ßo de IP. Para cada website que voc√™ acessar, o endere√ßo dever√° ser traduzido para um endere√ßo de IP.

Nossa, mapear o endere√ßo de um website para um endere√ßo IP? Isso parece o caso perfeito para a utiliza√ß√£o de tabelas hash! Este processo √© chamado de resolu√ß√£o DNS, e as tabelas hash s√£o uma das maneiras pelas quais esta funcionalidade pode ser implementada.


* Cache

Voc√™ j√° conheceu uma crian√ßa bastante curiosa? Que faz in√∫meras perguntas como ‚ÄúO qu√£o distante Marte fica da Terra?‚Äù, ‚ÄúQual a dist√¢ncia at√© a Lua?‚Äù e ‚ÄúQual a dist√¢ncia at√© J√∫piter?‚Äù. A cada pergunta voc√™ precisa pesquisar a resposta e s√≥ ent√£o voc√™ conseguir√° responder n√©? Logo voc√™ ter√° memorizado que a Lua fica a 384.400 km de dist√¢ncia e n√£o precisar√° mais procurar esta resposta. √â desta forma que o cache funciona: os websites lembram dos dados em vez de recalcul√°-los a cada solicita√ß√£o.

Agora pense no site da Trybe: voc√™ sabia que ali todo o conte√∫do √© feito sob medida? Pois √©, todas as vezes que voc√™ acessa a p√°gina betrybe.com, os servidores precisam pensar e selecionar qual conte√∫do √© de seu interesse. Por√©m, se voc√™ n√£o tiver feito login no site da Trybe, ver√° apenas a p√°gina de login, sendo que todas as pessoas ver√£o a mesma p√°gina de login. Ou seja, a Trybe engloba diversas solicita√ß√µes para a mesma informa√ß√£o: ‚ÄúMostre-me a p√°gina inicial quando eu n√£o estiver logado‚Äù. Isso evita que o servidor tenha que pensar como a p√°gina inicial √©, pois ele memoriza como a p√°gina inicial deve ser apresentada e ent√£o a envia para voc√™.

Isso se chama caching, e esta pr√°tica oferece duas vantagens:

Voc√™ recebe a p√°gina da web muito mais rapidamente, da mesma forma que voc√™ memorizou a dist√¢ncia entre a Terra e a Lua. Assim, da pr√≥xima vez que uma crian√ßa perguntar sobre isso, n√£o ser√° necess√°rio pesquisar no Google, pois voc√™ conseguir√° responder instantaneamente.

A Trybe precisa trabalhar menos.

Esta t√©cnica √© uma maneira comum de agilizar as coisas. Todos os grandes sites usam caching, e os dados destes cachings s√£o armazenados em uma tabela hash! A Trybe n√£o est√° s√≥ aplicando o caching na p√°gina de entrada. Ela est√° fazendo cache das p√°ginas Forma√ß√£o, Blog, D√∫vidas e muitas outras. Assim, ela precisa mapear a URL de uma p√°gina e relacion√°-la aos dados da p√°gina.




