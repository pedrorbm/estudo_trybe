# N√≥:

O N√≥ (Node) √© um TAD respons√°vel por conter pelo menos duas coisas:

Um valor (qualquer tipo)
Um ponteiro (para o espa√ßo de mem√≥ria de outro N√≥)

Para simplificar: imagine que uma vari√°vel √© uma gaveta, onde cabe um valor de um determinado tipo. O N√≥, √© como uma gaveta com duas partes: em uma delas cabe um valor, e na outra cabe a localiza√ß√£o de outra gaveta.

Esta segunda parte da gaveta que o N√≥ possui √© chamada de ponteiro, pois ele aponta para outro elemento (outro n√≥). Este ponteiro aponta para o endere√ßo de mem√≥ria onde o pr√≥ximo N√≥ se encontra. Mais especificamente, nesta parte da gaveta h√° o byte exato onde o pr√≥ximo n√≥ est√° alocado na mem√≥ria RAM. Note que este segundo n√≥ tamb√©m ter√° um ponteiro de outro N√≥, e assim sucessivamente quantas vezes quisermos, at√© que o √∫ltimo N√≥ ter√° um ponteiro nulo (null), que n√£o aponta para nada.

Sozinho, um n√≥ n√£o parece ter muito valor, por√©m quando encadeamos ou ligamos v√°rios n√≥s em sequ√™ncia, eles se tornam‚Ä¶. uma lista encadeada!


# Lista Encadeada:

Ligando v√°rios n√≥s encadeados atrav√©s de seus ponteiros, temos uma lista encadeada! Lembrando que cada n√≥ cont√©m um valor al√©m do ponteiro, temos assim uma estrutura capaz de conter uma quantidade indefinida de elementos em sequ√™ncia.

Listas Encadeadas, tamb√©m conhecidas como Listas Ligadas, ou em ingl√™s linked lists, s√£o um Tipo Abstrato de Dados capaz de armazenar elementos de forma sequencial.

Mas a√≠ podem perguntar ‚ÄúU√©, j√° n√£o t√≠nhamos o Array, que faz exatamente a mesma coisa?‚Äú ü§î e a resposta √©: a estrutura faz a mesma coisa, por√©m a ordem de complexidade de suas opera√ß√µes √© bem diferente!

Lembra dos problemas que t√≠nhamos com os Arrays, todo o trabalho que era para redimensionar a estrutura, inserir/remover elementos? ü§î As listas encadeadas simplesmente n√£o possuem alguns destes problemas. Por exemplo, como cada n√≥ que comp√µe a lista tem um endere√ßo de mem√≥ria, n√£o √© necess√°rio alocar todos os elementos da lista de forma sequencial nela, um diretamente seguido do pr√≥ximo, e tamb√©m n√£o precisamos escolher um tamanho inicial para a lista encadeada quando ela √© criada.

Vamos analisar as opera√ß√µes que podem ser feitas em listas, para podermos compar√°-las com estas mesmas opera√ß√µes feitas em Arrays, em quest√µes de velocidade e mem√≥ria utilizada.

‚ñ∂Ô∏è Inicializa√ß√£o: Para o array, precisamos escolher um tamanho inicial. Isto pode ser problem√°tico se n√£o soubermos de antem√£o quantos elementos esta estrutura precisar√° armazenar; estimar errado pode desperdi√ßar mem√≥ria com espa√ßo n√£o utilizado, ou se precisarmos de um array maior vamos ter que criar outro e realocar todos os elementos. J√° para uma lista encadeada, basta criarmos os primeiros elementos. Se n√£o forem adicionados mais, a lista n√£o est√° desperdi√ßando espa√ßo, e caso precisemos de mais itens, basta criar eles em qualquer lugar da mem√≥ria e alterar os ponteiros da lista j√° existente para apontar para os novos elementos, de acordo com a ordem desejada.

‚ñ∂Ô∏è Busca e Acesso: Aqui √© onde o array leva vantagem. No array, sabemos exatamente a posi√ß√£o de cada elemento na mem√≥ria, ent√£o se precisarmos acessar um espec√≠fico (que esteja por exemplo, na metade do array) isso √© trivial; j√° sabemos o endere√ßo. Por√©m, em uma lista encadeada os elementos est√£o espalhados. para buscar o en√©simo n√∫mero da lista, precisamos percorrer os N n√∫meros, buscando ponteiros para achar o pr√≥ximo. Esta opera√ß√£o pode ser mais custosa.

üí° Um detalhe importante √© que, para realizar a inser√ß√£o em uma lista encadeada, tamb√©m precisaremos buscar esta posi√ß√£o. Para saber qual estrutura √© melhor em casos de inser√ß√£o, precisamos somar o custo de busca e de inser√ß√£o. Portanto, para comparar o tempo de inser√ß√£o em arrays com o tempo de inser√ß√£o em listas encadeadas, precisamos levar em considera√ß√£o tamb√©m o tempo de busca em cada uma destas estruturas, de forma a termos o custo total da opera√ß√£o.

‚ñ∂Ô∏è Inser√ß√£o: Inserir em um array tem tr√™s casos:

O espa√ßo em que queremos inserir est√° vago. Neste caso, a opera√ß√£o √© extremamente simples e r√°pida.
O espa√ßo em que queremos inserir j√° est√° ocupado. Neste caso, vamos precisar mover todos os itens uma posi√ß√£o para frente na mem√≥ria para liberar o espa√ßo desejado. Esta opera√ß√£o custa muito.
O espa√ßo em que queremos inserir n√£o existe no array. neste caso, precisamos criar um array novo, com as novas dimens√µes desejadas, transferir todos os elementos, e ent√£o inserir o novo. Tamb√©m √© bem custoso.
J√° para uma lista encadeada, todas as inser√ß√µes s√£o extremamente r√°pidas. Para inserir no final, apenas criamos um novo n√≥ em qualquer lugar da mem√≥ria e fazemos o √∫ltimo n√≥ da lista apontar para este novo n√≥ que foi criado, fazendo com que este passe a ser o √∫ltimo. Para inserir no come√ßo, ou no meio, n√£o precisamos mover ningu√©m de lugar; criamos o novo n√≥ e ajustamos os ponteiros.

Exemplificando: Supondo que temos uma lista com os n√≥s A e C, sendo que A aponta para C (ou seja, A √© o primeiro elemento, C √© o segundo). Se quisermos inserir um n√≥ B entre o A e o C, primeiramente criamos o novo n√≥ B e fazemos ele apontar para o elemento que A aponta (que neste caso √© o C). Em seguida, fazemos A apontar para B. Pronto. E isto pode ser feito com esta mesma simplicidade em uma lista com milhares de elementos, bastando fazer o novo elemento apontar para o pr√≥ximo, e o anterior apontar para o novo.

LinkedLists n√£o tem as restri√ß√µes de acesso como nas seguintes TADs:

FILA: Acessar apenas o primeiro elemento;

PILHA: Acessar apenas o √∫ltimo elemento;

DEQUE: Acessar apenas as extremidades - Deque.

üí° Ou seja, uma Lista Encadeada possibilita acessar qualquer elemento, sem exce√ß√£o.


# Quais as opera√ß√µes mais comuns:

Ao se manipular uma LinkedList existem algumas opera√ß√µes que s√£o comumente utilizadas:

A opera√ß√£o insert_first nos permite adicionar um Node no in√≠cio da lista;

A opera√ß√£o insert_last nos permite adicionar um Node no final da lista;

A opera√ß√£o insert_at nos permite adicionar um Node em qualquer posi√ß√£o da lista;

A opera√ß√£o remove_first nos permite remover um Node do in√≠cio da lista;

A opera√ß√£o remove_last nos permite remover um Node do final da lista;

A opera√ß√£o remove_at nos permite remover um Node em qualquer posi√ß√£o da lista;

A opera√ß√£o clear nos permite remover todos os Nodes da lista;

A opera√ß√£o get_element_at nos permite visualizar o Node em qualquer posi√ß√£o da lista;

A opera√ß√£o is_empty nos permite identificar se existe ao menos um Node na lista.


# Encadeamento duplo:

As listas encadeadas normais t√™m seus n√≥s ligados por ponteiros em somente uma dire√ß√£o. Mas e se precisarmos, por algum motivo, percorrer a lista tamb√©m no sentido oposto? Nada nos impede de criar ponteiros no sentido oposto tamb√©m, fazendo com que cada n√≥ aponte para o anterior e o pr√≥ximo ao mesmo tempo!

‚úîÔ∏è A vantagem √© termos mais facilidade de percorrer esta lista no sentido oposto. ‚ùå A desvantagem √© ocuparmos mais espa√ßo de mem√≥ria, pois temos uma quantidade maior de ponteiros. Podemos construir nossos n√≥s com mais de um ponteiro, isso possibilita montarmos estruturas diferentes, como as listas duplamente encadeadas, ou √°rvores por exemplo.

O principal motivo da evolu√ß√£o da lista encadeada para a lista duplamente encadeada √© a capacidade de otimiza√ß√£o em opera√ß√µes nas extremidades.

Vimos no conte√∫do anterior que opera√ß√µes a serem realizadas no final como insert_last e remove_last teriam complexidade de O(n). Neste caso, como temos uma forma de guardar a primeira e a √∫ltima posi√ß√£o, podemos obter complexidade O(1), em ambas opera√ß√µes.

Agora que temos refer√™ncias ao come√ßo e ao final da lista, vamos nome√°-los: o primeiro n√≥ da lista se chama HEAD, a cabe√ßa da lista. O √∫ltimo n√≥ da lista se chama TAIL, a cauda da lista. Assim evitamos confundir a qual ponta da lista estamos nos referindo.


# Implementa√ß√£o de um Node:

Primeiro iremos declarar o construtor da classe Node. Em seguida, declararemos a propriedade que indica o pr√≥ximo elemento (next) como tendo o valor, por default, None:

node.py

EX:

class Node:
    def __init__(self, value):
        self.value = value  # üé≤ Dado a ser armazenado
        self.next = None  # üëâ Forma de apontar para outro n√≥

    def __str__(self):
        return f"Node(value={self.value}, next={self.next})"
        

# Implementa√ß√£o de uma LinkedList:

Devemos utilizar a classe criada anteriormente, para criar nossa estrutura da LinkedList:

linked_list_content.py

EX:

from node import Node


class LinkedList:
    def __init__(self):
        self.head_value = None
        self.__length = 0

    def __str__(self):
        return f"LinkedList(len={self.__length}, value={self.head_value})"

    def __len__(self):
        return self.__length
        
üí° Utilizamos o conceito Literal String Interpolation na fun√ß√£o __str__, caso haja d√∫vidas, deem uma olhada na doc do pep-0498.

Agora vamos implementar as opera√ß√µes do LinkedList para entendermos melhor as funcionalidades dessa estrutura de dados.


* Inserir no in√≠cio

Devemos informar que o elemento que estamos inserindo seja o novo head_value:

linked_list_content.py

EX:

# from node import Node


class LinkedList:
    # ...

    def insert_first(self, value):
        first_value = Node(value)
        self.head_value = first_value
        self.__length += 1
        
Caso optemos por inserir o valor 3, teremos o resultado:

EX:

LinkedList(len=1 value=Node(value=3 next=None))

No entanto, seguir essa abordagem faz com que os elementos anteriores sejam sobrepostos pelo novo. Dito isso, devemos indicar que o elemento atual, head_value, ser√° o next do elemento que estamos inserindo.

Resumindo: ‚úèÔ∏è o next ser√° preenchido com o valor que est√° atualmente na head_value, para que o novo valor, que estamos inserindo no in√≠cio da lista, seja preenchido na vari√°vel head_value, se tornando a ‚Äúcabe√ßa‚Äù da lista.

linked_list_content.py

EX:

# from node import Node


class LinkedList:
    # ...

    def insert_first(self, value):
        first_value = Node(value)
        first_value.next = self.head_value
        self.head_value = first_value
        self.__length += 1
        
Desta forma, adicionando o valor 3 e posteriormente o valor 1 teremos o resultado:

EX:

LinkedList(len=2 value=Node(value=1 next=Node(value=3 next=None)))
Inserir no final

* Devemos informar que o elemento que estamos inserindo seja o √∫ltimo na nossa estrutura de cadeia de Nodes:

linked_list_content.py

EX:

# from node import Node


class LinkedList:
    # ...

    def insert_last(self, value):
        last_value = Node(value)
        current_value = self.head_value

        while current_value.next:
            current_value = current_value.next
        current_value.next = last_value
        self.__length += 1
        
Idealmente esta abordagem estaria correta, desde que houvesse ao menos um elemento em nossa estrutura. Por√©m, caso n√£o haja nenhum elemento, o trecho: while current_value.next: causaria o erro: AttributeError: 'NoneType' object has no attribute 'next'.

Isso acontece, pois o head_value ainda n√£o possui valor. Para corrigir essa l√≥gica, podemos utilizar a fun√ß√£o insert_first escrita previamente.

linked_list_content.py

EX:

# from node import Node


class LinkedList:
    # ...

    def insert_last(self, value):
        last_value = Node(value)
        current_value = self.head_value

        # Mais abaixo criaremos o m√©todo is_empty()
        # que substituir√° a condi√ß√£o deste if
        if current_value is None:
            return self.insert_first(value)

        while current_value.next:
            current_value = current_value.next
        current_value.next = last_value
        self.__length += 1
        
Desta forma, adicionando o valor 3 e posteriormente o valor 1 teremos o resultado:

EX:

LinkedList(len=2 value=Node(value=3 next=Node(value=1 next=None)))

Percebam que usamos a vari√°vel auxiliar current_value para percorrer toda a cadeia de Nodes. Isto √© necess√°rio, pois assim n√£o perdemos a refer√™ncia para a cabe√ßa da estrutura, head_value.

* Inserir em qualquer posi√ß√£o

Devemos informar que o elemento que estamos inserindo seja adicionado na posi√ß√£o desejada em nossa estrutura.

üëÄ De olho na dica: a primeira posi√ß√£o, assim como em arrays, ser√° considerada como 0

Levaremos em considera√ß√£o as seguintes observa√ß√µes:

Se o elemento tem a posi√ß√£o inferior a 1, ser√° adicionado na posi√ß√£o inicial, utilizando a fun√ß√£o insert_first;

Se o elemento tem a posi√ß√£o igual ou superior a quantidade de elementos, ser√° adicionado na posi√ß√£o final, utilizando a fun√ß√£o insert_last.

linked_list_content.py

EX:

# from node import Node


class LinkedList:
    # ...

    def insert_at(self, value, position):
        if position < 1:
            return self.insert_first(value)
        if position >= len(self):
            return self.insert_last(value)
        current_value = self.head_value
        while position > 1:
            current_value = current_value.next
            position -= 1
        next_value = Node(value)
        next_value.next = current_value.next
        current_value.next = next_value
        self.__length += 1
        
Desta forma podemos voltar nossos esfor√ßos apenas para a parte que estava ‚Äúdescoberta‚Äù. Ou seja, voltamos a nossa l√≥gica apenas para as posi√ß√µes do meio da nossa estrutura. A l√≥gica √© similar ao inserir no final insert_last, no entanto, n√£o analisamos se existe um pr√≥ximo, mas sim, se o pr√≥ximo √© a posi√ß√£o que queremos inserir o novo valor.

* Remover no in√≠cio

Devemos fazer com que a nossa estrutura remova a ‚Äúcabe√ßa‚Äù, em casos de estrutura vazia, devemos retornar None:

linked_list_content.py

EX:

# from node import Node


class LinkedList:
    # ...

    def remove_first(self):
        value_to_be_removed = self.head_value
        if value_to_be_removed:
            self.head_value = self.head_value.next
            value_to_be_removed.next = None
            self.__length -= 1
        return value_to_be_removed
        
Dessa forma, fazemos com que o elemento next passe a ser o primeiro elemento, j√° que a head_value ir√° referenci√°-lo

* Remover no final

Devemos informar que o elemento que estamos removendo seja o √∫ltimo da nossa estrutura de cadeia de Nodes. Os problemas vistos na sess√£o Inserir no final tamb√©m se aplicam aqui.

Dito isso, caso tenhamos apenas um elemento em nossa estrutura, invocaremos a fun√ß√£o de remo√ß√£o existente, remove_first:

linked_list_content.py

EX:

# from node import Node


class LinkedList:
    # ...

    def remove_last(self):
        if len(self) <= 1:
            return self.remove_first()

        previous_to_be_removed = self.head_value

        while previous_to_be_removed.next.next:
            previous_to_be_removed = previous_to_be_removed.next

        value_to_be_removed = previous_to_be_removed.next
        previous_to_be_removed.next = None
        self.__length -= 1
        return value_to_be_removed
        
üí° Veja que essa fun√ß√£o requer uma aten√ß√£o especial, pois al√©m de uma vari√°vel auxiliar que utilizamos como ponteiro para identificar o Node a ser removido, precisamos ter uma outra vari√°vel para indicar o Node anterior. Desta forma, indicamos que o Node anterior ao √∫ltimo ir√° apontar para None como pr√≥ximo, liberando assim a refer√™ncia ao anteriormente tido como √∫ltimo em nossa estrutura.

* Remover em qualquer posi√ß√£o

exemplo remove qualquer posicao linked list
LinkedList Remove Anywhere
Devemos informar a posi√ß√£o do elemento que desejamos a remo√ß√£o de nossa estrutura.

Levaremos em considera√ß√£o as seguintes observa√ß√µes:

Se o elemento tem a posi√ß√£o inferior a 1, ser√° removido na posi√ß√£o inicial, utilizando a fun√ß√£o remove_first;

Se o elemento tem a posi√ß√£o igual ou superior a quantidade de elementos, ser√° removido na posi√ß√£o final, utilizando a fun√ß√£o remove_last.

linked_list_content.py

EX:

# from node import Node


class LinkedList:
    # ...

    def remove_at(self, position):
        if position < 1:
            return self.remove_first()
        if position >= len(self):
            return self.remove_last()

        previous_to_be_removed = self.head_value
        while position > 1:
            previous_to_be_removed = previous_to_be_removed.next
            position -= 1
        value_to_be_removed = previous_to_be_removed.next
        previous_to_be_removed.next = value_to_be_removed.next
        value_to_be_removed.next = None
        self.__length -= 1
        return value_to_be_removed
        
Desta forma podemos voltar nossos esfor√ßos apenas para a parte que estava ‚Äúdescoberta‚Äù. Ou seja, voltamos a nossa l√≥gica apenas para as posi√ß√µes do meio da nossa estrutura. A l√≥gica √© similar ao remover do final remove_last, no entanto, n√£o analisamos se existe um pr√≥ximo, mas sim, se o pr√≥ximo √© a posi√ß√£o que queremos remover.

* Obter elemento em qualquer posi√ß√£o

Devemos informar a posi√ß√£o do elemento que desejamos visualizar o conte√∫do, esta fun√ß√£o deve retornar uma c√≥pia do Node existente em nossa estrutura.

Levaremos em considera√ß√£o as seguintes observa√ß√µes:

Se o elemento tem a posi√ß√£o inferior a 1, ser√° retornado o conte√∫do da posi√ß√£o inicial;

Se o elemento tem a posi√ß√£o igual ou superior a quantidade de elementos, ser√° retornado o conte√∫do da posi√ß√£o final.

linked_list_content.py

EX:

# from node import Node


class LinkedList:
    # ...

    def get_element_at(self, position):
        value_returned = None
        value_to_be_returned = self.head_value
        if value_to_be_returned:
            while position > 0 and value_to_be_returned.next:
                value_to_be_returned = value_to_be_returned.next
                position -= 1
            if value_to_be_returned:
                value_returned = Node(value_to_be_returned.value)
        return value_returned
        
‚ö†Ô∏è Um ponto de aten√ß√£o para as verifica√ß√µes constantes presentes no c√≥digo, elas indicam que:

Caso n√£o haja elementos em nossa estrutura ser√° retornado None;

Caso a posi√ß√£o seja menor igual a 0, ser√° retornado o primeiro elemento;

Caso a posi√ß√£o seja maior igual a N, onde N √© o tamanho da lista, ser√° retornado o √∫ltimo elemento.

Por fim, retornamos um novo Node com o mesmo valor do existente em nossa estrutura. Isto √© necess√°rio para que retornemos apenas o valor, e n√£o a refer√™ncia aos demais elementos.

* Est√° vazia

Devemos informar se a estrutura est√° vazia, como possu√≠mos um campo length podemos utiliz√°-lo como ponto a ser analisado, afinal se o mesmo for 0 nossa estrutura n√£o possui elementos

linked_list_content.py

EX:

# from node import Node


class LinkedList:
    # ...

    def is_empty(self):
        return not self.__length
        
O uso do not neste contexto nos informa se a estrutura est√° vazia, j√° que not 0 == True.

* Por fim nossa classe ficou assim:

linked_list_content.py

EX:

from node import Node


class LinkedList:

    def __init__(self):
        self.head_value = None
        self.__length = 0

    def __str__(self):
        return f"LinkedList(len={self.__length}, value={self.head_value})"

    def __len__(self):
        return self.__length

    def insert_first(self, value):
        first_value = Node(value)
        first_value.next = self.head_value
        self.head_value = first_value
        self.__length += 1

    def insert_last(self, value):
        last_value = Node(value)
        current_value = self.head_value

        if self.is_empty():
            return self.insert_first(value)

        while current_value.next:
            current_value = current_value.next
        current_value.next = last_value
        self.__length += 1

    def insert_at(self, value, position):
        if position < 1:
            return self.insert_first(value)
        if position >= len(self):
            return self.insert_last(value)
        current_value = self.head_value
        while position > 1:
            current_value = current_value.next
            position -= 1
        next_value = Node(value)
        next_value.next = current_value.next
        current_value.next = next_value
        self.__length += 1

    def remove_first(self):
        value_to_be_removed = self.head_value
        if value_to_be_removed:
            self.head_value = self.head_value.next
            value_to_be_removed.next = None
            self.__length -= 1
        return value_to_be_removed

    def remove_last(self):
        if len(self) <= 1:
            return self.remove_first()

        previous_to_be_removed = self.head_value

        while previous_to_be_removed.next.next:
            previous_to_be_removed = previous_to_be_removed.next

        value_to_be_removed = previous_to_be_removed.next
        previous_to_be_removed.next = None
        self.__length -= 1
        return value_to_be_removed

    def remove_at(self, position):
        if position < 1:
            return self.remove_first()
        if position >= len(self):
            return self.remove_last()

        previous_to_be_removed = self.head_value

        while position > 1:
            previous_to_be_removed = previous_to_be_removed.next
            position -= 1

        value_to_be_removed = previous_to_be_removed.next
        previous_to_be_removed.next = value_to_be_removed.next
        value_to_be_removed.next = None
        self.__length -= 1

        return value_to_be_removed

    def get_element_at(self, position):
        value_returned = None
        value_to_be_returned = self.head_value
        if value_to_be_returned:
            while position > 0 and value_to_be_returned.next:
                value_to_be_returned = value_to_be_returned.next
                position -= 1
            if value_to_be_returned:
                value_returned = Node(value_to_be_returned.value)
        return value_returned

    def is_empty(self):
        return not self.__length


# Para testar, apenas rode o arquivo com: `python3 linked_list_content.py`

if __name__ == "__main__":
    linked_list = LinkedList()

    print(linked_list.is_empty()) # sa√≠da: True
    linked_list.insert_first(1)
    print(linked_list) # sa√≠da: LinkedList(len=1 value=Node(value=1 next=None))

    linked_list.insert_first(2)
    print(linked_list) # sa√≠da: LinkedList(len=2 value=Node(value=2 next=Node(value=1 next=None)))

    linked_list.insert_last(3)
    print(linked_list) # sa√≠da: LinkedList(len=3 value=Node(value=2 next=Node(value=1 next=Node(value=3 next=None))))

    linked_list.remove_last()
    print(linked_list) # sa√≠da: LinkedList(len=2 value=Node(value=2 next=Node(value=1 next=None)))

    linked_list.remove_first()
    print(linked_list) # sa√≠da: LinkedList(len=1 value=Node(value=1 next=None))

    linked_list.insert_at(5, 1)
    print(linked_list) # sa√≠da: LinkedList(len=2 value=Node(value=1 next=Node(value=5 next=None)))

    linked_list.remove_at(0)
    print(linked_list) # sa√≠da: LinkedList(len=1 value=Node(value=5 next=None))

    linked_list.insert_at(6, 1)
    linked_list.insert_at(7, 2)
    linked_list.insert_at(8, 3)
    linked_list.insert_at(9, 4)
    print(linked_list.get_element_at(3)) # sa√≠da: Node(value=8 next=None)





