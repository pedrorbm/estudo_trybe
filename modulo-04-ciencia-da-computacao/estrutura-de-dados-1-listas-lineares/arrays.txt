# Estrutura de Dados: Array:

A implementa√ß√£o concreta de um TAD √© chamada de Estrutura de Dados (ED), e um exemplo de ED √© o Array.

Mas antes de aprofundarmos no Array, vamos ficar na mesma p√°gina sobre o que √© uma ED?

* Estruturas de Dados (EDs)

H√° diversas formas de organizar dados, e cada uma tem diferentes m√©todos de acesso e inser√ß√£o, que podem levar mais ou menos tempo, e ocupam uma quantidade de mem√≥ria diferente. Estas particularidades determinam qual estrutura devemos utilizar para resolver cada problema.

A Estrutura de Dados pode ser implementada de v√°rias maneiras e sua implementa√ß√£o pode variar de linguagem para linguagem, desde que respeite a interface do TAD que est√° implementando (assim como classes abstratas e interfaces, lembra?)

Existem diversas EDs que podem ser usadas para implementar o TAD Lista Linear, veremos algumas de suas vantagens e desvantagens. Neste momento, vamos focar na Estrutura de Dados chamada Array (ou arranjo).

√â prov√°vel que voc√™ j√° conhe√ßa o termo Array em outro contexto. Neste momento, vamos entender a estrutura do Array de forma mais consolidada, ou seja, analisando a complexidade de tempo e espa√ßo para cada uma de suas opera√ß√µes.

* Implementando o TAD Lista Linear com Arrays

Para seguirmos com o entendimento dessa estrutura, vamos apresentar uma implementa√ß√£o do TAD Lista Linear usando Arrays. No caso, vamos utilizar uma list do Python como nosso Array.

‚ö†Ô∏è Importante: O tipo list do Python n√£o √© um Array puro, pois um Array puro somente armazena elementos de um mesmo tipo (e listas no Python n√£o tem essa limita√ß√£o). Mas o tipo list utiliza parte da l√≥gica de Arrays e isso ser√° suficiente para entendermos suas vantagens e desvantagens ‚ò∫Ô∏è

Devemos implementar pelo menos um jeito de recuperar e armazenar um dado atrav√©s do √≠ndice. Para isso, vamos escrever o c√≥digo abaixo:

Nota: Lembre-se de criar e ativar o ambiente isolado.

array_example.py

EX:

"""Perceba que temos uma cole√ß√£o de valores
e opera√ß√µes que atuam sobre estes valores,
de acordo com o que foi definido pelo TAD."""


class ListaArray:
    def __init__(self):
        self.data = []

    def __len__(self):
        # quando pedido o tamanho do array
        # retorne o tamanho de data
        return len(self.data)

    def __str__(self):
        # converte para string e exibe os valores de data
        return str(self.data)

    def get(self, index):
        # recupera o elemento no √≠ndice informado
        return self.data[index]

    def set(self, index, value):
        # insere um elemento no √≠ndice informado
        self.data.insert(index, value)


# vamos inicializar e preencher uma estrutura de dados array
array = ListaArray()
array.set(0, "Felipe")
array.set(1, "Ana")
array.set(2, "Shirley")
array.set(3, "Miguel")

# para acessar um elemento do array, utilizamos seu √≠ndice
print(array.get(0))  # sa√≠da: Felipe
print(array.get(2))  # sa√≠da: Shirley
print("-----")

# podemos iterar sobre seus elementos da seguinte maneira
index = 0
# enquanto h√° elementos no array
while index < len(array):
    # recupera o elemento atrav√©s de um √≠ndice
    print("Index:", index, ", Nome:", array.get(index))
    index += 1
    
Relembrando o problema das notas, como arrays s√£o estruturas eficientes para consultas, podemos buscar um estudante, atrav√©s de um √≠ndice, e percorrer suas notas de uma maneira eficaz. Ainda temos o detalhe de que n√£o ocorrem tantas inser√ß√µes de notas, somente quando um estudante entrar em recupera√ß√£o.

ü§î Mas porque n√£o ter inser√ß√µes √© uma coisa boa?

Vamos entender o que acontece quando inserimos elementos em um array.


# Entendendo a estrutura:

Para entender o que acontece a cada inser√ß√£o na nossa ListaArray, devemos entender o comportamento de uma lista (list), pois √© a base da implementa√ß√£o da nossa estrutura de dados.

array_example.py

EX:

import sys

# class ListaArray:
#     def __init__(self):
#         self.data = []
# ...
# array = ListaArray()

# sys.getsizeof retorna o tamanho da lista em bytes
array_memory_size = sys.getsizeof(array.data)
print(array_memory_size) #  56

# ...

Quando inicializamos nossa estrutura ListaArray e internamente inicializamos uma lista(list) vazia, adicionando alguns itens, um espa√ßo adicional √© reservado para armazenar os itens. O tamanho de cada slot √© baseado no tamanho do tipo que vamos armazenar.

üí° No caso do Python, o ‚Äútipo‚Äù que fica armazenado √© apenas o endere√ßo de mem√≥ria de cada objeto. √â assim que a classe list consegue armazenar elementos de diversos tipos sem se preocupar com o tamanho de cada objeto armazenado.

Vamos inserir alguns itens e comparar o resultado.

array_example.py

EX:

# ...

array.set(0, "Marcos")
array.set(1, "Patr√≠cia")
# quando come√ßamos as inser√ß√µes o valor muda
array_memory_size = sys.getsizeof(array.data)
print(array_memory_size)  # 88

array.set(2, "Matheus")
array.set(3, "Giovana")
# como um espa√ßo adicional √© reservado o valor n√£o √© modificado
array_memory_size = sys.getsizeof(array.data)
print(array_memory_size) # 88

Inserimos mais alguns valores e vamos ver o que acontece.

array_example.py

EX:

# ...

array.set(4, "Alberto")
array.set(5, "Marta")
array.set(6, "T√∫lio")
array.set(7, "Michelle")
array_memory_size = sys.getsizeof(array.data)
print(array_memory_size) # 120

Agora notamos que a lista cresceu de tamanho √† medida que adicionamos novos itens. De acordo com a documenta√ß√£o da linguagem Python, a cada vez que um elemento √© inserido, a lista cresce o seu tamanho em 1.125.

Embora √† primeira vista pare√ßa que a estrutura apenas aloca mais espa√ßos em mem√≥ria e adiciona novos itens, o que acontece na verdade √© que, quando h√° um crescimento, um novo endere√ßo na mem√≥ria √© reservado para uma nova lista. Em seguida, os elementos s√£o copiados da lista original para a nova, e ent√£o o novo elemento √© adicionado ao espa√ßo de mem√≥ria da nova lista.

Para ajudar a compreens√£o, vamos ver isto de uma forma um pouco mais visual.

EX:

# Supondo uma lista com 4 valores num√©ricos:
            *---*---*---*---*
original    | 1 | 2 | 3 | 4 |   posi√ß√£o na mem√≥ria: 0x01
            *---*---*---*---*

# Ao adicionar um novo item, a lista precisa crescer:
            *---*
novo item   | 5 |
            *---*
            *---*---*---*---*
original    | 1 | 2 | 3 | 4 |    posi√ß√£o na mem√≥ria: 0x01
            *---*---*---*---*

# Uma nova lista √© criada:
            *---*---*---*---*---*---*---*---*
nova        |   |   |   |   |   |   |   |   |    posi√ß√£o na mem√≥ria: 0x1A
            *---*---*---*---*---*---*---*---*

# Os elementos da lista original s√£o copiados para a nova lista:
            *---*---*---*---*
original    | 1 | 2 | 3 | 4 |    posi√ß√£o na mem√≥ria: 0x01
            *---*---*---*---*
              ‚Üì   ‚Üì   ‚Üì   ‚Üì
            *---*---*---*---*---*---*---*---*
nova        | 1 | 2 | 3 | 4 |   |   |   |   |    posi√ß√£o na mem√≥ria: 0x1A
            *---*---*---*---*---*---*---*---*

# O novo elemento √© colocado na nova lista:
            *---*
novo item   | 5 | -------------
            *---*             ‚Üì
            *---*---*---*---*---*---*---*---*
nova        | 1 | 2 | 3 | 4 |   |   |   |   |    posi√ß√£o na mem√≥ria: 0x1A
            *---*---*---*---*---*---*---*---*

# O endere√ßo onde se encontrava a lista antiga √© liberado para ser utilizado
# e o "nome original" √© atribu√≠do a nova lista:
            *---*---*---*---*---*---*---*---*
original    | 1 | 2 | 3 | 4 | 5 |   |   |   |    posi√ß√£o na mem√≥ria: 0x1A
            *---*---*---*---*---*---*---*---*
            
Essa organiza√ß√£o em espa√ßos cont√≠nuos em mem√≥ria torna o acesso a √≠ndices muito eficiente, pois basta pegar o endere√ßo em mem√≥ria do primeiro elemento e somar ao √≠ndice, multiplicando pelo tamanho do tipo armazenado e teremos o valor daquela posi√ß√£o. Posso ter dez, cem ou mil itens que o tempo para acessar o valor pelo √≠ndice ser√° o mesmo.

üí° A decis√£o por criar uma nova lista e copiar os valores parece esquisita a primeira vista, mas a opera√ß√£o de realoca√ß√£o tem um custo muito muito grande, explicando assim esta decis√£o.

* At√© agora inserimos somente ao final do nosso array. Mas e se precisarmos adicionar um elemento no in√≠cio, ou no meio?

array_example.py

EX:

# ...
# array = ListaArray()

array.set(0, "Marcos")
array.set(1, "Patr√≠cia")
# print(array), internamente chama o m√©todo array.__str__() que implementamos
print(array)  # sa√≠da: ["Marcos", "Patr√≠cia"]

# inserindo no come√ßo do array
array.set(0, "Valeria")
print(array)  # sa√≠da: ["Valeria", "Marcos", "Patr√≠cia"]

# inserindo em uma posi√ß√£o intermedi√°ria
array.set(1, "Miguel")
print(array) # sa√≠da: ['Valeria', 'Miguel', 'Marcos', 'Patr√≠cia']

Quando inserimos um novo elemento no in√≠cio do array, todos os elementos j√° existentes s√£o deslocados √† direita, tendo seu √≠ndice modificado em 1. An√°logo a isto, quando adicionamos em uma posi√ß√£o intermedi√°ria, todos os elementos com √≠ndices posteriores ao inserido ser√£o movidos em uma posi√ß√£o.

EX:

# Supondo uma lista com 4 caracteres ao qual adicionaremos mais um no in√≠cio:
            *---*
novo item   | a |
            *---*
              ‚Üì
            *---*---*---*---*
original    | b | c | d |   |    posi√ß√£o na mem√≥ria: 0x01
            *---*---*---*---*
                ‚§ª  ‚§ª  ‚§ª

# Os elementos s√£o deslocados para o pr√≥ximo √≠ndice.

            *---*---*---*---*
original    | a | b | c | d |    posi√ß√£o na mem√≥ria: 0x01
            *---*---*---*---*


# As regras de crescimento ainda se aplicam portanto pode ser que uma nova lista
# seja criada, o elemento adicionado e os elementos copiados para a nova lista.
# Ainda assim, o √≠ndice de todos os elementos posteriores a inser√ß√£o
# ser√£o acrescidos em 1.

O mesmo acontece se inserirmos um novo elemento no meio da lista:

EX:

# Supondo uma lista com 3 caracteres ao qual adicionaremos mais um na segunda posi√ß√£o, vulgo √≠ndice 1:
(inserimos b na posi√ß√£o 1).

                *---*
novo item       | b |
                *---*
                  ‚Üì
            *---*---*---*---*
original    | a | c | d |   |    posi√ß√£o na mem√≥ria: 0x01
            *---*---*---*---*
                    ‚§ª  ‚§ª

# O resultado final seria:
            *---*---*---*---*
original    | a | b | c | d |    posi√ß√£o na mem√≥ria: 0x01
            *---*---*---*---*
            
Algo similar ocorre quando fazemos remo√ß√µes de valores √† partir dos √≠ndices:

EX:

# Supondo uma lista com 4 caracteres ao qual removeremos um elemento

# Se removermos o √∫ltimo elemento (√≠ndice 3), nada precisa ser modificado

         *---*---*---*---*
array    | a | b | c |   |    posi√ß√£o na mem√≥ria: 0x01
         *---*---*---*-‚§π-*
                        d

# Por√©m se removermos o primeiro, ou qualquer outro √≠ndice,
# todos os valores ser√£o deslocados √† esquerda:
                 ‚§∫  ‚§∫  ‚§∫
         *---*---*---*---*---*---*---*---*
array    | a |   | c | d | e |   |   |   |    posi√ß√£o na mem√≥ria: 0x01
         *---*-‚§π-*---*---*---*---*---*---*
                b

# √Ä medida que itens s√£o removidos, a estrutura diminui em tamanho:
         *---*---*---*---*
array    | a | c | d | e |    posi√ß√£o na mem√≥ria: 0x01
         *---*---*---*---*
         
* O c√≥digo de remo√ß√£o ficaria assim:

array_example.py

EX:

# import sys

class ListaArray:
    # ...
    def remove(self, index):
        # removeremos o item, retornando-o
        return self.data.pop(index)

# ...
# array = ListaArray()
array.set(0, "Marcos")
array.set(1, "Patr√≠cia")
print(array)  # sa√≠da: ['Marcos', 'Patr√≠cia']

array.remove(0)  # retorna a string "Marcos"
print(array)  # sa√≠da: ['Patr√≠cia']


# Arrays multidimensionais e outras opera√ß√µes:

Arrays podem ter mais de uma dimens√£o, de fato, podem ser estendidas para um n√∫mero N de dimens√µes. Isto pode ser bastante √∫til para modelagens de matrizes, tabuleiros em jogos ou problemas que envolvam tabela de dados.

Vamos ver um exemplo de como poder√≠amos implementar um array dimensional. Para isso, vamos criar um novo arquivo, no mesmo diret√≥rio do arquivo que est√°vamos utilizando anteriormente, apenas para n√£o termos que criar outro ambiente isolado.

multidimensional_array_example.py

EX:

from array_example import ListaArray


class Matrix(ListaArray):

    def get(self, row, column):
        return self.data[row][column]

    def set(self, row, column, value):
        """Caso a linha n√£o exista, uma nova linha
        ser√° criada."""
        try:
            self.data[row].insert(column, value)
        except IndexError:
            self.data.insert(row, [value])

    def remove(self, row, column):
        # removeremos o item, retornando-o
        return self.data[row].pop(column)

print('----- Arrays multidimensionais')
array = Matrix()
array.set(0, 0, "Marcos")
array.set(0, 1, 6)
array.set(0, 2, 9)

array.set(1, 0, "Patr√≠cia")
array.set(1, 1, 9)
array.set(1, 2, 6)

print(array)

# remove o √≠ndice 2, da primeira linha com o valor 9
array.remove(0, 2)

print(array)

Como j√° deve ter notado, list √© uma implementa√ß√£o do TAD Array, e embora aqui tenhamos utilizado uma nova classe para escrever a estrutura de dados array, isto est√° cheirando muito a um MiddleMan. Portanto vamos remover o intermedi√°rio e utilizar diretamente a classe a partir de agora.

* Vamos ver mais algumas coisas interessantes que podemos fazer com esta estrutura. Para isso, crie um novo arquivo novamente.

functions_examples.py

EX:

# Dado um array com os valores
array = [1, 2, 4, 5, 6]
# e outro com os valores
other_array = [7, 8, 9]
# podemos junta-los em um novo utilizando o operador +
new_array = array + other_array
# um novo array √© criado e o conte√∫do de ambos √© copiado
# para a nova estrutura
print('Array unido:', new_array)

print("-----")

# Uma outra opera√ß√£o interessante √© a busca
# pois podemos buscar um elemento utilizando o operador in
# √â equivalente a iterar sobre cada elemento e verificar a igualdade
# essa busca pode demorar um pouco j√°
# que se n√£o encontrar pode acabar percorrendo toda a estrutura

print("Possui 5:", 5 in new_array)  # sa√≠da: True
print("Possui 10:", 10 in new_array)  # sa√≠da: False

print("-----")

# temos o count para contar quantas vezes um elemento aparece
print("Vezes em que o 1 se repete:", [1, 2, 1, 2, 1, 4, 5, 6].count(1))

# array de duas dimens√µes
matrix = [[1, 2, 3],
          [4, 5, 6],
          [7, 8, 9]]

print("-----")

# acessando um √≠ndice
print('indice[1][1]:', matrix[1][1])  # sa√≠da: 5

print("-----")

# deletando um elemento √° partir do √≠ndice
del matrix[2][2]
print('deletando √≠ndice [2][2]:', matrix)


# Arrays no Pythonverso:

Arrays tamb√©m est√£o presentes no universo Python em outras implementa√ß√µes al√©m do tipo list. Abaixo veremos alguns exemplos:

* M√≥dulo array

Este m√≥dulo que j√° vem na linguagem Python, cont√©m uma implementa√ß√£o de arrays compacta e otimizada para valores b√°sicos como caracteres, n√∫meros inteiros e ponto flutuante.

module_array_example.py

EX:

import sys
from array import array

# define um array vazio de inteiros sem sinal
myarray = array("I")

# podemos adicionar alguns valores
myarray.insert(0, 5)  # na posi√ß√£o 0 o valor 5
myarray.insert(1, 3)
myarray.insert(2, 5)
print("Ap√≥s adicionar alguns valores: ", myarray)

# adicionar em uma posi√ß√£o intermedi√°ria
myarray.insert(1, 4)
print("Ap√≥s inser√ß√£o em √≠ndice intermedi√°rio: ", myarray)


# remover um valor atrav√©s do √≠ndice
myarray.pop(0)
print("Ap√≥s remover um valor:", myarray)

# compare o tamanho entre uma lista e um array
elements = list(range(100))  # definimos uma lista de 100 n√∫meros
print("Tamanho da lista:", sys.getsizeof(elements))
array_from_list = array("I", elements)  # criamos um array a partir da lista
print("Tamanho do array", sys.getsizeof(array_from_list))

Um exemplo de utiliza√ß√£o deste array pode ser para armazenar avalia√ß√µes de um motorista em um sistema de motoristas particulares.

* Numpy

Pacote fundamental para computa√ß√£o cient√≠fica em Python, possui uma implementa√ß√£o r√°pida e vers√°til para array de n-dimens√µes.

üê¶ Para usar o Numpy devemos instal√°-lo atrav√©s do pip. Vamos utilizar o seguinte comando:

EX:

python3 -m pip install numpy
numpy_array_example.py

EX:

import numpy as np

# define um array vazio de inteiros
myarray = np.array([], dtype=int)

# podemos adicionar alguns valores
myarray = np.insert(myarray, 0, 5)  # na posi√ß√£o 0 o valor 5
myarray = np.insert(myarray, 1, 3)
myarray = np.insert(myarray, 2, 5)
print("Ap√≥s adicionar alguns valores: ", myarray)

# adicionar em uma posi√ß√£o intermedi√°ria
myarray = np.insert(myarray, 1, 4)
print("Ap√≥s inser√ß√£o em √≠ndice intermedi√°rio: ", myarray)


# remover um valor atrav√©s do √≠ndice
myarray = np.delete(myarray, 0)
print("Ap√≥s remover um valor:", myarray)

Bibliotecas como o pandas para an√°lise de dados, ou scikit-learn para aprendizado de m√°quina utilizam o numpy por baixo dos panos, devido a sua implementa√ß√£o eficiente.
