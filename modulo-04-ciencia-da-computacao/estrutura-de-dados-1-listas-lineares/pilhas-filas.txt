# O que √© uma pilha?

A estrutura de pilha √© uma estrutura do tipo LIFO (Last In First Out). Ou seja, o √∫ltimo elemento a entrar na pilha √© o primeiro a sair.

Quem nunca deixou um monte de roupas uma em cima da outra num canto da casa? Nunca organiz√°vamos aquela pilha de roupas e sempre que precis√°vamos de alguma roupa peg√°vamos uma de cima por pregui√ßa de organizar as demais roupas. Voc√™s j√° tentaram remover uma roupa que estivesse no meio da pilha? Faz uma baita bagun√ßa e sempre era necess√°rio organizar os restante das roupas.

A dica √© sempre tentar remover a roupa de cima da pilha de roupas, a mesma coisa deve ser feito com a estrutura de dados pilha. Sempre devemos remover o √∫ltimo item que entrou na pilha, ou seja, o item mais acima. Uma remo√ß√£o de algum item do meio dar√° um baita trabalho para reorganizar a pilha.

Assim como no mundo real, quando manipulamos uma pilhas de pratos, por exemplo, s√≥ conseguimos efetuar ‚Äúopera√ß√µes‚Äù no topo da pilha. Adicionar um novo prato no topo da pilha √© uma tarefa bem simples de ser realizada, assim como tamb√©m a opera√ß√£o de retirar um prato da pilha para podermos utilizar no almo√ßo. Claro que no mundo real podemos remover um prato do meio, mas convenhamos, d√° um pouco de trabalho, n√£o? Na programa√ß√£o remover itens do meio da pilha tamb√©m n√£o √© uma boa ideia.

Num restaurante voc√™s j√° perceberam que, quando os pratos dispon√≠veis para as pessoas clientes est√£o acabando, uma pessoa adiciona uma certa quantidade de pratos no topo de uma pilha de pratos? Neste caso os √∫ltimos pratos adicionados ser√£o os primeiros a serem utilizados, pois n√≥s n√£o tiramos os pratos de baixo da pilha e sim do topo.

Podemos criar uma pilha utilizando alguma outra estruturas de dados como listas encadeadas ou arrays, com a √∫nica diferen√ßa que todas as opera√ß√µes devem ocorrer com o elemento mais ao topo, ou seja, no √∫ltimo elemento adicionado. Em nosso exemplos vamos utilizar o built-in list para facilitar o entendimento.

O desenho de uma pilha normalmente se parece com um daqueles porta moedas antigos com molas.


* Concluindo nossa solu√ß√£o:

Lembra da nossa necessidade?

‚ÄúPrecisamos de uma forma de lembrar n√£o somente a quantidade de aberturas, como tamb√©m a ordem‚Äù

A pilha faz exatamente isso!

Veja o exemplo da string ( { } ) }

Quando os elementos come√ßarem a fechar, sabemos com certeza que o primeiro a ser fechado deve ser o √∫ltimo que foi aberto. (E tamb√©m o segundo a ser fechado o segundo √∫ltimo que foi aberto, e assim por diante.) Ou seja, Last In, First Out. Agora, para verificar se eles est√£o sendo fechados corretamente, basta verificarmos o pr√≥ximo s√≠mbolo que acharmos com o s√≠mbolo que est√° no topo da nossa pilha: Se acharmos um }, no topo da pilha deve existir um {. Se acharmos um ), o topo da pilha deve ter um (, e ao final da string, a pilha deve estar vazia, significando que todos os s√≠mbolos acharam seu devido par na ordem correta.

Se encontrarmos um elemento fechando na string, e a pilha estiver vazia, significa que fechamos algo sem antes abrir, ou seja, a string n√£o est√° ‚Äúbalanceada‚Äù. Se terminarmos a string, e houverem elementos na pilha ainda, significa que abrimos algo sem fechar depois. E se encontrarmos um s√≠mbolo na string, e o s√≠mbolo no topo da pilha for o par diferente, significa que eles est√£o na ordem errada. O caso correto √© quando terminamos a string com sucesso, e a pilha est√° vazia!

Conseguimos assim verificar o balanceamento de par√™nteses e chaves! Este problema √© cl√°ssico, pois Pilhas √© exatamente o conceito utilizado por compiladores e interpretadores para entender opera√ß√µes matem√°ticas, a qual escopo pertence cada bloco, come√ßo e final de strings, e muitas outras coisas.


# Quais as opera√ß√µes mais comuns:

Ao se manipular uma pilha, existem algumas opera√ß√µes que s√£o comuns de serem utilizadas. S√£o elas: push, pop, e peek.

A opera√ß√£o push adiciona um item no topo da pilha. Vale frisar novamente que, quando estamos utilizando pilhas, podemos adicionar novos valores somente no topo dela. Lembrando da analogia com o porta moedas, n√≥s n√£o conseguimos simplesmente adicionar uma moeda no meio das moedas j√° adicionadas. Para esse caso ter√≠amos que remover as moedas de cima e ent√£o adicionar a moeda que queremos para ent√£o adicionar as demais moedas de volta.

J√° as fun√ß√µes pop e peek s√£o utilizadas para ler valores do topo da pilha. A diferen√ßa entre as opera√ß√µes √© que o pop remove o item da pilha, enquanto que o peek somente l√™ o item.


# Utilizando pilhas:

Implementa√ß√£o de uma pilha utilizando Python
Para fixar o conte√∫do das fun√ß√µes b√°sicas de uma pilha, vamos criar uma classe Stack e aplicar nela as opera√ß√µes que acabamos de ver.

Primeiro iremos declarar a classe chamada Stack no arquivo stack.py. Em seguida, vamos declarar o construtor para termos uma pilha vazia e duas propriedades que ser√£o √∫teis para implementar as funcionalidades da pilha. A primeira propriedade nos retorna o tamanho da pilha e a segunda propriedade nos indica se a pilha esta vazia.

Nota: Aqui iremos utilizar o tipo built-in de lista para focarmos em entender as pilhas.

stack.py

EX:

class Stack():
    def __init__(self):
        self._data = list()

    def size(self):
        return len(self._data)

    def is_empty(self):
        return not bool(self.size())
        
* Ap√≥s adicionar as fun√ß√µes auxiliares, vamos adicionar as opera√ß√µes de push (empilhar itens) e pop (remover itens do topo da pilha). Com esses m√©todos j√° poderemos manipular valores na pilha. No arquivo stack.py vamos adicionar os m√©todo de push e pop, conforme o c√≥digo abaixo:

stack.py

EX:

class Stack():
    # ...

    def push(self, value):
        self._data.append(value)

    def pop(self):
        if self.is_empty():
            return None

        # -1 se refere ao √∫ltimo objeto da pilha.
        # Ou seja, o valor do topo da pilha
        value = self._data[-1]
        del self._data[-1]
        return value
        
* O m√©todo push adiciona um novo valor no topo da pilha, enquanto que o m√©todo pop ir√° pegar o elemento do topo e ent√£o retornar esse valor. Nem sempre √© interessante remover o valor da pilha, por isso iremos implementar o m√©todo peek que somente l√™ o valor no topo da pilha e ent√£o o retorna. Vamos adicion√°-lo dentro da nossa classe Stack:

stack.py

EX:

class Stack():
    # ...

    def peek(self):
        if self.is_empty():
            return None
        value = self._data[-1]
        return value
        
* A √∫ltima funcionalidade da pilha √© um m√©todo para limpa-la. Para isso iremos adicionar o m√©todo clear, que se encarregar√° de limpar todos os elementos da pilha.

stack.py

EX:

class Stack():
    # ...

    def clear(self):
        self._data.clear()
        
* Por fim, vamos adicionar o m√©todo __str__ que far√° a impress√£o de todos os elementos que est√£o empilhados. Do primeiro ao √∫ltimo item inserido (da parte de baixo da pilha at√© o topo).

stack.py

EX:

class Stack():
    # ...

    def __str__(self):
        str_items = ""
        for i in range(self.size()):
            value = self._data[i]
            str_items += str(value)
            if i + 1 < self.size():
                str_items += ", "

        return "Stack(" + str_items + ")"
        
* No final dessas implementa√ß√µes teremos a declara√ß√£o da classe Stack com todas as opera√ß√µes que podemos realizar com uma pilha. Claro que ainda podemos estender ainda mais a classe Stack para limitar a quantidade de itens na stack e retornar um erro de StackOverflow. N√£o se preocupem, temos um exerc√≠cio para isso üòä. No final, o arquivo stack.py ter√° a seguinte implementa√ß√£o:

stack.py

EX:

class Stack():
    def __init__(self):
        self._data = list()

    def size(self):
        return len(self._data)

    def is_empty(self):
        return not bool(self.size())

    def push(self, value):
        self._data.append(value)

    def pop(self):
        if self.is_empty():
            return None

        # -1 se refere ao √∫ltimo objeto da pilha.
        # Ou seja, o valor do topo da pilha
        value = self._data[-1]
        del self._data[-1]
        return value

    def peek(self):
        if self.is_empty():
            return None
        value = self._data[-1]
        return value

    def clear(self):
        self._data.clear()

    def __str__(self):
        str_items = ""
        for i in range(self.size()):
            value = self._data[i]
            str_items += str(value)
            if i + 1 < self.size():
                str_items += ", "

        return "Stack(" + str_items + ")"


if __name__ == "__main__":
    elements = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    content_stack = Stack()

    for elem in elements:
        content_stack.push(elem)

    # sa√≠da: Stack(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    print(content_stack)
    # sa√≠da: 10
    print(content_stack.size())

    # sa√≠da: 10
    print(content_stack.peek())
    # sa√≠da: 10, pois a fun√ß√£o retorna o elemento que est√° sendo retirado
    print(content_stack.pop())

    # sa√≠da: 9, pois, ap√≥s o 10 ter sido removido, o 9 se tornou o elemento do topo da pilha
    print(content_stack.peek())
    # sa√≠da: 9
    print(content_stack.size())

    # sa√≠da: None, pois a fun√ß√£o n√£o retorna nada!
    print(content_stack.clear())
    # sa√≠da: 0
    print(content_stack.size())
    
Para testar, apenas rode o c√≥digo com python3 -m stack.py üòä

# Onde pilhas s√£o normalmente utilizadas:

As pilhas s√£o utilizadas para resolver diversos problemas em linguagens de programa√ß√£o. Muitas linguagens utilizam a pilha para poder controlar o estado das chamadas de fun√ß√µes ou para resolver express√µes matem√°ticas e l√≥gicas.

Pilhas tamb√©m podem ser utilizadas para replicar o funcionamento de algoritmos recursivos, ou qualquer outro cen√°rio em que temos uma cole√ß√£o de elementos e precisamos controlar qual foi o elemento mais recente.

Uma curiosidade interessante √© que as pilhas, conceitualmente, n√£o t√™m limite de tamanho, por√©m nas implementa√ß√µes reais a linguagem de programa√ß√£o define um tamanho m√°ximo, pois nossos computadores t√™m mem√≥ria limitada. Quando, por exemplo, fazemos uma chamada recursiva sem uma condi√ß√£o de parada correta, a pilha de chamadas vai aumentando at√© o estourar o limite da linguagem. Ao tentarmos adicionar mais um valor, a pilha ‚Äútransborda‚Äù e lan√ßa um erro. ‚Ä¶ Sabe como √© o nome desse erro?

Stack. Overflow.


# Utiliza√ß√£o de pilhas no controle da chamada de fun√ß√µes:

A linguagem Python, por exemplo, utiliza a pilha em duas importantes funcionalidades da aplica√ß√£o. A primeira √© para controlar as chamadas da fun√ß√µes, ou seja, a linguagem mant√©m uma pilha com quais fun√ß√µes devem ser executadas ap√≥s a execu√ß√£o de uma fun√ß√£o. Ficou confuso? Ent√£o vamos a um exemplo!

Considerando que temos uma fun√ß√£o com o nome process_video e ela recebe um argumento indicando o caminho de um v√≠deo. Dentro dessa fun√ß√£o √© invocado a fun√ß√£o load_video, recebendo tamb√©m o argumento do caminho do v√≠deo repassado da fun√ß√£o process_video. O c√≥digo dessas fun√ß√µes ficariam parecido com:

EX:

def load_video(video_path):
    print('Carregando v√≠deo do caminho:', video_path)
    return 'fake v√≠deo'

def process_video(video_path):
    print('Carregando v√≠deo...')
    loaded_video = load_video(video_path)
    # Faz alguma coisa legal com o v√≠deo
    
Nesse c√≥digo, ao invocarmos a fun√ß√£o para processar o video, o interpretador do Python come√ßa a executa-la e, ao chegar na linha que invocamos a fun√ß√£o de leitura do video, o Python faz um push da fun√ß√£o corrente (process_video()) na pilha de execu√ß√£o, com todo o seu contexto, para ent√£o executar a fun√ß√£o de leitura. Quando a fun√ß√£o de leitura for finalizada o Python ir√° fazer um pop da pilha para continuar a execu√ß√£o da aplica√ß√£o.

Se adicionarmos a fun√ß√£o traceback.print_stack(file=sys.stdout) conseguimos ver quais os itens presentes na call stack do Python. Para que voc√™s possam visualizar basta copiar o c√≥digo abaixo e execut√°-lo no modo iterativo do interpretador:

üí° Modo iterativo do interpretado: executar o comando python no terminal. Com isso, voc√™ ir√° entrar no IDLE do Python. Ap√≥s ter entrado, escreva o c√≥digo abaixo.

EX:

import traceback
import sys


def load_video(video_path):
    print('Carregando v√≠deo do caminho:', video_path)
    traceback.print_stack(file=sys.stdout)
    return 'fake v√≠deo'

def process_video(video_path):
    print('Carregando v√≠deo...')
    loaded_video = load_video(video_path)
    # Faz alguma coisa legal com o v√≠deo


process_video('path/to/my/video')


callstack
üí° Caso estejam usando o modo iterativo, ser√° exibido no terminal uma stack menor do que quando o c√≥digo √© executado no iPython. A stack ser√° diferente, pois o iPython possui uma estrutura para poder melhorar a interatividade via linha de comando e o print da stack acaba imprimindo essa estrutura tamb√©m. Se tiver interesse, vale a pena verificar ambos para notar a diferen√ßa.


# Utiliza√ß√£o de pilhas na resolu√ß√£o de express√µes:

Outro lugar que pilhas s√£o muito bem aproveitadas √© na valida√ß√£o de express√µes matem√°ticas. Existem diversos tipos de representa√ß√£o de express√µes, como por exemplo, infixa e p√≥s fixa. Quando escrevemos a express√£o (A + B) * C estamos escrevendo uma express√£o no formato infixa. A mesma express√£o, quando escrita no formato p√≥s fixa, ficaria um pouco diferente: A B + C *. E como resolver√≠amos essa express√£o? Basicamente n√≥s pegamos os A e B para aplicarmos a opera√ß√£o de soma (o + logo ap√≥s as vari√°veis). Quando obtivermos o resultado da soma, aplicamos a opera√ß√£o de multiplica√ß√£o com a vari√°vel C (o * logo ap√≥s o C), ou seja, iremos resolvendo a express√£o sempre de dois em dois operadores, da esquerda para a direita. Para entendermos melhor como funciona, vamos desenvolver um exemplo, fazendo o passo a passo considerando os valores A = 5, B = 10 e C = 3:

Temos a express√£o em p√≥s fixa: A B + C *, substituindo as vari√°veis ficar√≠amos com: 5 10 + 3 *.

* expressao1

O primeiro passo √© pegar os dois primeiros valores e executar a opera√ß√£o de soma, ent√£o iremos resolver a primeira parte da opera√ß√£o (5 10 +). O resultado dessa soma √© 15, certo?

Agora pegaremos o resultado e adicionaremos √† primeira parte da express√£o. A nova express√£o fica assim:

* expressao2

Ent√£o repetiremos o primeiro passo, mas para opera√ß√£o de multiplica√ß√£o. Iremos pegar os dois primeiros valores da express√£o e executaremos a opera√ß√£o de multiplica√ß√£o, resolvendo a ultima parte da express√£o (15 3 *). O resultado dessa multiplica√ß√£o √© 45, certo?

* expressao3

Substituindo o resultado na express√£o teremos somente um valor nela. Com isso, nossa express√£o est√° resolvida. O resultado de (10 + 5) * 3 √© 45.

Mas como pilhas s√£o utilizadas para a resolu√ß√£o de express√µes p√≥s fixa? Percebam que resolvemos a express√£o da esquerda para a direita, sempre aplicando as opera√ß√µes nos dois √∫ltimos n√∫meros da express√£o, n√£o √© mesmo? Dessa forma conseguimos adicionar esses n√∫meros numa pilha e ent√£o aplicamos a opera√ß√£o no primeiro e no segundo item do topo da pilha, at√© que reste somente um item na pilha (nosso resultado final). Por exemplo, considerando a primeira parte da express√£o que resolvemos acima 10 5 +, n√≥s iremos adicionar o valor 10 e 5 no topo da pilha e quando lermos o valor + aplicaremos a opera√ß√£o nos dois itens do topo. Ent√£o adicionamos o resultado no topo da pilha:

* expressao-op1

Com o resultado da opera√ß√£o, n√≥s o adicionamos novamente na pilha para podermos continuar com as outras partes da express√£o. A segunda opera√ß√£o de multiplica√ß√£o, entre o resultado da soma (15) e o valor da vari√°vel C (3), segue o mesmo principio da primeiro opera√ß√£o. N√≥s retiramos os valores da pilha para ent√£o executar a multiplica√ß√£o. Ent√£o adicionamos o resultado novamente na pilha, ficando somente com um valor, que √© o resultado da express√£o.

* expressao-op2

Se ainda ficou um pouco confuso como utilizar pilhas para a resolu√ß√£o dessas express√µes, iremos desenvolver um exemplo pr√°tico em conjunto para a resolu√ß√£o dessas express√µes.

Implementando uma fun√ß√£o que resolve express√µes p√≥s fixas
Agora vamos praticar! Vamos implementar uma fun√ß√£o, utilizando stacks, para calcular a express√µes p√≥s fixa. Vamos utilizar o mesmo exemplo que vimos anteriormente:(A + b) * C. Vamos implementar uma fun√ß√£o que receba essa express√£o, em formato de string, p√≥s fixa e ent√£o calcule o resultado da express√£o.

O primeiro passo √© criar o arquivo expression_solver.py e ent√£o escreveremos todo o nosso c√≥digo nele. Depois iremos declarar uma fun√ß√£o chamada solve_expression(), que receber√° uma express√£o no formato texto como argumento. A fun√ß√£o ir√° instanciar uma pilha para nos auxiliar na resolu√ß√£o da express√£o. O c√≥digo abaixo demonstra essa primeira parte.

Nota: √© necess√°rio que o arquivo stack.py, que criamos no in√≠cio do conte√∫do, esteja no mesmo diret√≥rio que o arquivo expression_solver.py.

expression_solver.py

EX:

from stack import Stack


def solve_expression(expr):
    stack = Stack()

    tokens_list = expr.split(' ')
    
Essa quebra dos tokens ser√° importante para decidirmos o que faremos com cada um dos valores que temos na express√£o, seja eles n√∫meros ou opera√ß√µes. Por enquanto iremos somente implementar as opera√ß√µes de soma e multiplica√ß√£o!

* Bom, com os valores dos tokens, iremos percorrer a nossa lista de tokens e executar as opera√ß√µes de push e pop da stack, para podermos resolver a express√£o. Primeiro vamos adicionar o c√≥digo para executar somente a soma e a adi√ß√£o dos valores na pilha. Depois faremos a opera√ß√£o de multiplica√ß√£o:

expression_solver.py

EX:

# ...


def solve_expression(expr):
    # ...

    for token in tokens_list:
        if token == '+':
            # Sum operation
            result = stack.pop() + stack.pop()
            stack.push(result)
        else:
            # add number operation
            stack.push(int(token))
            
Show! Com a adi√ß√£o desse loop podemos executar express√µes somente com a opera√ß√£o de soma. Ent√£o a primeira parte da nossa express√£o 10 5 + j√° pode ser executada na nossa fun√ß√£o que resolve express√µes p√≥s fixa.

Agora teremos que executar a opera√ß√£o de multiplica√ß√£o e ao final retornar o resultado da express√£o, ou seja, o valor que ficou na pilha.

* Vamos adicionar mais um pouco de c√≥digo para podermos executar a segunda parte da nossa express√£o, a opera√ß√£o de multiplica√ß√£o. O c√≥digo a ser adicionado √© uma verifica√ß√£o para fazermos a opera√ß√£o de multiplica√ß√£o e o calculo da multiplica√ß√£o em si. Ele √© bem parecido com o c√≥digo da soma, a diferen√ßa √© que se executa uma multiplica√ß√£o com os dois valores do topo da lista.

expression_solver.py

EX:

# ...


def solve_expression(expr):
    # ...

    # for token in tokens_list:
        # if token == '+':
            # Sum operation
            # result = stack.pop() + stack.pop()
            # stack.push(result)
        elif token == '*':
            # multiply operation
            result = stack.pop() * stack.pop()
            stack.push(result)
        # else:
            # add number operation
            # stack.push(int(token))

    return stack.pop()


print(solve_expression("5 10 + 3 *"))

Agora j√° conseguimos resolver a nossa express√£o utilizando a nossa fun√ß√£o de resolu√ß√£o de express√µes! üéâ üí•

* O c√≥digo final do arquivo expression_solver.py ficou assim:

expression_solver.py

EX:

from stack import Stack


def solve_expression(expr):
    stack = Stack()
    tokens_list = expr.split(' ')

    for token in tokens_list:
        if token == '+':
            # Sum operation
            result = stack.pop() + stack.pop()
            stack.push(result)
        elif token == '*':
            # multiply operation
            result = stack.pop() * stack.pop()
            stack.push(result)
        else:
            # add the number operation
            stack.push(int(token))

    return stack.pop()


print(solve_expression("5 10 + 3 *"))


# Filas:

Assim como temos a mentalidade Last In, First Out (ou First In, Last Out) para problemas que s√£o pilhas, precisamos de outra mentalidade para problemas que s√£o filas: First In, First Out (FIFO) (ou Last In, Last Out). Quem chega primeiro recebe atendimento primeiro, nada mais justo. Assim, todos ser√£o atendidos com uma demora mais parecida.

Na computa√ß√£o tamb√©m temos problemas que requerem a mentalidade FIFO. Por exemplo, j√° parou para pensar como √© que um processador com um √∫nico n√∫cleo consegue rodar um sistema operacional inteiro, e mais 17 programas ao mesmo tempo? Cada programa demanda uma s√©rie de opera√ß√µes, e um n√∫cleo s√≥ pode executar uma de cada vez; ele coloca as opera√ß√µes em uma fila, e resolve estas opera√ß√µes uma por uma, garantindo assim que todos os programas consigam rodar e prosseguir em suas tarefas.

Assim como a pilha, o TAD Fila (queue, em ingl√™s) tamb√©m pode ser implementada tanto em um array como em uma lista; o importante n√£o √© a forma que ela √© implementada em c√≥digo, mas sim a forma que ela se comporta; que m√©todos ela exp√µe. No caso da fila, as opera√ß√µes devem ser as seguintes:

Enqueue: Adiciona um elemento no final da fila
Dequeue: Remove e retorna o primeiro elemento da fila

Implementa√ß√£o de uma fila utilizando Python
Notou como a √∫nica diferen√ßa da fila √© que a remo√ß√£o ocorre no come√ßo, em vez de no final? Apenas essa diferen√ßa causa um funcionamento totalmente diferente, que soluciona problemas diferentes! Para visualizar melhor essa situa√ß√£o, imagine que voc√™ vai entrar na fila de uma lanchonete drive thru. Seu carro vai entrar no come√ßo, ou no final da fila? ü§î

Por fim, ao entramos na fila, devemos nos posicionar ao final dela e esperarmos os carros da frente serem atendidos, at√© que chegue a nossa vez. Falando nisso, suponha que, ap√≥s alguns minutos, finalmente chegou sua vez e voc√™ pegou seu pedido. Agora, voc√™ pode sair da fila e aproveitar seu lanche em casa. Isso s√≥ aconteceu porque voc√™ chegou ao in√≠cio da fila, esperou sua vez de receber o pedido e, em seguida, te ‚Äúremoveram‚Äù da fila.

Para observarmos como essas opera√ß√µes funcionam na pr√°tica, vamos declarar uma classe Queue em um arquivo queue.py. Filas em Python podem ser implementadas de diferentes maneiras, mas, para seguirmos um padr√£o, vamos usar o tipo built-in de lista para estudarmos as filas, assim como fizemos com as pilhas.

queue.py

EX:

class Queue():
    def __init__(self):
        self.queue = list()
        
* Como nossa fila ainda est√° vazia, vamos come√ßar pelo m√©todo enqueue (enfileirar, em portugu√™s). √â atrav√©s dele que iremos incluir itens em nossa fila. E como estamos usando o tipo lista, podemos utilizar o m√©todo append, j√° que ele, naturalmente, inclui o elemento novo no final da lista.

queue.py

EX:

    def enqueue(self, value):
        self.queue.append(value)
        
Agora que temos um m√©todo que faz a inser√ß√£o de itens na fila, precisamos do m√©todo respons√°vel por remov√™-los. √â a√≠ que entra o X da quest√£o! Na fila, n√£o podemos simplesmente retirar um item a esmo. Como os itens est√£o enfileirados, devemos respeitar sua ordem.

* Sempre que quisermos retirar um elemento de uma fila, esteja ele em um drive thu ou em um c√≥digo, esse item deve ser o primeiro desta fila. E, para isso, vamos implementar o m√©todo dequeue (desenfileirar, em portugu√™s). Como devemos remover o primeiro elemento, podemos nos guiar pelo seu √≠ndice, j√° que, em uma lista, ele sempre ser√° 0.

queue.py

EX:

    def dequeue(self):
        # Se n√£o houver mais itens na fila, o m√©todo retornar√° None
        if len(self.queue) == 0:
            return None
        # O m√©todo pop remove e retorna o valor do √≠ndice fornecido
        return self.queue.pop(0)
        
* Dessa maneira, conclu√≠mos a declara√ß√£o da classe Queue com as duas opera√ß√µes principais do TAD Fila.

queue.py

EX:

class Queue():
    def __init__(self):
        self.queue = list()

    def enqueue(self, value):
        self.queue.append(value)

    def dequeue(self):
        if len(self.queue) == 0:
            return None
        return self.queue.pop(0)
        
* Dependendo da nossa necessidade, podemos estender ainda mais essa classe, manipulando nossa fila de diversas outras maneiras. Vamos adicionar o m√©todo __str__ ao nosso c√≥digo para testarmos essa implementa√ß√£o!

queue.py

EX:

class Queue():
    def __init__(self):
        self._data = list()

    def enqueue(self, value):
        self._data.append(value)

    def dequeue(self):
        if len(self._data) == 0:
            return None
        return self._data.pop(0)

    def __str__(self):
        str_items = ""
        for i in range(len(self._data)):
            value = self._data[i]
            str_items += str(value)
            if i + 1 < len(self._data):
                str_items += ", "

        return "Queue(" + str_items + ")"

if __name__ == "__main__":
    elements = ["Milkshake", "Batata Frita", "Refrigerante"]
    content_queue = Queue()

    print(content_queue)
    # Sa√≠da: Queue()
    
    for elem in elements:
        content_queue.enqueue(elem)

    print(content_queue)
    # Sa√≠da: Queue(Milkshake, Batata Frita, Refrigerante)
    
    content_queue.dequeue()
    print(content_queue)
    # Sa√≠da: Queue(Batata Frita, Refrigerante) 
    
    print(content_queue.dequeue())
    # Sa√≠da: Batata Frita
    # porque "Milkshake" j√° foi removido e "Batata Frita" se tornou o primeiro elemento da fila 
    
Para testar, apenas rode o c√≥digo com python3 -m queue.py 







