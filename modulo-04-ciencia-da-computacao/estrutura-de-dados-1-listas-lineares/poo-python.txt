# M√©todo Construtor/Inicializador:

* Ap√≥s modelada nossa Classe do objeto, podemos partir para o construtor. O construtor √© um m√©todo especial que roda automaticamente quando a gente cria (instancia) o objeto. Na maioria das linguagens, o construtor cria e devolve a inst√¢ncia do objeto e j√° inicializa os seus atributos.

Em python, esta opera√ß√£o √© dividida em dois m√©todos:

EX:

__new__ (Construtor)
__init__ (Inicializador)
Copiar
class Exemplo:
    def __init__(self):
        print("Inicializando Exemplo")
        self.__privado = "Eu sou privado"

    def __new__(cls, *args, **kwargs):
        print("Criando uma nova inst√¢ncia de Exemplo")
        instance = super().__new__(cls)
        return instance

    def __metodo_privado(self):
        print("Este √© um m√©todo privado")

    def metodo_publico(self):
        print("Este √© um m√©todo p√∫blico")
        self.__metodo_privado()
        
Observe que o nome do m√©todo privado come√ßa com dois sublinhados __. Al√©m disso, dentro do construtor __init__, h√° um atributo que come√ßa com dois sublinhados __privado. Isso tamb√©m √© um exemplo de encapsulamento de dados. Para acessar o m√©todo privado de dentro da classe, podemos simplesmente chamar o m√©todo normalmente. Por exemplo, o m√©todo p√∫blico metodo_publico chama o m√©todo privado __metodo_privado usando o self.__metodo_privado().

O m√©todo __new__ √© respons√°vel por criar e retornar uma nova inst√¢ncia da classe. Ele √© uma parte importante da metaprograma√ß√£o em Python, pois permite que os desenvolvedores personalizem a cria√ß√£o de objetos e controlem como as inst√¢ncias s√£o criadas. Ele tamb√©m aceita quaisquer argumentos que seriam passados para o m√©todo __init__, que s√£o capturados pelos par√¢metros *args e **kwargs.

No entanto, se tentarmos acessar o m√©todo privado a partir de fora da classe, receberemos um erro:

EX:

exemplo = Exemplo()
exemplo.__metodo_privado() # Erro: AttributeError: 'Exemplo' object has no attribute '__metodo_privado'

Isso ocorre porque o m√©todo privado s√≥ pode ser acessado dentro da pr√≥pria classe.

Em resumo, os m√©todos privados s√£o √∫teis para manter a integridade do objeto, tornando certos m√©todos e atributos acess√≠veis somente dentro da classe, ocultando a implementa√ß√£o interna e evitando que outras partes do c√≥digo interfiram no funcionamento da classe.

Anota a√≠ ‚úèÔ∏è: O Python j√° implementa estes m√©todos por padr√£o para cada nova classe criada, mas voc√™ pode implement√°-los novamente, ou seja, sobrescrev√™-los. √â desse modo que customizamos nosso construtor/inicializador.

* Importante: Apesar do m√©todo __init__ ser ‚Äúapenas‚Äù o inicializador, √© comum ver refer√™ncias a ele como o construtor. Isso acontece pois s√£o raras as vezes que precisamos alterar o __new__ para customizar nossas classes. Como a comunidade j√° adotou que ‚Äúo __init__ √© o construtor de objetos no Python‚Äú, tamb√©m vamos seguir essa conven√ß√£o por aqui üòâ

Com isso vamos para o segundo passo: basta recriar o m√©todo __init__ dentro de nossa classe, conforme exemplo a seguir:

EX:

class Liquidificador:
    def __init__(self, cor, potencia, tensao, preco):
        self.preco = preco
        self.cor = cor
        self._potencia = potencia
        self._tensao = tensao
        self.__ligado = False
        self.__velocidade = 0
        self.__velocidade_maxima = 3
        self.__corrente_atual_no_motor = 0
        
O primeiro par√¢metro, o self, representa a inst√¢ncia do objeto, ou seja, tem acesso ao objeto na mem√≥ria.

De olho na dica üëÄ: Em muitas linguagens tamb√©m √© chamado de this, e como em Python √© um par√¢metro expl√≠cito, voc√™ pode cham√°-lo como quiser, mas self √© uma conven√ß√£o adotada pela comunidade.

Com o m√©todo __init__ inicializamos os atributos do objeto apenas atribuindo um valor a cada nova chave. Exemplo: self.__ligado = False.

Os pr√≥ximos par√¢metros s√£o os que permitem criar de forma customizada nosso objeto, como a cor: self.cor = cor.

De olho na dica üëÄ: No exemplo self.cor = cor, o valor do par√¢metro cor do m√©todo __init__ √© atribu√≠do ao atributo hom√¥nimo cor do objeto (self.cor). Entretanto o par√¢metro cor poderia valorar um atributo qualquer. Um exemplo disso seria se armazen√°ssemos a corrente m√°xima que o motor pode ter: self.corrente_maxima_no_motor = potencia / tensao. Observe como potencia e tensao s√£o dois par√¢metros utilizados para valorar um √∫nico atributo.

* Agora podemos criar nossos primeiros liquidificadores:

EX:

meu_liquidificador = Liquidificador("Azul", 200, 127, 200)
seu_liquidificador = Liquidificador(
    cor="Vermelho", potencia=250, tensao=220, preco=100
)

Perceba que √© poss√≠vel ter atributos que n√£o precisam ser passados por meio de par√¢metros na chamada do construtor. Por exemplo, para o booleano __ligado e o inteiro __velocidade, o construtor vai inici√°-los sempre com os valores fixos (hard coded) False e 0, respectivamente.


# Encapsulamento e Abstra√ß√£o

Agora que j√° sabemos criar nossos objetos, √© essencial sabermos como simplificar seu uso e esconder os detalhes de implementa√ß√£o.

* Encapsulamento:
O encapsulamento √© um dos pilares da orienta√ß√£o a objetos. Por meio dele, √© poss√≠vel simplificar bastante a implementa√ß√£o da abstra√ß√£o. Assim, segmentamos nossos atributos e m√©todos em 3 categorias:

P√∫blicos: podem ser acessados livremente por qualquer parte da aplica√ß√£o
Protegidos: podem ser acessados apenas pela classe que os definem e, quando h√° heran√ßa envolvida, tamb√©m pelas classes ‚Äúabaixo‚Äù na hierarquia (veremos o t√≥pico heran√ßa a seguir)
Privados: podem ser acessados apenas pela classe que os definem
Em Python n√£o temos palavras reservadas como public, private e protected para declarar um atributo ou m√©todo como p√∫blico, privado ou protegido, respectivamente. Para isso, existe uma conven√ß√£o de nomenclatura para definir a acessibilidade de cada recurso:

Nomes iniciados com _ (underline): s√£o considerados ‚Äúprotegidos‚Äú, como os atributos _potencia e _tensao.
‚ö†Ô∏è Isso √© apenas uma conven√ß√£o entre pessoas desenvolvedoras Python, pois ainda ser√° poss√≠vel fazer um acesso direto por fora da classe;
Nomes iniciados com __ (dunder/duplo underline): s√£o considerados ‚Äúprivados‚Äú, como os atributos __ligado e __velocidade.
‚ö†Ô∏è N√£o ser√° poss√≠vel fazer o acesso diretamente por fora da classe, mas existem formas de burlar isso (caso queira saber mais pesquise name mangling);
Quaisquer outros nomes v√°lidos: s√£o p√∫blicos.
Para ilustrar, vamos voltar ao exemplo do liquidificador.

Como podemos proteger o atributo ligado, de forma que fique simples e seguro alter√°-lo? Resposta: com os m√©todos.

Podemos criar os m√©todos ligar e desligar e daremos poderes para que eles consigam manipular os atributos.

Observe o c√≥digo a seguir:

EX:

class Liquidificador:
    def __init__(self, cor, potencia, tensao, preco):
        self.preco = preco
        self.cor = cor
        self._potencia = potencia
        self._tensao = tensao
        self.__ligado = False
        self.__velocidade = 0
        self.__velocidade_maxima = 3
        self.__corrente_atual_no_motor = 0

    def ligar(self, velocidade):
        if velocidade > self.__velocidade_maxima or velocidade < 0:
            raise ValueError(
                f"Velocidade deve estar entre 0 e {self.__velocidade_maxima}"
            )

        self.__velocidade = velocidade
        self.__corrente_atual_no_motor = (
            (self._potencia / self._tensao) / self.__velocidade_maxima
        ) * velocidade
        self.__ligado = True

    def desligar(self):
        self.__ligado = False
        self.__velocidade = 0

    def esta_ligado(self):
        return self.__ligado
        
        
* Qual visibilidade usar:

Diferentemente de linguagens mais rigorosas como o Java, onde a filosofia √© criar atributos privados por padr√£o, no Python foi adotada a filosofia oposta: por padr√£o os atributos e m√©todos s√£o p√∫blicos. Isso facilita muito a vida de quem est√° desenvolvendo, sem inserir complexidades desnecess√°rias.

‚ÄúSimples √© melhor que complicado‚Äù - Zen do Python.

Entretanto, muitas vezes precisamos indicar que algo n√£o deve ser utilizado por quem n√£o est√° dentro do contexto da classe, pois algo inesperado pode acontecer.
Um exemplo √© quando um atributo foi feito para ser somente lido por quem est√° fora da classe, mas sua valora√ß√£o deve ser feita seguindo alguma l√≥gica interna.
Para esses casos, a conven√ß√£o √© utilizar somente um underline, sem proibir ningu√©m de acessar caso queira.

Utilizar dois underlines quase nunca √© necess√°rio e n√£o costuma acontecer, a n√£o ser que voc√™ precise esconder algo at√© mesmo das subclasses.

Observa√ß√£o importante: apesar da filosofia da linguagem ser a de deixar m√©todos e atributos p√∫blicos por padr√£o, isso n√£o significa que voc√™ n√£o deve se preocupar em torn√°-los privados. O ponto √© simples: voc√™ come√ßa criando as coisas de maneira p√∫blica para facilitar o desenvolvimento, e assim que observar que algo n√£o deve ser acessado por fora da classe, voc√™ coloca um underline na frente. N√£o √© pra simplesmente ignorar esse passo e nunca criar atributos protegidos ou privados.


* Abstra√ß√£o:

A abstra√ß√£o de dados √© outro pilar da orienta√ß√£o a objetos, e oculta os detalhes da implementa√ß√£o mostrando apenas a funcionalidade para quem acessa os m√©todos, a fim de reduzir a complexidade do c√≥digo.

Perceba que, ao chamarmos o m√©todo ligar, n√£o existe a necessidade de conhecer o c√°lculo interno. Aqui estamos aplicando a abstra√ß√£o, pois apenas o c√≥digo da classe Liquidificador precisa se preocupar com a regra de neg√≥cio. Quando utilizarmos a classe em outra parte da aplica√ß√£o, precisaremos apenas saber quais s√£o os par√¢metros necess√°rios de cada m√©todo.

EX:

liquidificador_vermelho = Liquidificador("Vermelho", 250, 220, 100)
liquidificador_vermelho.ligar(1)
print("Est√° ligado?", liquidificador_vermelho.esta_ligado())
# Est√° ligado? True
liquidificador_vermelho.desligar()
print("Est√° ligado?", liquidificador_vermelho.esta_ligado())
# Est√° ligado? False


# Getters e Setters:

Mostramos no exemplo anterior como criar um m√©todo que permite ligar o liquidificador. Para isso, ele acessa e altera alguns atributos privados. Existe uma outra forma de manipular atributos privados de maneira indireta, utilizando m√©todos denominados getters e setters.

Um m√©todo setter implementa a l√≥gica de como alterar um valor. Um m√©todo getter implementa a l√≥gica de como recuperar um valor.

EX:

class Liquidificador:
    def get_cor(self):
        return self.__cor.upper()

    def set_cor(self, nova_cor):
        if nova_cor.lower() == "turquesa":
            raise ValueError("N√£o existe liquidificador turquesa")

        self.__cor = nova_cor

    def __init__(self, cor, potencia, tensao, preco):
        # Observe que usamos o setter para j√° validarmos o primeiro valor
        self.set_cor(cor)

        # Demais vari√°veis omitidas para este exemplo


liquidificador = Liquidificador("Azul", "110", "127", "200")

# print(f"A cor atual √© {liquidificador.__cor}")
# AttributeError: 'Liquidificador' object has no attribute '__cor'

print(f"A cor atual √© {liquidificador.get_cor()}")
# A cor atual √© AZUL
liquidificador.set_cor("Preto")
print(f"Ap√≥s pintarmos, a nova cor √© {liquidificador.get_cor()}")
# Ap√≥s pintarmos, a nova cor √© PRETO

Como podemos ver, o acesso ao atributo privado liquidificador.__cor gera um erro, mas chamar o m√©todo get_cor() funciona perfeitamente. O comportamento √© similar para o acesso: liquidificador.__cor = "alguma cor" gera um erro, mas liquidificador.set_cor("alguma cor") n√£o (desde que a cor n√£o seja turquesa).

* Especificidades do Python

M√©todos com prefixos get_ e set_ costumam, em Python, ser substitu√≠dos por uma forma de acesso mais transparente, para que possam ser utilizados como se fossem atributos p√∫blicos. Para isso s√£o utilizados os decoradores (decorators) @property e @propriedade.setter, como no exemplo abaixo:

EX:

class Liquidificador:
    # Getter
    @property
    def cor(self):
        return self.__cor.upper()

    @cor.setter # Repare que √© @cor.setter, e n√£o @property.setter
    def cor(self, nova_cor):
        if nova_cor.lower() == "turquesa":
            raise ValueError("N√£o existe liquidificador turquesa")

        self.__cor = nova_cor

    def __init__(self, cor, potencia, tensao, preco):
        # Observe que usamos o setter para j√° validarmos o primeiro valor:
        # usamos self.cor, que chama o setter, e n√£o self.__cor que manipula
        # o atributo diretamente
        self.cor = cor

        # Demais vari√°veis omitidas para este exemplo


liquidificador = Liquidificador("Rosa", "110", "127", "200")

print(liquidificador.cor) # ROSA
liquidificador.cor = "Vermelho"
print(liquidificador.cor) # VERMELHO
Com isso podemos acessar o m√©todo cor e decor√°-lo com o @property para facilitar o acesso de fora liquidificador.cor.

√â poss√≠vel criar um outro m√©todo tamb√©m com o nome cor e decorar com @cor.setter. Ele deve receber, al√©m de self, um segundo par√¢metro que √© o novo valor de cor. A partir disso a atribui√ß√£o liquidificador.cor = "Vermelho" passa a funcionar.

Motivos para deixar um atributo privado ser alterado por meio de setters
Em algumas ocasi√µes √© necess√°rio realizar a valida√ß√£o do novo valor. Neste exemplo n√≥s impedimos a cria√ß√£o de um liquidificador cuja cor seja turquesa.

As vezes √© necess√°rio at√© mesmo alterar ou consultar outros atributos privados enquanto realizamos a modifica√ß√£o.

Motivos para deixar um atributo privado ser obtido por meio de getters
Em algumas ocasi√µes √© necess√°rio padronizar a sa√≠da independentemente do valor interno. Neste exemplo n√≥s s√≥ retornamos a cor em letras mai√∫sculas.

Geralmente o getter s√≥ retorna o valor da propriedade, portanto ele existe apenas para que um setter tamb√©m possa existir. √â importante ressaltar que, apesar de ser comum existir um getter somente para um setter poder existir, um pode tranquilamente existir sem o outro, ou seja, pode existir um atributo somente leitura (atributo privado + getter), bem como um atributo somente escrita (atributo privado + setter), a depender da necessidade da abstra√ß√£o.


# Composi√ß√£o:

Agora que temos nosso liquidificador funcionando, vamos associ√°-lo a uma pessoa cozinheira, dizendo assim que esta pessoa pode possuir um liquidificador.

‚ö†Ô∏è Aviso: Se atente ao fato de que uma pessoa n√£o √© da mesma classe que um liquidificador, ela possui um liquidificador. Neste caso, precisamos utilizar o conceito de Composi√ß√£o.

Anota a√≠ ‚úèÔ∏è: Composi√ß√£o √© atribuir o objeto de uma classe a um atributo da outra, gerando assim um relacionamento de pertencimento entre elas. Voc√™ pode ver mais aqui.

Observe o exemplo abaixo que aplica esse conceito:

EX:

class Pessoa:
    def __init__(self, nome, saldo_na_conta):
        self.nome = nome
        self.saldo_na_conta = saldo_na_conta
        self.liquidificador = None

    def comprar_liquidificador(self, liquidificador):
        if liquidificador.preco <= self.saldo_na_conta:
            self.saldo_na_conta -= liquidificador.preco
            self.liquidificador = liquidificador
            
Agora, a classe Pessoa tem o m√©todo espec√≠fico para comprar seu liquidificador:

EX:

pessoa_cozinheira = Pessoa("Jacquin", 1000)
pessoa_cozinheira.comprar_liquidificador(liquidificador_vermelho)

Pronto, codamos a nossa entidade! üòÑ

* O que ser√° que acontece em Python se a gente realizar o print deste novo objeto?

Ao imprimir a inst√¢ncia de um objeto, o Python exibe a posi√ß√£o de mem√≥ria do objeto.

EX:

print(pessoa_cozinheira)
# retorno: Pessoa object at 0x7f53bbe1b580>

Uma forma de melhorar esta apresenta√ß√£o, √© implementar o m√©todo __str__ para a classe que deseja imprimir. Assim o Python substituir√° o print padr√£o pelo retorno que voc√™ desejar. Veja esse exemplo:

EX:

class Pessoa:
# ....
    def __str__(self):
        return f"{self.nome} - possui {self.saldo_na_conta} reais em sua conta."

print(pessoa_cozinheira)
# retorno: Jacquin - possui 800 reais em sua conta.


# Heran√ßa:

Pensando em eletr√¥nicos, alguns deles possuem caracter√≠sticas em comum, n√£o √© mesmo? Exemplos: tens√£o, pot√™ncia, ligado ou desligado e cor. Com isso, podemos perceber que para o construtor de ventilador, televis√£o e liquidificador, sempre teremos atributos id√™nticos.

Voc√™ pode estar refletindo: ‚ÄúRepetir tanto c√≥digo n√£o √© eficiente, correto?‚Äù

Sim! E a boa not√≠cia √© que podemos evitar essa repeti√ß√£o com o conceito de heran√ßa, criando assim uma classe Eletrodomestico. Neste sentido, as classes ventilador, batedeira, m√°quina de lavar e secador ser√£o suas filhas, ou seja, herdar√£o dela.

Anota a√≠ ‚úèÔ∏è: Heran√ßa √© especializar o comportamento de uma classe, ou seja, a classe herdeira √© tudo que a classe ascendente √© e talvez um pouco mais!

Veja o exemplo a seguir:

EX:

class Eletrodomestico:
    def __init__(self, cor, potencia, tensao, preco):
        self.preco = preco
        self.cor = cor
        self._potencia = potencia
        self._tensao = tensao
        self.__ligado = False
        self.__velocidade = 0
        self.__velocidade_maxima = 3
        self.__corrente_atual_no_motor = 0

    def ligar(self, velocidade):
        if velocidade > self.__velocidade_maxima or velocidade < 0:
            raise ValueError(
                f"Velocidade deve estar entre 0 e {self.__velocidade_maxima}"
            )

        self.__velocidade = velocidade
        self.__corrente_atual_no_motor = (
            (self._potencia / self._tensao) / self.__velocidade_maxima
        ) * velocidade
        self.__ligado = True

    def desligar(self):
        self.__ligado = False
        self.__velocidade = 0

    def esta_ligado(self):
        return self.__ligado

    @property
    def cor(self):
        return self.__cor.upper()

    @cor.setter
    def cor(self, nova_cor):
        self.__cor = nova_cor
        
Em Python, para declarar que um objeto herda as caracter√≠sticas de outro, basta na declara√ß√£o da classe ‚Äúpassarmos como par√¢metro‚Äù a classe que ser√° herdada. V√°rias classes podem ser passadas para realizar a heran√ßa m√∫ltipla, mas isso foge do escopo desta aula. Caso queira, veja mais sobre heran√ßa m√∫ltipla aqui.

* Vamos ver um exemplo de como podemos fazer um Liquidificador herdar de Eletrodomestico:

EX:

class Liquidificador(Eletrodomestico):
    pass
    
S√≥ por herdar de Eletrodomestico, Liquidificador j√° possui acesso a todos os m√©todos e atributos (p√∫blicos e protegidos) definidos em Eletrodomestico. Simples assim. Podemos criar novos m√©todos e atributos que n√£o existem na superclasse a vontade. Novos m√©todos s√≥ precisam ter sua defini√ß√£o, mas novos atributos (declarados no __init__) exigir√£o o uso de polimorfismo.

* Super

Um m√©todo pode chamar um outro m√©todo j√° declarado na superclasse da seguinte maneira:

EX:

class A:
    def faz_algo(self, valor):
        print(valor)


class B(A):
    def faz_outra_coisa(self):
        print("Vou printar o valor pelo m√©todo criado em A")
        # Chama o m√©todo da classe A, que neste caso √© a superclasse, passando
        # o `self` explicitamente
        A.faz_algo(self, valor=1)


b = B()
b.faz_outra_coisa()
# Vou printar o valor pelo m√©todo criado em A
# 1

Observa√ß√£o sobre a linha 11: dada uma classe X qualquer que possua um m√©todo y que recebe self, ou seja, uma classe normal com um m√©todo normal, e um objeto z que √© uma inst√¢ncia dessa classe, as duas chamadas s√£o equivalentes: z.y() e X.y(z). Normalmente utilizamos a primeira, que √© um ‚Äúa√ß√∫car sint√°tico‚Äù para a segunda, para evitar a complexidade de chamar o nome da classe, bem como passar o objeto em quest√£o como par√¢metro.

Mas observe que a chamada comentada cria um acoplamento, ou seja, temos que chamar explicitamente A dentro de um m√©todo de B. Uma forma de melhorar isso √© acessando a superclasse de B (que neste caso √© de fato A) sem cham√°-la explicitamente, delegando a um m√©todo que vai buscar qual que √© a superclasse. Esse m√©todo √© o super(). O exemplo anterior pode ter a linha A.faz_algo(self, valor=1) alterada para super().faz_algo(valor=1). Importante observar a remo√ß√£o do self na passagem de par√¢metros para a faz_algo. Mudar de acesso direto para super n√£o somente n√£o traz nenhum preju√≠zo como ainda traz uma melhoria: Se eu mudar a classe da qual B herda de A para qualquer outra que possua o m√©todo faz_algo, tudo continua a funcionar.

* MRO

Ao utilizar heran√ßa em Python, o m√©todo super busca os m√©todos em uma ordem espec√≠fica das superclasses. Voc√™ pode ler mais sobre o MRO aqui se quiser, mas √© um conte√∫do mais avan√ßado e provavelmente voc√™ n√£o vai precisar para constru√ß√µes n√£o t√£o complexas.

* Herdar mais de uma vez

Apenas a t√≠tulo de curiosidade, √© interessante saber que existe heran√ßa multi-n√≠vel e heran√ßa m√∫ltipla em Python. S√£o conte√∫dos que √© bom voc√™ ao menos ver e saber que existem, mas n√£o se preocupe em se aprofundar neles pois o uso n√£o √© t√£o corriqueiro. D√™ uma olhadinha:

* Heran√ßa multi-n√≠vel

Uma classe pode herdar de outra que herda de outra, ou seja, A herda de B, B herda de C. N√£o h√° diferen√ßas significativas no funcionamento, mas √© interessante saber que √© poss√≠vel e relativamente normal. Por mais que voc√™ n√£o escreva algo assim, √© poss√≠vel que veja bastante em c√≥digos de outras pessoas.

Exemplo:

EX:

class C: # C 
    def x(self): # m√©todo de exemplo
        print(1)

class B(C): # B herda de C
    pass

class A(B): # A herda de B
    pass


a = A()
a.x()
# 1

Ao acessar a.x() o m√©todo x √© buscado no objeto a, depois na classe A, depois na classe B, depois na classe C, subindo por toda a hierarquia de classes at√© ser encontrado ou levantar um AttributeError.

* Heran√ßa m√∫ltipla

Em Python existe tamb√©m a chamada heran√ßa m√∫ltipla, n√£o t√£o comum a outras linguagens, que √© a capacidade que uma classe tem de herdar de mais de uma classe ao mesmo tempo. Ou seja, uma classe A pode herdar de B e C simultaneamente, sem que haja heran√ßa multi-n√≠vel.

EX:

class A(B, C): 
    pass
    
‚ö†Ô∏è Importante: o uso de heran√ßa m√∫ltipla √© bastante desencorajado, pois gera complexidade extra na hierarquia de classes. Isso exige maior controle da pessoa desenvolvedora sobre o funcionamento impl√≠cito da linguagem, podendo levar a comportamentos inesperados na aplica√ß√£o.


# Polimorfismo:

Polimorfismo √© mais um pilar da orienta√ß√£o a objetos, ocorrendo quando diferentes m√©todos s√£o chamados pelo mesmo nome. Um trecho bem adaptado da Wikip√©dia descreve de forma n√≠tida o conceito de polimorfismo:

O polimorfismo (do grego poli = muitas, morphos = formas) permite que refer√™ncias de tipos de classes mais abstratas representem o comportamento das classes concretas que referenciam, de forma a tratar v√°rios tipos de maneira homog√™nea.

Al√©m da defini√ß√£o, h√° tamb√©m um trecho que d√° mais nitidez ao significado pr√°tico disso:

O polimorfismo √© caracterizado quando duas ou mais classes distintas t√™m m√©todos de mesmo nome, de forma que uma fun√ß√£o possa utilizar um objeto de qualquer uma das classes polim√≥rficas, sem necessidade de tratar de forma diferenciada conforme a classe do objeto.

Existem v√°rios tipos de polimorfismo, mas dois s√£o mais comuns: sobrecarga de m√©todos (method overloading) e sobrescrita de m√©todos (method overriding). Vamos ver cada um deles.

* Sobrecarga de m√©todos

A sobrecarga de m√©todos √© algo que nativamente n√£o existe em Python, mas √© comum em outras linguagens, portanto √© interessante entender. Ela acontece quando mais de um m√©todo pode ser definido com o mesmo nome, mas aceitando par√¢metros em quantidades ou tipos diferentes. Por exemplo, na linguagem C++ podemos ter duas fun√ß√µes com o mesmo nome, func, onde uma recebe um n√∫mero inteiro e outra recebe um caractere.

EX:

// C√≥digo em C++
#include "stdio.h"

int func(int a) { return a + 1; }
int func(char b) { return 4; }

int main() { printf("%d %d", func(1), func('a')); }
// sa√≠da: 2 4

Se chamarmos func() passando um valor inteiro, a primeira fun√ß√£o ser√° chamada, e o retorno ser√° o valor passado + 1. J√° se chamarmos um valor do tipo caractere (char), o retorno ser√° o valor 4. Este n√£o √© um exemplo √∫til, mas coisas bem complexas podem ser feitas por meio da sobrecarga em linguagens que as permitem.

Uma boa explica√ß√£o do motivo para o Python n√£o possuir um suporte nativo para a sobrecarga √© o fato de Python ter tipagem din√¢mica, ou seja, os tipos de dado podem mudar durante a execu√ß√£o do programa. Em C++ os tipos das vari√°veis s√£o definidos antes da execu√ß√£o do c√≥digo, no tempo de compila√ß√£o.

Observa√ß√£o: o c√≥digo acima funciona conforme explicado compilando com o g++, mas n√£o com o gcc. Caso tenha o g++ instalado, voc√™ pode reproduzir o exemplo salvando o conte√∫do em um arquivo e executando o seguinte comando: g++ meu_arquivo.cpp ; ./a.out.


* Par√¢metros opcionais

Apesar de n√£o existir a sobrecarga, √© comum a exist√™ncia de par√¢metros opcionais nas fun√ß√µes e m√©todos, o que a depender do uso pode levar a um funcionamento similar ao de sobrecarga.

Pensando no exemplo da classe Pessoa, para declarar uma nova pessoa informamos a idade, o nome e saldo_na_conta. Mas ser√° que √© necess√°rio? Podemos deixar alguns opcionais? Observe o exemplo a seguir:

EX:

class Pessoa:
    def __init__(self, nome, idade=None, saldo_na_conta=None):
        self.idade = idade
        self.nome = nome
        self.saldo_na_conta = saldo_na_conta
        self.brinquedos = []

pessoa_1 = Pessoa("Marcelo", 22, 700)
pessoa_2 = Pessoa("Matheus")
pessoa_3 = Pessoa("Maria", 33)
pessoa_4 = Pessoa("M√°rcia", saldo_na_conta=100)

Com isso a depender de como chamamos o m√©todo, coisas diferentes ir√£o acontecer. Se passarmos uma idade, ela ser√° valorada como um atributo da pessoa. Se n√£o passarmos, o valor ser√° None. Nesse caso estamos apenas definindo o valor da vari√°vel, mas poder√≠amos ter uma s√©rie de ifs que iriam realizar a√ß√µes diferentes com base nos par√¢metros de entrada, o que n√£o √© uma sobrecarga (pois s√≥ um m√©todo √© declarado), mas se assemelha a ela no uso pr√°tico.


* Sobrescrita de m√©todos

J√° a sobrescrita de m√©todos √© mais comum em qualquer linguagem que possua orienta√ß√£o a objetos. A sobrescrita ocorre quando um m√©todo definido em uma superclasse √© novamente definido (reescrito/sobrescrito) na subclasse.

Vamos continuar de onde paramos na li√ß√£o anterior, onde criamos a classe Liquidificador que herda da classe Eletrodom√©stico. Se quisermos, podemos reescrever alguns m√©todos de forma a deix√°-los mais convenientes para o nosso uso. Para realizar a sobrescrita, basta declarar novamente o m√©todo na subclasse. Vamos a um exemplo:

EX:

class Liquidificador(Eletrodomestico):
    def esta_ligado(self):
        return False
        
Este m√©todo n√£o √© nada √∫til visto que sempre retorna False, mas nos ajuda a entender que podemos simplesmente escrever uma nova l√≥gica para um m√©todo.


* Super

Talvez voc√™ j√° conhe√ßa o super, mas vamos ver como ele pode ser √∫til no contexto de sobrescrita de m√©todos. Imagine que voc√™ quer somente melhorar o m√©todo da superclasse, por exemplo mudando o valor que ele retorna. N√£o faz sentido, em diversas ocasi√µes, que voc√™ reescreva tudo e modifique s√≥ algumas coisas. As vezes voc√™ quer reaproveitar o que j√° foi feito e somente dar uma incrementada. √â a√≠ que entra o super.

Lembrando que o super √© uma refer√™ncia √† superclasse, ou seja, a classe da qual voc√™ est√° herdando.

Na verdade no caso do Python, que possui heran√ßa m√∫ltipla, √© uma refer√™ncia √† pr√≥xima classe da MRO (Ordem de Resolu√ß√£o de M√©todos).

Por meio dessa refer√™ncia, voc√™ pode acessar m√©todos da superclasse por meio da subclasse. Para isso utilizamos a nota√ß√£o super().m√©todo().

EX:

class Liquidificador(Eletrodomestico):
    def esta_ligado(self):
        return "Sim" if super().esta_ligado() else "N√£o"
        
Neste exemplo em espec√≠fico n√≥s modificamos o tipo de retorno do m√©todo esta_ligado, retornando strings ao inv√©s de um booleano (isso √© uma m√° pr√°tica pois fere o princ√≠pio de substitui√ß√£o de Liskov, mas vamos ignorar este detalhe para o exemplo continuar simples). Observe que h√° uma chamada ao mesmo m√©todo na superclasse, de forma a n√£o precisar recriar a l√≥gica dele na subclasse. Neste caso aqui √© algo simples, pois √© s√≥ o retorno de um booleano, mas Eletrodomestico.esta_ligado poderia ser um m√©todo complexo e custoso, fazendo com que reaproveit√°-lo seja a melhor escolha.

Vamos ver um exemplo de como informar que o Ventilador e o Liquidificador herdam da classe Eletrodomestico:

EX:

class Liquidificador(Eletrodomestico):
    pass

class Ventilador(Eletrodomestico):
    def __init__(self, cor, potencia, tensao, preco, quantidade_de_portas=1):
        # Chamada ao construtor da superclasse
        super().__init__(cor, potencia, tensao, preco)
        
        # Faz outras coisas espec√≠ficas dessa subclasse
        self.quantidade_de_portas = quantidade_de_portas


class Pessoa:
    def __init__(self, nome, saldo_na_conta):
        self.nome = nome
        self.saldo_na_conta = saldo_na_conta
        self.eletrodomesticos = []

    # Permite a aquisi√ß√£o de qualquer eletrodom√©stico
    def comprar_eletrodomestico(self, eletrodomestico):
        if eletrodomestico.preco <= self.saldo_na_conta:
            self.saldo_na_conta -= eletrodomestico.preco
            self.eletrodomestico.append(eletrodomestico)
            
Ao sobrescrever o construtor, devemos chamar o construtor da superclasse tamb√©m, de forma a garantir que ele seja executado e o que ele faz seja aproveitado. Caso n√£o fa√ßa isso, como em qualquer m√©todo normal, voc√™ ter√° de re-implementar a l√≥gica do construtor da superclasse manualmente na subclasse.

De olho na dica üëÄ: Se voc√™ quiser sobrescrever m√©todos decorados com o @property, precisar√° fazer algumas adapta√ß√µes na superclasse. D√™ uma olhada nesta resposta no stack overflow para mais informa√ß√µes.

* Polimorfismo com interface

O polimorfismo com interfaces se utiliza da sobrescrita de m√©todos de uma maneira muito interessante para garantir que, mesmo esperando um item do tipo da superclasse, ele tenha m√©todos devidamente implementados na subclasse. E isso se d√° por meio de classes abstratas.

* Classe abstrata

Uma classe abstrata √© aquela que n√£o pode possuir inst√¢ncias a partir dela, existindo apenas para ser herdada.

Na verdade o Python √© uma linguagem t√£o permissiva que voc√™ at√© consegue criar inst√¢ncias da classe abstrata, mas conceitualmente √© algo que n√£o deve ser feito.

Geralmente classes mais gen√©ricas s√£o abstratas, e classes mais espec√≠ficas herdam delas. Por exemplo podemos ter uma classe Database que √© abstrata e duas classes normais que herdam dela: MongoDatabase e MySQLDatabase. A classe Database pode vir com alguns m√©todos prontos para as classes que herdam dela utilizarem, podem ter m√©todos abstratos ou ambos ou at√© mesmo nenhum m√©todo (sendo uma classe puramente conceitual).

Para criar uma classe abstrata em Python, basta criar uma classe que herda de abc.ABC:

EX:

from abc import ABC


class Database(ABC):
    pass
    
    
* M√©todos abstratos

Nas classes abstratas podemos ter (mas n√£o temos a obriga√ß√£o de ter) alguns m√©todos abstratos, que s√£o m√©todos que n√£o possuem uma implementa√ß√£o, e servem para obrigar a classe normal que herda da classe abstrata a implement√°-los (por meio da sobrescrita de m√©todos). Por exemplo, na classe Database podemos ter o m√©todo abstrato connect. Esse m√©todo n√£o possui implementa√ß√£o em Database, mas MongoDatabase e MySQLDatabase, classes normais, s√£o obrigadas a implement√°-lo.

Para declarar um m√©todo como abstrato, utilizamos o decorador @abc.abstractmethod, e preenchemos o corpo do m√©todo com um pass, com Ellipsis (...) ou com um raise NotImplementedError:

EX:

from abc import ABC, abstractmethod


class Database(ABC):
    @abstractmethod
    def execute(self, query):
        ...


class MongoDatabase(Database):
    def execute(self, query):
        print(f"executando query '{query}' no mongo")


class MySQLDatabase(Database):
    def execute(self, query):
        print(f"executando query '{query}' no mysql")
        
        
* Mix de classes abstratas

Uma classe abstrata pode herdar de outra classe abstrata, e ent√£o pode ou n√£o implementar os m√©todos abstratos da superclasse. A primeira classe n√£o abstrata na hierarquia deve implementar todos os m√©todos abstratos que ainda n√£o tiverem sido implementados por uma de suas superclasses.

* Interface

Interfaces s√£o o equivalente a classes abstratas que somente possuem m√©todos abstratos, ou seja, nenhum m√©todo j√° √© implementado. Em algumas linguagens de programa√ß√£o existe uma palavra reservada e uma sintaxe espec√≠fica para a cria√ß√£o e uso de interfaces. Em Python s√£o apenas classes abstratas comuns que s√£o herdadas por classes normais.

A diferen√ßa de uma classe abstrata para uma interface √© que uma classe abstrata pode possuir m√©todos que as subclasses ir√£o herdar e reaproveitar, enquanto que a interface √© s√≥ um contrato para definir m√©todos que devem ser implementados.

Retomando o exemplo, o fato de Database ter um m√©todo abstrato execute garante que se um objeto √© inst√¢ncia de qualquer classe descendente de Database, com toda certeza ele possui um m√©todo execute implementado. Por isso que as classes normais devem implementar todos os m√©todos abstratos.

EX:

def minha_func(database): # repare que o d √© min√∫sculo
    if isinstance(database, Database):
        database.execute("query qualquer")
    else:
        print(f"{database} n√£o √© um Database v√°lido")

db1 = MongoDatabase()
db2 = MySQLDatabase()

minha_func(db1)
minha_func(db2)
minha_func("db_inv√°lido")

# executando query 'query qualquer' no mongo
# executando query 'query qualquer' no mysql
# db_inv√°lido n√£o √© um Database v√°lido

A fun√ß√£o isinstance retorna se um objeto √© inst√¢ncia de uma classe ou de qualquer uma de suas subclasses.

Pode n√£o parecer t√£o impressionante, mas Python possui type hints, e as tipagens poderiam ser avaliadas em tempo de checagem est√°tica, e n√£o de execu√ß√£o, como foi com o uso de isinstance:

EX:

# repare que coloco o tipo do par√¢metro, ou seja, `database` √© do tipo
# `Database`
def minha_func(database: Database):
    database.execute("query qualquer")
    
Colocar a tipagem deixa a fun√ß√£o mais simples, pois n√£o ser√° necess√°rio confirmar em tempo de execu√ß√£o que database √© de fato uma inst√¢ncia de Database. Antes mesmo de rodar o programa j√° receberia um erro no vs code ao chamar minha_func("db_inv√°lido").

Se quiser saber mais sobre tipagem, pesquise as diferen√ßas entre tipagem estrutural em tempo de execu√ß√£o (duck typing ou tipagem pato), tipagem nominal em tempo de execu√ß√£o (goose typing ou tipagem ganso), tipagem est√°tica (type hints ou dicas de tipos) e tipagem estrutural est√°tica (duck typing est√°tico por meio da classe typing.Protocol). O Python suporta todas as 4.


# M√©todos est√°ticos e de classe:

Por vezes √© necess√°rio trabalhar com atributos e m√©todos que n√£o est√£o relacionados com a inst√¢ncia, no caso, com o objeto.
Nestes casos existem atributos e m√©todos de classe, que servem para manipular a classe em si, e m√©todos est√°ticos, que n√£o possuem nenhuma rela√ß√£o (a n√£o ser a sem√¢ntica) com as classes ou inst√¢ncias.
Vamos come√ßar pelo mais simples.

* M√©todos est√°ticos

M√©todos est√°ticos s√£o fun√ß√µes normais, s√≥ que dentro de uma classe.
Apesar disso, o significado sem√¢ntico √© ‚Äúuma fun√ß√£o que n√£o precisa de dados nem do objeto (inst√¢ncia) nem da classe, mas faz sentido ser chamada a partir de um deles‚Äù.
O uso √© muito incomum, visto que voc√™ pode colocar uma fun√ß√£o no mesmo m√≥dulo que a classe que voc√™ est√° utilizando, mas a forma de acesso √© mais transparente, o que pode ajudar a garantir o pilar de abstra√ß√£o.

O uso √© feito por meio do decorador @staticmethod, que n√£o precisa ser importado, visto que j√° est√° no escopo global.

EX:

class Classe:
    @staticmethod
    def m√©todo_est√°tico():
        print("Ol√°")


objeto = Classe()
Classe.m√©todo_est√°tico()
objeto.m√©todo_est√°tico()
# Sa√≠da:
# Ol√°
# Ol√°

Observe que d√° pra acessar o m√©todo est√°tico tanto a partir da classe quanto a partir do objeto.

* Atributos de classe

N√£o s√≥ os objetos, mas as classes tamb√©m podem possuir atributos.
Esta funcionalidade √© interessante para servir como um valor padr√£o caso o atributo n√£o seja valorado (ou seja, tenha um valor atribu√≠do a ele) no objeto, mas mais do que isso, √© muito mais interessante quando utilizada para compartilhar informa√ß√£o entre as diversas inst√¢ncias.

Atributos da classe s√£o declarados no n√≠vel (escopo) da classe (no mesmo n√≠vel que os m√©todos).
Eles podem ser acessados tanto pela classe quanto pelos objetos.
Eles podem ser alterados ou pelo acesso feito a partir da classe ou por m√©todos de classe. Se voc√™ tentar alterar a partir de um objeto vai apenas setar um atributo do objeto com o mesmo nome.

EX:

class Classe:
    atributo_da_classe = 1


objeto_1 = Classe()
objeto_2 = Classe()

print(Classe.atributo_da_classe)  # Sa√≠da: 1
print(objeto_1.atributo_da_classe)  # Sa√≠da: 1
print(objeto_2.atributo_da_classe)  # Sa√≠da: 1

Classe.atributo_da_classe = 2
print(Classe.atributo_da_classe)  # Sa√≠da: 2
print(objeto_1.atributo_da_classe)  # Sa√≠da: 2
print(objeto_2.atributo_da_classe)  # Sa√≠da: 2

objeto_1.atributo_da_classe = 3
print(Classe.atributo_da_classe)  # Sa√≠da: 2
print(objeto_1.atributo_da_classe)  # Sa√≠da: 3
print(objeto_2.atributo_da_classe)  # Sa√≠da: 2

No print 1 √© o acesso feito diretamente pela classe.
Nos prints 2 e 3 observe que mesmo o objeto n√£o tendo o atributo definido, a classe tem, portanto o acesso tamb√©m funciona.
Nos prints 4, 5 e 6 podemos ver que mudar o atributo diretamente na classe reflete a mudan√ßa em todos os objetos.
J√° nos prints 7, 8 e 9 podemos ver que o valor muda para 3 somente no objeto_1. Isso significa que foi criado um atributo de objeto/inst√¢ncia com o mesmo nome, portanto o atributo da classe n√£o foi utilizado.

* M√©todos de classe

Como foi dito, a outra forma de alterar atributos da classe √© por meio de m√©todos de classe.
Diferentemente dos m√©todos normais, estes n√£o precisam de dados da inst√¢ncia, mas diferentemente de m√©todos est√°ticos, eles precisam de dados da classe.

Eles funcionam por meio do decorador @classmethod, que, assim como o @staticmethod, tamb√©m est√° dispon√≠vel no escopo global, e recebem um primeiro par√¢metro cls, que referencia a classe.

EX:

class Classe:
    _atributo_da_classe = 1

    @classmethod
    def seta_atributo_da_classe(cls, valor):
        cls._atributo_da_classe = valor

    @classmethod
    def retorna_atributo_da_classe(cls):
        return cls._atributo_da_classe


objeto_1 = Classe()
objeto_2 = Classe()

print(Classe.retorna_atributo_da_classe())  # Sa√≠da: 1
print(objeto_1.retorna_atributo_da_classe())  # Sa√≠da: 1
print(objeto_2.retorna_atributo_da_classe())  # Sa√≠da: 1

Classe.seta_atributo_da_classe(2)
print(Classe.retorna_atributo_da_classe())  # Sa√≠da: 2
print(objeto_1.retorna_atributo_da_classe())  # Sa√≠da: 2
print(objeto_2.retorna_atributo_da_classe())  # Sa√≠da: 2

objeto_1.seta_atributo_da_classe(3)
print(Classe.retorna_atributo_da_classe())  # Sa√≠da: 3
print(objeto_1.retorna_atributo_da_classe())  # Sa√≠da: 3
print(objeto_2.retorna_atributo_da_classe())  # Sa√≠da: 3
Como podemos ver, o acesso √© feito de maneira transparente, sem precisar passar explicitamente o par√¢metro cls.

A prop√≥sito, tal como o self, cls √© apenas uma conven√ß√£o, podendo receber outros nomes.
√â comum confundir e escrever um classmethod que recebe self, o que n√£o vai quebrar o programa, mas √© importante saber que independentemente do nome o par√¢metro ser√° uma refer√™ncia √† classe, e n√£o ao objeto.

A diferen√ßa desse exemplo para o anterior √© que acessar o m√©todo de classe a partir do objeto pode alterar atributos de classe, tal como na linha que seta o atributo para o valor 3 a partir da chamada objeto_1.seta_atributo_da_classe(3): apesar de chamado do objeto, o m√©todo altera o valor do atributo da classe, refletindo a altera√ß√£o em todas as inst√¢ncias. Com isso √© poss√≠vel realizar uma comunica√ß√£o entre as inst√¢ncias da classe.

* Chamando m√©todos

Em Python a chamada de m√©todos pode ser feita de algumas formas diferentes.

√â bom salientar que o acesso de m√©todos de inst√¢ncia, de classe e est√°ticos podem ser feitos de forma transparente, isto √©, ao chamar objeto.m√©todo(par√¢metro) voc√™ n√£o sabe se o m√©todo √© da inst√¢ncia, de classe ou est√°tico, o que ajuda na abstra√ß√£o e facilidade do uso.
O Python preenche os valores de self e cls de maneira adequada quando eles existem, e n√£o passa nenhum par√¢metro adicional pra um m√©todo est√°tico.

Segue uma listagem mais completa para sintetizar:

EX:

# Arquivo main.py
class Classe:
    atributo_da_classe = 1

    def __init__(self):
        self.atributo_do_objeto = 2

    def m√©todo_normal(self):
        print(self)

    @classmethod
    def m√©todo_de_classe(cls):
        print(cls)

    @staticmethod
    def m√©todo_est√°tico():
        print("Ol√°")


objeto = Classe()

# Acessando atributo do objeto
print(objeto.atributo_do_objeto)
# N√£o d√° pra chamar usando a classe (Classe.atributo_do_objeto d√° erro)
# Sa√≠da:
# 2

# Acessando atributo da classe
print(Classe.atributo_da_classe)
print(objeto.atributo_da_classe) 
# Sa√≠da:
# 1
# 1

# Chamando o m√©todo normal
Classe.m√©todo_normal(objeto)  # Ou Classe.m√©todo_normal(self=objeto)
objeto.m√©todo_normal() # A√ß√∫car sint√°tico para a forma da linha acima
# Sa√≠da:
# <__main__.Classe object at 0x7f2304ab3d30>
# <__main__.Classe object at 0x7f2304ab3d30>

# Chamando o m√©todo est√°tico
Classe.m√©todo_est√°tico()
objeto.m√©todo_est√°tico()
# Sa√≠da:
# Ol√°
# Ol√°

# Chamando o m√©todo de classe
Classe.m√©todo_de_classe()  # Observe que n√£o precisa passar nenhum par√¢metro
objeto.m√©todo_de_classe() 
# Sa√≠da:
# <class '__main__.Classe'>
# <class '__main__.Classe'>




