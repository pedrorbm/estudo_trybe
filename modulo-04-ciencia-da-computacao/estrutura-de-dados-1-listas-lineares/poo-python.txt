# MÃ©todo Construtor/Inicializador:

* ApÃ³s modelada nossa Classe do objeto, podemos partir para o construtor. O construtor Ã© um mÃ©todo especial que roda automaticamente quando a gente cria (instancia) o objeto. Na maioria das linguagens, o construtor cria e devolve a instÃ¢ncia do objeto e jÃ¡ inicializa os seus atributos.

Em python, esta operaÃ§Ã£o Ã© dividida em dois mÃ©todos:

EX:

__new__ (Construtor)
__init__ (Inicializador)
Copiar
class Exemplo:
    def __init__(self):
        print("Inicializando Exemplo")
        self.__privado = "Eu sou privado"

    def __new__(cls, *args, **kwargs):
        print("Criando uma nova instÃ¢ncia de Exemplo")
        instance = super().__new__(cls)
        return instance

    def __metodo_privado(self):
        print("Este Ã© um mÃ©todo privado")

    def metodo_publico(self):
        print("Este Ã© um mÃ©todo pÃºblico")
        self.__metodo_privado()
        
Observe que o nome do mÃ©todo privado comeÃ§a com dois sublinhados __. AlÃ©m disso, dentro do construtor __init__, hÃ¡ um atributo que comeÃ§a com dois sublinhados __privado. Isso tambÃ©m Ã© um exemplo de encapsulamento de dados. Para acessar o mÃ©todo privado de dentro da classe, podemos simplesmente chamar o mÃ©todo normalmente. Por exemplo, o mÃ©todo pÃºblico metodo_publico chama o mÃ©todo privado __metodo_privado usando o self.__metodo_privado().

O mÃ©todo __new__ Ã© responsÃ¡vel por criar e retornar uma nova instÃ¢ncia da classe. Ele Ã© uma parte importante da metaprogramaÃ§Ã£o em Python, pois permite que os desenvolvedores personalizem a criaÃ§Ã£o de objetos e controlem como as instÃ¢ncias sÃ£o criadas. Ele tambÃ©m aceita quaisquer argumentos que seriam passados para o mÃ©todo __init__, que sÃ£o capturados pelos parÃ¢metros *args e **kwargs.

No entanto, se tentarmos acessar o mÃ©todo privado a partir de fora da classe, receberemos um erro:

EX:

exemplo = Exemplo()
exemplo.__metodo_privado() # Erro: AttributeError: 'Exemplo' object has no attribute '__metodo_privado'

Isso ocorre porque o mÃ©todo privado sÃ³ pode ser acessado dentro da prÃ³pria classe.

Em resumo, os mÃ©todos privados sÃ£o Ãºteis para manter a integridade do objeto, tornando certos mÃ©todos e atributos acessÃ­veis somente dentro da classe, ocultando a implementaÃ§Ã£o interna e evitando que outras partes do cÃ³digo interfiram no funcionamento da classe.

Anota aÃ­ âœï¸: O Python jÃ¡ implementa estes mÃ©todos por padrÃ£o para cada nova classe criada, mas vocÃª pode implementÃ¡-los novamente, ou seja, sobrescrevÃª-los. Ã‰ desse modo que customizamos nosso construtor/inicializador.

* Importante: Apesar do mÃ©todo __init__ ser â€œapenasâ€ o inicializador, Ã© comum ver referÃªncias a ele como o construtor. Isso acontece pois sÃ£o raras as vezes que precisamos alterar o __new__ para customizar nossas classes. Como a comunidade jÃ¡ adotou que â€œo __init__ Ã© o construtor de objetos no Pythonâ€œ, tambÃ©m vamos seguir essa convenÃ§Ã£o por aqui ðŸ˜‰

Com isso vamos para o segundo passo: basta recriar o mÃ©todo __init__ dentro de nossa classe, conforme exemplo a seguir:

EX:

class Liquidificador:
    def __init__(self, cor, potencia, tensao, preco):
        self.preco = preco
        self.cor = cor
        self._potencia = potencia
        self._tensao = tensao
        self.__ligado = False
        self.__velocidade = 0
        self.__velocidade_maxima = 3
        self.__corrente_atual_no_motor = 0
        
O primeiro parÃ¢metro, o self, representa a instÃ¢ncia do objeto, ou seja, tem acesso ao objeto na memÃ³ria.

De olho na dica ðŸ‘€: Em muitas linguagens tambÃ©m Ã© chamado de this, e como em Python Ã© um parÃ¢metro explÃ­cito, vocÃª pode chamÃ¡-lo como quiser, mas self Ã© uma convenÃ§Ã£o adotada pela comunidade.

Com o mÃ©todo __init__ inicializamos os atributos do objeto apenas atribuindo um valor a cada nova chave. Exemplo: self.__ligado = False.

Os prÃ³ximos parÃ¢metros sÃ£o os que permitem criar de forma customizada nosso objeto, como a cor: self.cor = cor.

De olho na dica ðŸ‘€: No exemplo self.cor = cor, o valor do parÃ¢metro cor do mÃ©todo __init__ Ã© atribuÃ­do ao atributo homÃ´nimo cor do objeto (self.cor). Entretanto o parÃ¢metro cor poderia valorar um atributo qualquer. Um exemplo disso seria se armazenÃ¡ssemos a corrente mÃ¡xima que o motor pode ter: self.corrente_maxima_no_motor = potencia / tensao. Observe como potencia e tensao sÃ£o dois parÃ¢metros utilizados para valorar um Ãºnico atributo.

* Agora podemos criar nossos primeiros liquidificadores:

EX:

meu_liquidificador = Liquidificador("Azul", 200, 127, 200)
seu_liquidificador = Liquidificador(
    cor="Vermelho", potencia=250, tensao=220, preco=100
)

Perceba que Ã© possÃ­vel ter atributos que nÃ£o precisam ser passados por meio de parÃ¢metros na chamada do construtor. Por exemplo, para o booleano __ligado e o inteiro __velocidade, o construtor vai iniciÃ¡-los sempre com os valores fixos (hard coded) False e 0, respectivamente.


# Encapsulamento e AbstraÃ§Ã£o

Agora que jÃ¡ sabemos criar nossos objetos, Ã© essencial sabermos como simplificar seu uso e esconder os detalhes de implementaÃ§Ã£o.

* Encapsulamento:
O encapsulamento Ã© um dos pilares da orientaÃ§Ã£o a objetos. Por meio dele, Ã© possÃ­vel simplificar bastante a implementaÃ§Ã£o da abstraÃ§Ã£o. Assim, segmentamos nossos atributos e mÃ©todos em 3 categorias:

PÃºblicos: podem ser acessados livremente por qualquer parte da aplicaÃ§Ã£o
Protegidos: podem ser acessados apenas pela classe que os definem e, quando hÃ¡ heranÃ§a envolvida, tambÃ©m pelas classes â€œabaixoâ€ na hierarquia (veremos o tÃ³pico heranÃ§a a seguir)
Privados: podem ser acessados apenas pela classe que os definem
Em Python nÃ£o temos palavras reservadas como public, private e protected para declarar um atributo ou mÃ©todo como pÃºblico, privado ou protegido, respectivamente. Para isso, existe uma convenÃ§Ã£o de nomenclatura para definir a acessibilidade de cada recurso:

Nomes iniciados com _ (underline): sÃ£o considerados â€œprotegidosâ€œ, como os atributos _potencia e _tensao.
âš ï¸ Isso Ã© apenas uma convenÃ§Ã£o entre pessoas desenvolvedoras Python, pois ainda serÃ¡ possÃ­vel fazer um acesso direto por fora da classe;
Nomes iniciados com __ (dunder/duplo underline): sÃ£o considerados â€œprivadosâ€œ, como os atributos __ligado e __velocidade.
âš ï¸ NÃ£o serÃ¡ possÃ­vel fazer o acesso diretamente por fora da classe, mas existem formas de burlar isso (caso queira saber mais pesquise name mangling);
Quaisquer outros nomes vÃ¡lidos: sÃ£o pÃºblicos.
Para ilustrar, vamos voltar ao exemplo do liquidificador.

Como podemos proteger o atributo ligado, de forma que fique simples e seguro alterÃ¡-lo? Resposta: com os mÃ©todos.

Podemos criar os mÃ©todos ligar e desligar e daremos poderes para que eles consigam manipular os atributos.

Observe o cÃ³digo a seguir:

EX:

class Liquidificador:
    def __init__(self, cor, potencia, tensao, preco):
        self.preco = preco
        self.cor = cor
        self._potencia = potencia
        self._tensao = tensao
        self.__ligado = False
        self.__velocidade = 0
        self.__velocidade_maxima = 3
        self.__corrente_atual_no_motor = 0

    def ligar(self, velocidade):
        if velocidade > self.__velocidade_maxima or velocidade < 0:
            raise ValueError(
                f"Velocidade deve estar entre 0 e {self.__velocidade_maxima}"
            )

        self.__velocidade = velocidade
        self.__corrente_atual_no_motor = (
            (self._potencia / self._tensao) / self.__velocidade_maxima
        ) * velocidade
        self.__ligado = True

    def desligar(self):
        self.__ligado = False
        self.__velocidade = 0

    def esta_ligado(self):
        return self.__ligado
        
        
* Qual visibilidade usar:

Diferentemente de linguagens mais rigorosas como o Java, onde a filosofia Ã© criar atributos privados por padrÃ£o, no Python foi adotada a filosofia oposta: por padrÃ£o os atributos e mÃ©todos sÃ£o pÃºblicos. Isso facilita muito a vida de quem estÃ¡ desenvolvendo, sem inserir complexidades desnecessÃ¡rias.

â€œSimples Ã© melhor que complicadoâ€ - Zen do Python.

Entretanto, muitas vezes precisamos indicar que algo nÃ£o deve ser utilizado por quem nÃ£o estÃ¡ dentro do contexto da classe, pois algo inesperado pode acontecer.
Um exemplo Ã© quando um atributo foi feito para ser somente lido por quem estÃ¡ fora da classe, mas sua valoraÃ§Ã£o deve ser feita seguindo alguma lÃ³gica interna.
Para esses casos, a convenÃ§Ã£o Ã© utilizar somente um underline, sem proibir ninguÃ©m de acessar caso queira.

Utilizar dois underlines quase nunca Ã© necessÃ¡rio e nÃ£o costuma acontecer, a nÃ£o ser que vocÃª precise esconder algo atÃ© mesmo das subclasses.

ObservaÃ§Ã£o importante: apesar da filosofia da linguagem ser a de deixar mÃ©todos e atributos pÃºblicos por padrÃ£o, isso nÃ£o significa que vocÃª nÃ£o deve se preocupar em tornÃ¡-los privados. O ponto Ã© simples: vocÃª comeÃ§a criando as coisas de maneira pÃºblica para facilitar o desenvolvimento, e assim que observar que algo nÃ£o deve ser acessado por fora da classe, vocÃª coloca um underline na frente. NÃ£o Ã© pra simplesmente ignorar esse passo e nunca criar atributos protegidos ou privados.


* AbstraÃ§Ã£o:

A abstraÃ§Ã£o de dados Ã© outro pilar da orientaÃ§Ã£o a objetos, e oculta os detalhes da implementaÃ§Ã£o mostrando apenas a funcionalidade para quem acessa os mÃ©todos, a fim de reduzir a complexidade do cÃ³digo.

Perceba que, ao chamarmos o mÃ©todo ligar, nÃ£o existe a necessidade de conhecer o cÃ¡lculo interno. Aqui estamos aplicando a abstraÃ§Ã£o, pois apenas o cÃ³digo da classe Liquidificador precisa se preocupar com a regra de negÃ³cio. Quando utilizarmos a classe em outra parte da aplicaÃ§Ã£o, precisaremos apenas saber quais sÃ£o os parÃ¢metros necessÃ¡rios de cada mÃ©todo.

EX:

liquidificador_vermelho = Liquidificador("Vermelho", 250, 220, 100)
liquidificador_vermelho.ligar(1)
print("EstÃ¡ ligado?", liquidificador_vermelho.esta_ligado())
# EstÃ¡ ligado? True
liquidificador_vermelho.desligar()
print("EstÃ¡ ligado?", liquidificador_vermelho.esta_ligado())
# EstÃ¡ ligado? False


# Getters e Setters:

Mostramos no exemplo anterior como criar um mÃ©todo que permite ligar o liquidificador. Para isso, ele acessa e altera alguns atributos privados. Existe uma outra forma de manipular atributos privados de maneira indireta, utilizando mÃ©todos denominados getters e setters.

Um mÃ©todo setter implementa a lÃ³gica de como alterar um valor. Um mÃ©todo getter implementa a lÃ³gica de como recuperar um valor.

EX:

class Liquidificador:
    def get_cor(self):
        return self.__cor.upper()

    def set_cor(self, nova_cor):
        if nova_cor.lower() == "turquesa":
            raise ValueError("NÃ£o existe liquidificador turquesa")

        self.__cor = nova_cor

    def __init__(self, cor, potencia, tensao, preco):
        # Observe que usamos o setter para jÃ¡ validarmos o primeiro valor
        self.set_cor(cor)

        # Demais variÃ¡veis omitidas para este exemplo


liquidificador = Liquidificador("Azul", "110", "127", "200")

# print(f"A cor atual Ã© {liquidificador.__cor}")
# AttributeError: 'Liquidificador' object has no attribute '__cor'

print(f"A cor atual Ã© {liquidificador.get_cor()}")
# A cor atual Ã© AZUL
liquidificador.set_cor("Preto")
print(f"ApÃ³s pintarmos, a nova cor Ã© {liquidificador.get_cor()}")
# ApÃ³s pintarmos, a nova cor Ã© PRETO

Como podemos ver, o acesso ao atributo privado liquidificador.__cor gera um erro, mas chamar o mÃ©todo get_cor() funciona perfeitamente. O comportamento Ã© similar para o acesso: liquidificador.__cor = "alguma cor" gera um erro, mas liquidificador.set_cor("alguma cor") nÃ£o (desde que a cor nÃ£o seja turquesa).

* Especificidades do Python

MÃ©todos com prefixos get_ e set_ costumam, em Python, ser substituÃ­dos por uma forma de acesso mais transparente, para que possam ser utilizados como se fossem atributos pÃºblicos. Para isso sÃ£o utilizados os decoradores (decorators) @property e @propriedade.setter, como no exemplo abaixo:

EX:

class Liquidificador:
    # Getter
    @property
    def cor(self):
        return self.__cor.upper()

    @cor.setter # Repare que Ã© @cor.setter, e nÃ£o @property.setter
    def cor(self, nova_cor):
        if nova_cor.lower() == "turquesa":
            raise ValueError("NÃ£o existe liquidificador turquesa")

        self.__cor = nova_cor

    def __init__(self, cor, potencia, tensao, preco):
        # Observe que usamos o setter para jÃ¡ validarmos o primeiro valor:
        # usamos self.cor, que chama o setter, e nÃ£o self.__cor que manipula
        # o atributo diretamente
        self.cor = cor

        # Demais variÃ¡veis omitidas para este exemplo


liquidificador = Liquidificador("Rosa", "110", "127", "200")

print(liquidificador.cor) # ROSA
liquidificador.cor = "Vermelho"
print(liquidificador.cor) # VERMELHO
Com isso podemos acessar o mÃ©todo cor e decorÃ¡-lo com o @property para facilitar o acesso de fora liquidificador.cor.

Ã‰ possÃ­vel criar um outro mÃ©todo tambÃ©m com o nome cor e decorar com @cor.setter. Ele deve receber, alÃ©m de self, um segundo parÃ¢metro que Ã© o novo valor de cor. A partir disso a atribuiÃ§Ã£o liquidificador.cor = "Vermelho" passa a funcionar.

Motivos para deixar um atributo privado ser alterado por meio de setters
Em algumas ocasiÃµes Ã© necessÃ¡rio realizar a validaÃ§Ã£o do novo valor. Neste exemplo nÃ³s impedimos a criaÃ§Ã£o de um liquidificador cuja cor seja turquesa.

As vezes Ã© necessÃ¡rio atÃ© mesmo alterar ou consultar outros atributos privados enquanto realizamos a modificaÃ§Ã£o.

Motivos para deixar um atributo privado ser obtido por meio de getters
Em algumas ocasiÃµes Ã© necessÃ¡rio padronizar a saÃ­da independentemente do valor interno. Neste exemplo nÃ³s sÃ³ retornamos a cor em letras maiÃºsculas.

Geralmente o getter sÃ³ retorna o valor da propriedade, portanto ele existe apenas para que um setter tambÃ©m possa existir. Ã‰ importante ressaltar que, apesar de ser comum existir um getter somente para um setter poder existir, um pode tranquilamente existir sem o outro, ou seja, pode existir um atributo somente leitura (atributo privado + getter), bem como um atributo somente escrita (atributo privado + setter), a depender da necessidade da abstraÃ§Ã£o.


# ComposiÃ§Ã£o:

Agora que temos nosso liquidificador funcionando, vamos associÃ¡-lo a uma pessoa cozinheira, dizendo assim que esta pessoa pode possuir um liquidificador.

âš ï¸ Aviso: Se atente ao fato de que uma pessoa nÃ£o Ã© da mesma classe que um liquidificador, ela possui um liquidificador. Neste caso, precisamos utilizar o conceito de ComposiÃ§Ã£o.

Anota aÃ­ âœï¸: ComposiÃ§Ã£o Ã© atribuir o objeto de uma classe a um atributo da outra, gerando assim um relacionamento de pertencimento entre elas. VocÃª pode ver mais aqui.

Observe o exemplo abaixo que aplica esse conceito:

EX:

class Pessoa:
    def __init__(self, nome, saldo_na_conta):
        self.nome = nome
        self.saldo_na_conta = saldo_na_conta
        self.liquidificador = None

    def comprar_liquidificador(self, liquidificador):
        if liquidificador.preco <= self.saldo_na_conta:
            self.saldo_na_conta -= liquidificador.preco
            self.liquidificador = liquidificador
            
Agora, a classe Pessoa tem o mÃ©todo especÃ­fico para comprar seu liquidificador:

EX:

pessoa_cozinheira = Pessoa("Jacquin", 1000)
pessoa_cozinheira.comprar_liquidificador(liquidificador_vermelho)

Pronto, codamos a nossa entidade! ðŸ˜„

* O que serÃ¡ que acontece em Python se a gente realizar o print deste novo objeto?

Ao imprimir a instÃ¢ncia de um objeto, o Python exibe a posiÃ§Ã£o de memÃ³ria do objeto.

EX:

print(pessoa_cozinheira)
# retorno: Pessoa object at 0x7f53bbe1b580>

Uma forma de melhorar esta apresentaÃ§Ã£o, Ã© implementar o mÃ©todo __str__ para a classe que deseja imprimir. Assim o Python substituirÃ¡ o print padrÃ£o pelo retorno que vocÃª desejar. Veja esse exemplo:

EX:

class Pessoa:
# ....
    def __str__(self):
        return f"{self.nome} - possui {self.saldo_na_conta} reais em sua conta."

print(pessoa_cozinheira)
# retorno: Jacquin - possui 800 reais em sua conta.


# HeranÃ§a:

Pensando em eletrÃ´nicos, alguns deles possuem caracterÃ­sticas em comum, nÃ£o Ã© mesmo? Exemplos: tensÃ£o, potÃªncia, ligado ou desligado e cor. Com isso, podemos perceber que para o construtor de ventilador, televisÃ£o e liquidificador, sempre teremos atributos idÃªnticos.

VocÃª pode estar refletindo: â€œRepetir tanto cÃ³digo nÃ£o Ã© eficiente, correto?â€

Sim! E a boa notÃ­cia Ã© que podemos evitar essa repetiÃ§Ã£o com o conceito de heranÃ§a, criando assim uma classe Eletrodomestico. Neste sentido, as classes ventilador, batedeira, mÃ¡quina de lavar e secador serÃ£o suas filhas, ou seja, herdarÃ£o dela.

Anota aÃ­ âœï¸: HeranÃ§a Ã© especializar o comportamento de uma classe, ou seja, a classe herdeira Ã© tudo que a classe ascendente Ã© e talvez um pouco mais!

Veja o exemplo a seguir:

EX:

class Eletrodomestico:
    def __init__(self, cor, potencia, tensao, preco):
        self.preco = preco
        self.cor = cor
        self._potencia = potencia
        self._tensao = tensao
        self.__ligado = False
        self.__velocidade = 0
        self.__velocidade_maxima = 3
        self.__corrente_atual_no_motor = 0

    def ligar(self, velocidade):
        if velocidade > self.__velocidade_maxima or velocidade < 0:
            raise ValueError(
                f"Velocidade deve estar entre 0 e {self.__velocidade_maxima}"
            )

        self.__velocidade = velocidade
        self.__corrente_atual_no_motor = (
            (self._potencia / self._tensao) / self.__velocidade_maxima
        ) * velocidade
        self.__ligado = True

    def desligar(self):
        self.__ligado = False
        self.__velocidade = 0

    def esta_ligado(self):
        return self.__ligado

    @property
    def cor(self):
        return self.__cor.upper()

    @cor.setter
    def cor(self, nova_cor):
        self.__cor = nova_cor
        
Em Python, para declarar que um objeto herda as caracterÃ­sticas de outro, basta na declaraÃ§Ã£o da classe â€œpassarmos como parÃ¢metroâ€ a classe que serÃ¡ herdada. VÃ¡rias classes podem ser passadas para realizar a heranÃ§a mÃºltipla, mas isso foge do escopo desta aula. Caso queira, veja mais sobre heranÃ§a mÃºltipla aqui.

* Vamos ver um exemplo de como podemos fazer um Liquidificador herdar de Eletrodomestico:

EX:

class Liquidificador(Eletrodomestico):
    pass
    
SÃ³ por herdar de Eletrodomestico, Liquidificador jÃ¡ possui acesso a todos os mÃ©todos e atributos (pÃºblicos e protegidos) definidos em Eletrodomestico. Simples assim. Podemos criar novos mÃ©todos e atributos que nÃ£o existem na superclasse a vontade. Novos mÃ©todos sÃ³ precisam ter sua definiÃ§Ã£o, mas novos atributos (declarados no __init__) exigirÃ£o o uso de polimorfismo.

* Super

Um mÃ©todo pode chamar um outro mÃ©todo jÃ¡ declarado na superclasse da seguinte maneira:

EX:

class A:
    def faz_algo(self, valor):
        print(valor)


class B(A):
    def faz_outra_coisa(self):
        print("Vou printar o valor pelo mÃ©todo criado em A")
        # Chama o mÃ©todo da classe A, que neste caso Ã© a superclasse, passando
        # o `self` explicitamente
        A.faz_algo(self, valor=1)


b = B()
b.faz_outra_coisa()
# Vou printar o valor pelo mÃ©todo criado em A
# 1

ObservaÃ§Ã£o sobre a linha 11: dada uma classe X qualquer que possua um mÃ©todo y que recebe self, ou seja, uma classe normal com um mÃ©todo normal, e um objeto z que Ã© uma instÃ¢ncia dessa classe, as duas chamadas sÃ£o equivalentes: z.y() e X.y(z). Normalmente utilizamos a primeira, que Ã© um â€œaÃ§Ãºcar sintÃ¡ticoâ€ para a segunda, para evitar a complexidade de chamar o nome da classe, bem como passar o objeto em questÃ£o como parÃ¢metro.

Mas observe que a chamada comentada cria um acoplamento, ou seja, temos que chamar explicitamente A dentro de um mÃ©todo de B. Uma forma de melhorar isso Ã© acessando a superclasse de B (que neste caso Ã© de fato A) sem chamÃ¡-la explicitamente, delegando a um mÃ©todo que vai buscar qual que Ã© a superclasse. Esse mÃ©todo Ã© o super(). O exemplo anterior pode ter a linha A.faz_algo(self, valor=1) alterada para super().faz_algo(valor=1). Importante observar a remoÃ§Ã£o do self na passagem de parÃ¢metros para a faz_algo. Mudar de acesso direto para super nÃ£o somente nÃ£o traz nenhum prejuÃ­zo como ainda traz uma melhoria: Se eu mudar a classe da qual B herda de A para qualquer outra que possua o mÃ©todo faz_algo, tudo continua a funcionar.

* MRO

Ao utilizar heranÃ§a em Python, o mÃ©todo super busca os mÃ©todos em uma ordem especÃ­fica das superclasses. VocÃª pode ler mais sobre o MRO aqui se quiser, mas Ã© um conteÃºdo mais avanÃ§ado e provavelmente vocÃª nÃ£o vai precisar para construÃ§Ãµes nÃ£o tÃ£o complexas.

* Herdar mais de uma vez

Apenas a tÃ­tulo de curiosidade, Ã© interessante saber que existe heranÃ§a multi-nÃ­vel e heranÃ§a mÃºltipla em Python. SÃ£o conteÃºdos que Ã© bom vocÃª ao menos ver e saber que existem, mas nÃ£o se preocupe em se aprofundar neles pois o uso nÃ£o Ã© tÃ£o corriqueiro. DÃª uma olhadinha:

* HeranÃ§a multi-nÃ­vel

Uma classe pode herdar de outra que herda de outra, ou seja, A herda de B, B herda de C. NÃ£o hÃ¡ diferenÃ§as significativas no funcionamento, mas Ã© interessante saber que Ã© possÃ­vel e relativamente normal. Por mais que vocÃª nÃ£o escreva algo assim, Ã© possÃ­vel que veja bastante em cÃ³digos de outras pessoas.

Exemplo:

EX:

class C: # C 
    def x(self): # mÃ©todo de exemplo
        print(1)

class B(C): # B herda de C
    pass

class A(B): # A herda de B
    pass


a = A()
a.x()
# 1

Ao acessar a.x() o mÃ©todo x Ã© buscado no objeto a, depois na classe A, depois na classe B, depois na classe C, subindo por toda a hierarquia de classes atÃ© ser encontrado ou levantar um AttributeError.

* HeranÃ§a mÃºltipla

Em Python existe tambÃ©m a chamada heranÃ§a mÃºltipla, nÃ£o tÃ£o comum a outras linguagens, que Ã© a capacidade que uma classe tem de herdar de mais de uma classe ao mesmo tempo. Ou seja, uma classe A pode herdar de B e C simultaneamente, sem que haja heranÃ§a multi-nÃ­vel.

EX:

class A(B, C): 
    pass
    
âš ï¸ Importante: o uso de heranÃ§a mÃºltipla Ã© bastante desencorajado, pois gera complexidade extra na hierarquia de classes. Isso exige maior controle da pessoa desenvolvedora sobre o funcionamento implÃ­cito da linguagem, podendo levar a comportamentos inesperados na aplicaÃ§Ã£o.
# 



