# MÃ©todo Construtor/Inicializador:

* ApÃ³s modelada nossa Classe do objeto, podemos partir para o construtor. O construtor Ã© um mÃ©todo especial que roda automaticamente quando a gente cria (instancia) o objeto. Na maioria das linguagens, o construtor cria e devolve a instÃ¢ncia do objeto e jÃ¡ inicializa os seus atributos.

Em python, esta operaÃ§Ã£o Ã© dividida em dois mÃ©todos:

EX:

__new__ (Construtor)
__init__ (Inicializador)
Copiar
class Exemplo:
    def __init__(self):
        print("Inicializando Exemplo")
        self.__privado = "Eu sou privado"

    def __new__(cls, *args, **kwargs):
        print("Criando uma nova instÃ¢ncia de Exemplo")
        instance = super().__new__(cls)
        return instance

    def __metodo_privado(self):
        print("Este Ã© um mÃ©todo privado")

    def metodo_publico(self):
        print("Este Ã© um mÃ©todo pÃºblico")
        self.__metodo_privado()
        
Observe que o nome do mÃ©todo privado comeÃ§a com dois sublinhados __. AlÃ©m disso, dentro do construtor __init__, hÃ¡ um atributo que comeÃ§a com dois sublinhados __privado. Isso tambÃ©m Ã© um exemplo de encapsulamento de dados. Para acessar o mÃ©todo privado de dentro da classe, podemos simplesmente chamar o mÃ©todo normalmente. Por exemplo, o mÃ©todo pÃºblico metodo_publico chama o mÃ©todo privado __metodo_privado usando o self.__metodo_privado().

O mÃ©todo __new__ Ã© responsÃ¡vel por criar e retornar uma nova instÃ¢ncia da classe. Ele Ã© uma parte importante da metaprogramaÃ§Ã£o em Python, pois permite que os desenvolvedores personalizem a criaÃ§Ã£o de objetos e controlem como as instÃ¢ncias sÃ£o criadas. Ele tambÃ©m aceita quaisquer argumentos que seriam passados para o mÃ©todo __init__, que sÃ£o capturados pelos parÃ¢metros *args e **kwargs.

No entanto, se tentarmos acessar o mÃ©todo privado a partir de fora da classe, receberemos um erro:

EX:

exemplo = Exemplo()
exemplo.__metodo_privado() # Erro: AttributeError: 'Exemplo' object has no attribute '__metodo_privado'

Isso ocorre porque o mÃ©todo privado sÃ³ pode ser acessado dentro da prÃ³pria classe.

Em resumo, os mÃ©todos privados sÃ£o Ãºteis para manter a integridade do objeto, tornando certos mÃ©todos e atributos acessÃ­veis somente dentro da classe, ocultando a implementaÃ§Ã£o interna e evitando que outras partes do cÃ³digo interfiram no funcionamento da classe.

Anota aÃ­ âœï¸: O Python jÃ¡ implementa estes mÃ©todos por padrÃ£o para cada nova classe criada, mas vocÃª pode implementÃ¡-los novamente, ou seja, sobrescrevÃª-los. Ã‰ desse modo que customizamos nosso construtor/inicializador.

* Importante: Apesar do mÃ©todo __init__ ser â€œapenasâ€ o inicializador, Ã© comum ver referÃªncias a ele como o construtor. Isso acontece pois sÃ£o raras as vezes que precisamos alterar o __new__ para customizar nossas classes. Como a comunidade jÃ¡ adotou que â€œo __init__ Ã© o construtor de objetos no Pythonâ€œ, tambÃ©m vamos seguir essa convenÃ§Ã£o por aqui ðŸ˜‰

Com isso vamos para o segundo passo: basta recriar o mÃ©todo __init__ dentro de nossa classe, conforme exemplo a seguir:

EX:

class Liquidificador:
    def __init__(self, cor, potencia, tensao, preco):
        self.preco = preco
        self.cor = cor
        self._potencia = potencia
        self._tensao = tensao
        self.__ligado = False
        self.__velocidade = 0
        self.__velocidade_maxima = 3
        self.__corrente_atual_no_motor = 0
        
O primeiro parÃ¢metro, o self, representa a instÃ¢ncia do objeto, ou seja, tem acesso ao objeto na memÃ³ria.

De olho na dica ðŸ‘€: Em muitas linguagens tambÃ©m Ã© chamado de this, e como em Python Ã© um parÃ¢metro explÃ­cito, vocÃª pode chamÃ¡-lo como quiser, mas self Ã© uma convenÃ§Ã£o adotada pela comunidade.

Com o mÃ©todo __init__ inicializamos os atributos do objeto apenas atribuindo um valor a cada nova chave. Exemplo: self.__ligado = False.

Os prÃ³ximos parÃ¢metros sÃ£o os que permitem criar de forma customizada nosso objeto, como a cor: self.cor = cor.

De olho na dica ðŸ‘€: No exemplo self.cor = cor, o valor do parÃ¢metro cor do mÃ©todo __init__ Ã© atribuÃ­do ao atributo homÃ´nimo cor do objeto (self.cor). Entretanto o parÃ¢metro cor poderia valorar um atributo qualquer. Um exemplo disso seria se armazenÃ¡ssemos a corrente mÃ¡xima que o motor pode ter: self.corrente_maxima_no_motor = potencia / tensao. Observe como potencia e tensao sÃ£o dois parÃ¢metros utilizados para valorar um Ãºnico atributo.

* Agora podemos criar nossos primeiros liquidificadores:

EX:

meu_liquidificador = Liquidificador("Azul", 200, 127, 200)
seu_liquidificador = Liquidificador(
    cor="Vermelho", potencia=250, tensao=220, preco=100
)

Perceba que Ã© possÃ­vel ter atributos que nÃ£o precisam ser passados por meio de parÃ¢metros na chamada do construtor. Por exemplo, para o booleano __ligado e o inteiro __velocidade, o construtor vai iniciÃ¡-los sempre com os valores fixos (hard coded) False e 0, respectivamente.


# Encapsulamento e AbstraÃ§Ã£o

Agora que jÃ¡ sabemos criar nossos objetos, Ã© essencial sabermos como simplificar seu uso e esconder os detalhes de implementaÃ§Ã£o.

* Encapsulamento:
O encapsulamento Ã© um dos pilares da orientaÃ§Ã£o a objetos. Por meio dele, Ã© possÃ­vel simplificar bastante a implementaÃ§Ã£o da abstraÃ§Ã£o. Assim, segmentamos nossos atributos e mÃ©todos em 3 categorias:

PÃºblicos: podem ser acessados livremente por qualquer parte da aplicaÃ§Ã£o
Protegidos: podem ser acessados apenas pela classe que os definem e, quando hÃ¡ heranÃ§a envolvida, tambÃ©m pelas classes â€œabaixoâ€ na hierarquia (veremos o tÃ³pico heranÃ§a a seguir)
Privados: podem ser acessados apenas pela classe que os definem
Em Python nÃ£o temos palavras reservadas como public, private e protected para declarar um atributo ou mÃ©todo como pÃºblico, privado ou protegido, respectivamente. Para isso, existe uma convenÃ§Ã£o de nomenclatura para definir a acessibilidade de cada recurso:

Nomes iniciados com _ (underline): sÃ£o considerados â€œprotegidosâ€œ, como os atributos _potencia e _tensao.
âš ï¸ Isso Ã© apenas uma convenÃ§Ã£o entre pessoas desenvolvedoras Python, pois ainda serÃ¡ possÃ­vel fazer um acesso direto por fora da classe;
Nomes iniciados com __ (dunder/duplo underline): sÃ£o considerados â€œprivadosâ€œ, como os atributos __ligado e __velocidade.
âš ï¸ NÃ£o serÃ¡ possÃ­vel fazer o acesso diretamente por fora da classe, mas existem formas de burlar isso (caso queira saber mais pesquise name mangling);
Quaisquer outros nomes vÃ¡lidos: sÃ£o pÃºblicos.
Para ilustrar, vamos voltar ao exemplo do liquidificador.

Como podemos proteger o atributo ligado, de forma que fique simples e seguro alterÃ¡-lo? Resposta: com os mÃ©todos.

Podemos criar os mÃ©todos ligar e desligar e daremos poderes para que eles consigam manipular os atributos.

Observe o cÃ³digo a seguir:

EX:

class Liquidificador:
    def __init__(self, cor, potencia, tensao, preco):
        self.preco = preco
        self.cor = cor
        self._potencia = potencia
        self._tensao = tensao
        self.__ligado = False
        self.__velocidade = 0
        self.__velocidade_maxima = 3
        self.__corrente_atual_no_motor = 0

    def ligar(self, velocidade):
        if velocidade > self.__velocidade_maxima or velocidade < 0:
            raise ValueError(
                f"Velocidade deve estar entre 0 e {self.__velocidade_maxima}"
            )

        self.__velocidade = velocidade
        self.__corrente_atual_no_motor = (
            (self._potencia / self._tensao) / self.__velocidade_maxima
        ) * velocidade
        self.__ligado = True

    def desligar(self):
        self.__ligado = False
        self.__velocidade = 0

    def esta_ligado(self):
        return self.__ligado
        
        
* Qual visibilidade usar:

Diferentemente de linguagens mais rigorosas como o Java, onde a filosofia Ã© criar atributos privados por padrÃ£o, no Python foi adotada a filosofia oposta: por padrÃ£o os atributos e mÃ©todos sÃ£o pÃºblicos. Isso facilita muito a vida de quem estÃ¡ desenvolvendo, sem inserir complexidades desnecessÃ¡rias.

â€œSimples Ã© melhor que complicadoâ€ - Zen do Python.

Entretanto, muitas vezes precisamos indicar que algo nÃ£o deve ser utilizado por quem nÃ£o estÃ¡ dentro do contexto da classe, pois algo inesperado pode acontecer.
Um exemplo Ã© quando um atributo foi feito para ser somente lido por quem estÃ¡ fora da classe, mas sua valoraÃ§Ã£o deve ser feita seguindo alguma lÃ³gica interna.
Para esses casos, a convenÃ§Ã£o Ã© utilizar somente um underline, sem proibir ninguÃ©m de acessar caso queira.

Utilizar dois underlines quase nunca Ã© necessÃ¡rio e nÃ£o costuma acontecer, a nÃ£o ser que vocÃª precise esconder algo atÃ© mesmo das subclasses.

ObservaÃ§Ã£o importante: apesar da filosofia da linguagem ser a de deixar mÃ©todos e atributos pÃºblicos por padrÃ£o, isso nÃ£o significa que vocÃª nÃ£o deve se preocupar em tornÃ¡-los privados. O ponto Ã© simples: vocÃª comeÃ§a criando as coisas de maneira pÃºblica para facilitar o desenvolvimento, e assim que observar que algo nÃ£o deve ser acessado por fora da classe, vocÃª coloca um underline na frente. NÃ£o Ã© pra simplesmente ignorar esse passo e nunca criar atributos protegidos ou privados.


* AbstraÃ§Ã£o:

A abstraÃ§Ã£o de dados Ã© outro pilar da orientaÃ§Ã£o a objetos, e oculta os detalhes da implementaÃ§Ã£o mostrando apenas a funcionalidade para quem acessa os mÃ©todos, a fim de reduzir a complexidade do cÃ³digo.

Perceba que, ao chamarmos o mÃ©todo ligar, nÃ£o existe a necessidade de conhecer o cÃ¡lculo interno. Aqui estamos aplicando a abstraÃ§Ã£o, pois apenas o cÃ³digo da classe Liquidificador precisa se preocupar com a regra de negÃ³cio. Quando utilizarmos a classe em outra parte da aplicaÃ§Ã£o, precisaremos apenas saber quais sÃ£o os parÃ¢metros necessÃ¡rios de cada mÃ©todo.

EX:

liquidificador_vermelho = Liquidificador("Vermelho", 250, 220, 100)
liquidificador_vermelho.ligar(1)
print("EstÃ¡ ligado?", liquidificador_vermelho.esta_ligado())
# EstÃ¡ ligado? True
liquidificador_vermelho.desligar()
print("EstÃ¡ ligado?", liquidificador_vermelho.esta_ligado())
# EstÃ¡ ligado? False

