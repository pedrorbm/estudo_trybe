# INTRODU√á√ÉO A PYTHON.

* atualmente a vers√£o atual do python √© python 3.

* para acessar o terminal usando o linux que j√° vem integrado ao sistema, assim como mac. Basta digitar o seguinte comando:

EX:

python3  = comando digitado no terminal.

* operadores b√°sicos:

EX:

2 + 2  = soma.
2 - 2  = subtra√ß√£o.
2 * 2  = multiplica√ß√£o.
2 / 2  = divis√£o retornando o resto, ou seja retornando a divis√£o completa com v√≠rgula.
2 // 2  = divis√£o retornando apenas o inteiro, ou seja apenas os n√∫meros antes da v√≠rgula.
2 > 3  = compra√ß√£o de maior, retorn aum boolean.
2 < 3  = compara√ß√£o de menor, retorna um boolean.
2 >= 3  = compra√ß√£o de maior ou igual, retorn aum boolean.
2 <= 3  = compara√ß√£o de menor ou igual, retorna um boolean.
2 < 4 < 6  = para saber se o n√∫mero do meio est√° entre o intervalo estabelecido.
count = 2  = definindo uma vari√°vel, n√£o precisa usar var, let ou const.
count += 2  = incrementa mais 2 ao valor de count.
count -= 2  = diminui 2 ao valor de count.
count = count + 2  = incrementa 2, mas √© uma forma menos simplificada.
1 < count < 5  = saber se o valor de count est√° entre 1 e 5.
or  = tem o valor de ou, mesma coisa de "||" no javascript.
and  = valor de e, mesma coisa do "&&" no javascript.
True  = √© verdadeiro lembrando que come√ßa com a letra mai√∫scula.
False  = √© falso lembrando que come√ßa com a letra min√∫scula.

# tipos de dados:


* Booleanos (bool)
Os valores booleanos True e False pertencem ao tipo embutido bool.


* N√∫meros inteiros (int)
O primeiro dos tipos num√©ricos √© o int, ele representa um n√∫mero inteiro, ou seja, √© escrito sem parte fracion√°ria.


* Inicialize uma vari√°vel a = 5, digite o comando type(a) e observe o retorno.

O m√©todo type(operando) corresponde ao operador typeof operando do JavaScript.


* Assim como qualquer linguagem de programa√ß√£o, Python tamb√©m possui uma grande quantidade de comandos que precisamos aprender. Para nos ajudar nessa tarefa, podemos digitar help() dentro da linha de comandos do Python que ele nos dar√° detalhes do comando passado por par√¢metro.

EX:

help(list)
O comando help() tamb√©m pode ser utilizado em cl√°usulas if ou for, desde que colocado entre aspas e para sair de dentro do comando, basta apertar a tecla q.

help("if")
N√∫meros fracion√°rios (float)
O segundo tipo num√©rico √© o float, tamb√©m conhecido por ponto flutuante, ele representa um n√∫mero decimal ou fracion√°rio.

Inicialize uma vari√°vel a = 5.0, digite o comando type(a) e observe o retorno.


* Strings (str)
Al√©m dos tipos num√©ricos, temos o tipo de sequ√™ncia de texto str. Ele representa uma cadeia de caracteres ou, como popularmente conhecida, uma string. As strings s√£o definidas envolvendo um valor com aspas simples ou duplas. Exemplo: a = "Ol√°"


* Temos ainda estruturas do tipo:

sequ√™ncia(list, tuple, range);
conjuntos(set, frozenset);
mapeamento(dict);
sequ√™ncias bin√°rias(bytes, bytearray, memoryview).


* Listas (list)

Anota a√≠ ‚úèÔ∏è: uma lista √© uma sequ√™ncia mut√°vel e ordenada de elementos. Ela pode armazenar elementos heterog√™neos, ter seu tamanho vari√°vel e crescer √† medida que itens s√£o adicionados.

EX:

fruits = ["laranja", "ma√ß√£", "uva", "abacaxi"]  # elementos s√£o definidos separados por v√≠rgula, envolvidos por colchetes

fruits[0]  # o acesso √© feito por √≠ndices iniciados em 0

fruits[-1]  # o acesso tamb√©m pode ser negativo

fruits.append("banana")  # adicionando uma nova fruta

fruits.remove("abacaxi")  # removendo uma fruta

fruits.extend(["pera", "mel√£o", "kiwi"])  # acrescenta uma lista de frutas a lista original

fruits.index("ma√ß√£")  # retorna o √≠ndice onde a fruta est√° localizada, neste caso, 1

fruits.sort()  # ordena a lista de frutas
Vamos continuar com os exerc√≠cios! üí™


* Tuplas (tuple)

S√£o similares a listas, por√©m n√£o podem ser modificados durante a execu√ß√£o do programa.

EX:

user = ("Will", "Marcondes", 42)  # elementos s√£o definidos separados por v√≠rgula, envolvidos por par√™nteses

user[0]  # acesso tamb√©m por √≠ndices


* Conjuntos (set)

Um conjunto √© uma cole√ß√£o de elementos √∫nicos e n√£o ordenados. Conjuntos implementam opera√ß√µes de uni√£o, intersec√ß√£o e outras.

EX:

permissions = {"member", "group"}  # elementos separados por v√≠rgula, envolvidos por chaves

permissions.add("root")  # adiciona um novo elemento ao conjunto

permissions.add("member")  # como o elemento j√° existe, nenhum novo item √© adicionado ao conjunto

permissions.union({"user"})  # retorna um conjunto resultado da uni√£o

permissions.intersection({"user", "member"})  # retorna um conjunto resultante da intersec√ß√£o dos conjuntos

permissions.difference({"user"})  # retorna a diferen√ßa entre os dois conjuntos


* Conjuntos imut√°veis (frozenset)

√â uma varia√ß√£o do set, por√©m imut√°vel, ou seja, seus elementos n√£o podem ser modificados durante a execu√ß√£o do programa.

EX:

permissions = frozenset(["member", "group"])  # assim como o set, qualquer estrutura iter√°vel pode ser utilizada para criar um frozenset

permissions.union({"user"})  # novos conjuntos imut√°veis podem ser criados √† partir do original, mas o mesmo n√£o pode ser modificado

permissions.intersection({"user", "member"})  # retorna um conjunto resultante da intersec√ß√£o dos conjuntos

permissions.difference({"user"})  # retorna a diferen√ßa entre os dois conjuntos


* Dicion√°rios (dict)
Estrutura que associa uma chave a um determinado valor. √â a representa√ß√£o do t√£o famoso objeto que utilizamos em JavaScript.

EX:

people_by_id = {1: "Maria", 2: "Fernanda", 3: "Felipe"}  # elementos no formato "chave: valor" separados por v√≠rgula, envolvidos por chaves

people_by_name = {"Maria": 1, "Fernanda": 2, "Felipe": 3}  # outro exemplo, dessa vez usando strings como chaves. As aspas s√£o necess√°rias para que o Python n√£o ache que `Maria`, `Fernanda` e `Felipe` sejam vari√°veis.


people_by_id[1]  # sa√≠da: Maria
# elementos s√£o acessados por suas chaves

del people_by_id[1]  # elementos podem ser removidos com a palavra chave del

people_by_id.items()  # dict_items([(2, "Fernanda"), (3, "Felipe")])
# √© retornada uma cole√ß√£o iter√°vel de tuplas contendo chaves e valores


* Range (range)

Estrutura capaz de gerar uma sequ√™ncia num√©rica de um valor inicial at√© um valor final, modificando seu valor de acordo com o passo (step) definido. Pode ser declarado como range( [start], [stop], [step] ), em que start e step podem ser omitidos, possuindo valores iniciais iguais a 0 e 1 respectivamente.

Anota a√≠ ‚úèÔ∏è: O stop n√£o √© inclu√≠do na sequ√™ncia, portanto, caso queira uma sequ√™ncia de 1 at√© 10 a chamada dever√° ser range(1, 11)

Seus valores s√£o criados √† medida que esta sequ√™ncia √© percorrida.

EX:

# vamos converter o range em uma lista para ajudar na visualiza√ß√£o

# definimos somente o valor de parada
list(range(5))  # sa√≠da: [0, 1, 2, 3, 4]

# definimos o valor inicial e o de parada
list(range(1, 6))  # sa√≠da: [1, 2, 3, 4, 5]

# definimos valor inicial, de parada e modificamos o passo para 2
list(range(1, 11, 2))  # sa√≠da: [1, 3, 5, 7, 9]

# podemos utilizar valores negativos para as entradas tamb√©m
list(range(10, 0, -1))  # sa√≠da: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]


* Al√©m dos tipos b√°sicos, temos outros como datas, tuplas nomeadas, arrays, enumera√ß√µes e outros, mas estes t√™m de ser importados de seus respectivos m√≥dulos.


* Estruturas condicionais

Vamos imaginar a seguinte situa√ß√£o: em uma an√°lise de dados sobre pessoas desenvolvedoras, temos uma base de dados que cont√©m o sal√°rio delas, mas n√£o mostra a informa√ß√£o sobre sua senioridade.

Para fazer um agrupamento por essa classifica√ß√£o de n√≠vel de experi√™ncia, precisamos criar uma nova coluna que ser√° baseada no sal√°rio:

Menor que R$2.000,00, pessoa desenvolvedora estagi√°ria;

Entre R$2.000,00 e R$5.800,00, pessoa desenvolvedora j√∫nior;

Entre R$5.800,00 e R$7.500,00, pessoa desenvolvedora pleno;

Entre R$7.500,00 e R$10.500,00, pessoa desenvolvedora s√™nior;

Qualquer valor acima do que j√° foi mencionado a pessoa desenvolvedora √© considerada lideran√ßa.

EX:

position = ""
if salary <= 2000:
    position = "estagi√°rio"
elif 2000 < salary <= 5800:
    position = "j√∫nior"
elif 5800 < salary <= 7500:
    position = "pleno"
elif 7500 < salary <= 10500:
    position = "senior"
else:
    position = "l√≠der"
    
A indenta√ß√£o do c√≥digo deve ser feita com 4 espa√ßos em vez de tabs.

Voc√™ pode estar se perguntando: ‚ÄúN√£o est√° faltando alguma coisa nessa estrutura?‚Äùü§î

Resposta: Note que if e elif s√£o seguidos de uma express√£o que se avaliada como verdadeira, o trecho de c√≥digo ser√° executado. Um outro detalhe √© a aus√™ncia de chaves para definir o bloco. Utilizamos o caractere : para indicar abertura de um bloco e somente indenta√ß√£o para indicar o t√©rmino.

O bloco else ser√° executado se nenhuma das condi√ß√µes anteriores for satisfeita.

Agora que escrevemos mais linhas, notamos tamb√©m a aus√™ncia do caractere ;. Pois bem, a filosofia da linguagem Python nos diz: ‚ÄúLegibilidade conta‚Ä¶‚Äù, ent√£o, com isso, n√£o precisamos mais desse caractere.

Com a senioridade em m√£os, podemos criar uma nova coluna em nossa base dados com essa informa√ß√£o e realizar o agrupamento por cargo, desenhando lindos gr√°ficos.

Voc√™ pode estar se perguntando: ‚ÄúPosso modificar para uma estrutura switch?‚Äù Resposta: A estrutura condicional if e seu aninhamento com elif e else √© t√£o simples e leg√≠vel que n√£o precisamos da estrutura switch.

‚ÄùSimples √© melhor do que complexo‚Äù - Zen do python

* Em alguns casos, em que n√£o seja prejudicada a legibilidade, podemos criar estruturas de mapeamento (dicts) para simplificar o aninhamento de condicionais. Como o exemplo a seguir:

EX:

key = "id"
from_to = {
    "id": "identifier",
    "mail": "email",
    "lastName": "last_name",
}
from_to[key]


* Estruturas de repeti√ß√£o

*for

Imagine um sistema que fa√ßa a listagem de restaurantes. Estes restaurantes possuem uma nota proveniente da avalia√ß√£o dos seus clientes.

EX:

restaurants = [
    {"name": "Restaurante A", "nota": 4.5},
    {"name": "Restaurante B", "nota": 3.0},
    {"name": "Restaurante C", "nota": 4.2},
    {"name": "Restaurante D", "nota": 2.3},
]

Quando um cliente pede a listagem de restaurantes, ele pode escolher filtrar o resultado de acordo com a nota. Essa filtragem pode ocorrer percorrendo a lista de restaurantes ou criando uma nova lista com somente aqueles que atendem ao filtro, assim como mostra o exemplo abaixo:

EX:

filtered_restaurants = []
min_rating = 3.0
for restaurant in restaurants:
    if restaurant["nota"] > min_rating:
        filtered_restaurants.append(restaurant)
print(filtered_restaurants)  # imprime a lista de restaurantes, sem o B e D

Dado que a maior parte do tempo estamos percorrendo estruturas, os criadores do Python decidiram que o for each seria o la√ßo de repeti√ß√£o principal na linguagem.

Para cada repeti√ß√£o do nosso la√ßo, um novo elemento da estrutura iter√°vel √© atribu√≠do a vari√°vel de itera√ß√£o. No exemplo acima, vemos que a cada itera√ß√£o um novo restaurante √© colocado na vari√°vel restaurant.

* Em alguns casos, podemos ainda querer percorrer uma sequ√™ncia num√©rica, e para isto iteramos sobre a estrutura de dados range.

EX:

for index in range(5):
    print(index)
    
Al√©m de listas, v√°rias outras estruturas s√£o iter√°veis, como strings (str), tuplas (tuple), conjuntos (set), dicion√°rios (dict) e at√© mesmo arquivos.


* Compreens√£o de lista (list comprehension)

A compreens√£o de listas em Python possui uma sintaxe f√°cil e compacta para cria√ß√£o de listas, seja a partir de uma string ou de outra lista. √â uma maneira concisa de cria√ß√£o que executa uma opera√ß√£o em cada item da lista j√° existente.

Quando uma nova lista √© criada como resultado de uma itera√ß√£o, podemos simplificar utilizando compreens√£o de listas.

EX:

min_rating = 3.0
filtered_restaurants = [
    restaurant
    for restaurant in restaurants
    if restaurant["nota"] > min_rating
]
print(filtered_restaurants)  # imprime a lista de restaurantes, sem o B e D

A compreens√£o de listas √© declarada da mesma maneira que uma lista comum, por√©m no lugar dos elementos n√≥s colocamos a itera√ß√£o que vai gerar os elementos da nova lista.

√â poss√≠vel filtrar esses elementos utilizando o if.

Poder√≠amos listar tamb√©m somente o nome dos restaurantes, veja o exemplo abaixo:

EX:

# min_rating = 3.0
filtered_restaurants = [restaurant["name"]]  # aqui pedimos somente o nome do restaurante
#                        for restaurant in restaurants
#                        if restaurant["nota"] > min_rating]
# print(filtered_restaurants)  # imprime a lista de restaurantes, sem o B e D

Convers√£o de loop for em compreens√£o de listas
Convers√£o de loop for em compreens√£o de listas

* A compreens√£o de listas tamb√©m funciona com listas de strings. A seguinte cria uma nova lista de strings com os nomes que cont√©m a letra ‚Äòa‚Äô.

EX:

names_list = ['Duda', 'Rafa', 'Cris', 'Yuri']
new_names_list = [name for name in names_list if 'a' in name]

# Aqui o for percorre cada nome em "names_list", verifica se existe a letra "a" nele,
# o adiciona √† vari√°vel "name", e ent√£o gera nossa nova lista "new_names_list"
print(new_names_list)

# Sa√≠da
['Duda', 'Rafa']

* O exemplo a seguir usa uma compreens√£o de listas para criar uma lista com o quadrado dos n√∫meros entre 1 e 10.

EX:

quadrados = [x*x for x in range(11)]
print(quadrados)

# Sa√≠da
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

Isto √© equivalente √†s opera√ß√µes de map e filter em JavaScript.


* while

Com o while n√≥s podemos executar um conjunto de declara√ß√µes enquanto a condi√ß√£o for verdadeira.

No c√≥digo abaixo mostramos uma implementa√ß√£o da Sequ√™ncia de Fibonacci, presente em diversas formas na natureza. Ela √© uma sequ√™ncia num√©rica come√ßando por 0 e 1, e cada termo subsequente corresponde √† soma dos dois anteriores.

Podemos escrever esta sequ√™ncia da seguinte maneira:

EX:

n = 10
last, next = 0, 1
while last < n:
    print(last)
    last, next = next, last + next
    
O la√ßo de repeti√ß√£o while acontecer√° enquanto a condi√ß√£o for satisfeita.

Tenha cuidado ao manipular a vari√°vel presente na condicional ou entrar√° em uma repeti√ß√£o infinita.

No exemplo anterior, estamos imprimindo os elementos da sequ√™ncia at√© que atinja o valor 10. Neste caso, foi utilizado um truque chamado atribui√ß√£o m√∫ltipla. Isto √©, atribui√ß√£o de v√°rios valores a m√∫ltiplas vari√°veis ao mesmo tempo.

De olho na dicaüëÄ: Este truque pode ser utilizado tamb√©m para fazer a troca de valores entre vari√°veis: a, b = b, a.


* enumerate

Em Python, um loop for geralmente √© escrito como um loop sobre um objeto iter√°vel. Isso significa que voc√™ n√£o precisa de uma vari√°vel de contagem para acessar itens no iter√°vel.

Por√©m, √†s vezes, pode acontecer de voc√™ querer uma vari√°vel que muda em cada itera√ß√£o do loop. Em vez de criar e incrementar uma vari√°vel voc√™ mesmo, voc√™ pode usar enumerate() do Python para obter um contador e o valor do iter√°vel ao mesmo tempo!

EX:

languages = ['Python', 'Java', 'JavaScript']

enumerate_prime = enumerate(languages)

# converte um objeto enumerate em uma lista
print(list(enumerate_prime))

# Sa√≠da: [(0, 'Python'), (1, 'Java'), (2, 'JavaScript')]

* Voc√™ tamb√©m pode desestruturar (unpack) os itens da lista ou tupla:

EX:

languages = ['Python', 'Java', 'JavaScript']

for index, language in enumerate(['Python', 'Java']):
    print(f'{index} - {language}')
# Sa√≠da:
0 - Python
1 - Java

De olho na dica: na linha 4 voc√™ deve ter reparado algo diferente neste c√≥digo print(f'{index} - {language}'). A letra f usada dentro do print √© chamada de f-string. Ela fornece uma maneira de incorporar express√µes dentro de strings literais, usando uma sintaxe m√≠nima. Lembre-se de ler a documenta√ß√£o em caso de d√∫vidas.

* fun√ß√µes:

Os par√¢metros podem ser passados de forma:

posicional: s√£o aqueles definidos por meio da posi√ß√£o em que cada um √© passado;
nomeada: s√£o definidos por meio de seus nomes.

EX:

def soma(x, y):
    return x + y

soma(2, 2)  # os par√¢metros aqui s√£o posicionais

soma(x=2, y=2)  # aqui estamos nomeando os par√¢metros
Os par√¢metros tamb√©m podem ser vari√°dicos, ou seja, variam em sua quantidade.

* Par√¢metros posicionais vari√°dicos s√£o acessados como uma tupla no interior de uma fun√ß√£o, e par√¢metros nomeados vari√°dicos como um dicion√°rio.

EX:

def concat(*strings):
    # Equivalente a um ", ".join(strings), que concatena os elementos de um iter√°vel em uma string utilizando um separador
    # Nesse caso a string resultante estaria separada por v√≠rgula
    final_string = ""
    for string in strings:
        final_string += string
        if not string == strings[-1]:
            final_string += ', '
    return final_string

# pode ser chamado com 2 par√¢metros
concat("Carlos", "Cristina")  # sa√≠da: "Carlos, Cristina"

# pode ser chamado com um n√∫mero n de par√¢metros
concat("Carlos", "Cristina", "Maria")  # sa√≠da: "Carlos, Cristina, Maria"

# dict √© uma fun√ß√£o que j√° vem embutida no python
dict(nome="Felipe", sobrenome="Silva", idade=25)  # cria um dicion√°rio utilizando as chaves passadas

dict(nome="Ana", sobrenome="Souza", idade=21, turma=1)  # o n√∫mero de par√¢metros passados para a fun√ß√£o pode variar
As vari√°veis definidas dentro das fun√ß√µes tem escopo local. Por√©m, quando uma fun√ß√£o n√£o encontra um nome no escopo local, ela ir√° procurar no espa√ßo de nomes global.

* Em alguns casos, podemos querer limitar um par√¢metro em nomeado ou posicional para evitar ambiguidades e/ou aumentar legibilidade.

EX:

len([1, 2, 3, 4])  # fun√ß√£o len n√£o aceita argumentos nomeados

len(obj=[1, 2, 3, 4])  # este c√≥digo ir√° falhar

print("Coin", "Rodrigo", ", ")  # imprime Coin Rodrigo ,

print("Coin", "Rodrigo", sep=", ")  # nomeando o terceiro par√¢metro, agora temos a sa√≠da: Coin, Rodrigo

* primeiro arquivo:

M√≥dulos s√£o declarados utilizando snake case, ou seja, com nomes min√∫sculos e quando possu√≠rem mais de uma palavra, devem ser separadas por underscore (_).

* Vamos agora criar o arquivo area.py, declarando fun√ß√µes que calculam a √°rea de algumas figuras geom√©tricas.

area.py

EX:

 PI = 3.14  # PI √© uma "constante" em nosso m√≥dulo


 def square(side):
     '''Calculate area of square.'''
     return side * side


 def rectangle(length, width):
     '''Calculate area of rectangle.'''
     return length * width


 def circle(radius):
     '''Calculate area of circle.'''
     return PI * radius * radius
     
Observe que esse c√≥digo segue algumas boas pr√°ticas para legibilidade, tais como:

Entre cada fun√ß√£o temos um espa√ßo de 2 linhas;

As fun√ß√µes s√£o declaradas com nomes em letras min√∫sculas;

A constante PI √© definida em letras mai√∫sculas.

‚ö†Ô∏èAviso: Existe uma conven√ß√£o de declarar valores considerados constantes com letras mai√∫sculas, e o respeito por outros programadores de n√£o alterarem aquele valor.

* Abra um terminal e para executar o m√≥dulo em python, escreva python3 area.py. Se n√£o houve nenhum erro de digita√ß√£o, nada deve ter acontecido. Neste m√≥dulo s√≥ temos defini√ß√µes das fun√ß√µes e valores, mas n√£o estamos executando nenhuma delas. Isto √© o que chamamos de execu√ß√£o do m√≥dulo como script.

Hora de test√°-lo! No fim do arquivo, vamos adicionar algumas linhas para imprimir a √°rea de algumas figuras geom√©tricas.

EX:

 print("√Årea do quadrado:", square(10))
 print("√Årea do ret√¢ngulo:", rectangle(2, 2))
 print("√Årea do c√≠rculo:", circle(3))
 

Nosso m√≥dulo quando executado exibe alguns valores de teste.

* Vamos utilizar o nosso m√≥dulo de calcular √°rea de figuras planas. Escreva um novo arquivo com nome people.py e ele ser√° um script para calcular pessoas que est√£o presentes em um show, dado a √°rea do mesmo.

Este script ser√° escrito da seguinte maneira:

people.py

EX:

import area


PEOPLE_PER_SQUARE_METER = 2  # numero de pessoas por metro quadrado em m√©dia
FIELD_LENGTH = 60  # em metros
FIELD_WIDTH = 45  # em metros
people_at_concert = (
    area.rectangle(FIELD_LENGTH, FIELD_WIDTH) * PEOPLE_PER_SQUARE_METER
)

print("Est√£o presentes no show aproximadamente", people_at_concert, "pessoas.")

Anota a√≠ ‚úèÔ∏è: O import √© utilizado para termos todas as fun√ß√µes do m√≥dulo dispon√≠veis em outro arquivo. Uma outra maneira de utilizarmos √© escrevendo from area import rectangle, por exemplo, se quisermos importar apenas rectangle a partir de area. Por√©m, tome cuidado com conflitos de nomes caso use essa segunda maneira.

Ao execut√°-lo com o comando python3 people.py, vemos que a sa√≠da n√£o foi bem como esper√°vamos.

Execu√ß√£o exibe os testes feitos no m√≥dulo de √°rea.
Os nossos valores de teste est√£o sendo exibidos quando importamos o m√≥dulo. Mas n√£o queremos que isso aconte√ßa.

* Para corrigir, podemos acrescentar uma condicional ao m√≥dulo para somente exibir esses valores de teste quando o m√≥dulo for executado como script.

A vari√°vel __name__ √© utilizada pelo interpretador Python para identificar o arquivo que esta sendo executado e seu valor ser√° "__main__" quando invocamos um m√≥dulo como script.

area.py

EX:

# ...

if __name__ == "__main__":
    print("√Årea do quadrado:", square(10))
    print("√Årea do ret√¢ngulo:", rectangle(2, 2))
    print("√Årea do c√≠rculo:", circle(3))
    
Ao executarmos novamente nosso script, agora tudo est√° ok! üéâ


