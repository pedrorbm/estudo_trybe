# INTRODU√á√ÉO A PYTHON.

* atualmente a vers√£o atual do python √© python 3.

* para acessar o terminal usando o linux que j√° vem integrado ao sistema, assim como mac. Basta digitar o seguinte comando:

EX:

python3  = comando digitado no terminal.

* operadores b√°sicos:

EX:

2 + 2  = soma.
2 - 2  = subtra√ß√£o.
2 * 2  = multiplica√ß√£o.
2 / 2  = divis√£o retornando o resto, ou seja retornando a divis√£o completa com v√≠rgula.
2 // 2  = divis√£o retornando apenas o inteiro, ou seja apenas os n√∫meros antes da v√≠rgula.
2 > 3  = compra√ß√£o de maior, retorn aum boolean.
2 < 3  = compara√ß√£o de menor, retorna um boolean.
2 >= 3  = compra√ß√£o de maior ou igual, retorn aum boolean.
2 <= 3  = compara√ß√£o de menor ou igual, retorna um boolean.
2 < 4 < 6  = para saber se o n√∫mero do meio est√° entre o intervalo estabelecido.
count = 2  = definindo uma vari√°vel, n√£o precisa usar var, let ou const.
count += 2  = incrementa mais 2 ao valor de count.
count -= 2  = diminui 2 ao valor de count.
count = count + 2  = incrementa 2, mas √© uma forma menos simplificada.
1 < count < 5  = saber se o valor de count est√° entre 1 e 5.
or  = tem o valor de ou, mesma coisa de "||" no javascript.
and  = valor de e, mesma coisa do "&&" no javascript.
True  = √© verdadeiro lembrando que come√ßa com a letra mai√∫scula.
False  = √© falso lembrando que come√ßa com a letra min√∫scula.

# tipos de dados:


* Booleanos (bool)
Os valores booleanos True e False pertencem ao tipo embutido bool.


* N√∫meros inteiros (int)
O primeiro dos tipos num√©ricos √© o int, ele representa um n√∫mero inteiro, ou seja, √© escrito sem parte fracion√°ria.


* Inicialize uma vari√°vel a = 5, digite o comando type(a) e observe o retorno.

O m√©todo type(operando) corresponde ao operador typeof operando do JavaScript.


* Assim como qualquer linguagem de programa√ß√£o, Python tamb√©m possui uma grande quantidade de comandos que precisamos aprender. Para nos ajudar nessa tarefa, podemos digitar help() dentro da linha de comandos do Python que ele nos dar√° detalhes do comando passado por par√¢metro.

EX:

help(list)
O comando help() tamb√©m pode ser utilizado em cl√°usulas if ou for, desde que colocado entre aspas e para sair de dentro do comando, basta apertar a tecla q.

help("if")
N√∫meros fracion√°rios (float)
O segundo tipo num√©rico √© o float, tamb√©m conhecido por ponto flutuante, ele representa um n√∫mero decimal ou fracion√°rio.

Inicialize uma vari√°vel a = 5.0, digite o comando type(a) e observe o retorno.


* Strings (str)
Al√©m dos tipos num√©ricos, temos o tipo de sequ√™ncia de texto str. Ele representa uma cadeia de caracteres ou, como popularmente conhecida, uma string. As strings s√£o definidas envolvendo um valor com aspas simples ou duplas. Exemplo: a = "Ol√°"


* Temos ainda estruturas do tipo:

sequ√™ncia(list, tuple, range);
conjuntos(set, frozenset);
mapeamento(dict);
sequ√™ncias bin√°rias(bytes, bytearray, memoryview).


* Listas (list)

Anota a√≠ ‚úèÔ∏è: uma lista √© uma sequ√™ncia mut√°vel e ordenada de elementos. Ela pode armazenar elementos heterog√™neos, ter seu tamanho vari√°vel e crescer √† medida que itens s√£o adicionados.

EX:

fruits = ["laranja", "ma√ß√£", "uva", "abacaxi"]  # elementos s√£o definidos separados por v√≠rgula, envolvidos por colchetes

fruits[0]  # o acesso √© feito por √≠ndices iniciados em 0

fruits[-1]  # o acesso tamb√©m pode ser negativo

fruits.append("banana")  # adicionando uma nova fruta

fruits.remove("abacaxi")  # removendo uma fruta

fruits.extend(["pera", "mel√£o", "kiwi"])  # acrescenta uma lista de frutas a lista original

fruits.index("ma√ß√£")  # retorna o √≠ndice onde a fruta est√° localizada, neste caso, 1

fruits.sort()  # ordena a lista de frutas
Vamos continuar com os exerc√≠cios! üí™


* Tuplas (tuple)

S√£o similares a listas, por√©m n√£o podem ser modificados durante a execu√ß√£o do programa.

EX:

user = ("Will", "Marcondes", 42)  # elementos s√£o definidos separados por v√≠rgula, envolvidos por par√™nteses

user[0]  # acesso tamb√©m por √≠ndices


* Conjuntos (set)

Um conjunto √© uma cole√ß√£o de elementos √∫nicos e n√£o ordenados. Conjuntos implementam opera√ß√µes de uni√£o, intersec√ß√£o e outras.

EX:

permissions = {"member", "group"}  # elementos separados por v√≠rgula, envolvidos por chaves

permissions.add("root")  # adiciona um novo elemento ao conjunto

permissions.add("member")  # como o elemento j√° existe, nenhum novo item √© adicionado ao conjunto

permissions.union({"user"})  # retorna um conjunto resultado da uni√£o

permissions.intersection({"user", "member"})  # retorna um conjunto resultante da intersec√ß√£o dos conjuntos

permissions.difference({"user"})  # retorna a diferen√ßa entre os dois conjuntos


* Conjuntos imut√°veis (frozenset)

√â uma varia√ß√£o do set, por√©m imut√°vel, ou seja, seus elementos n√£o podem ser modificados durante a execu√ß√£o do programa.

EX:

permissions = frozenset(["member", "group"])  # assim como o set, qualquer estrutura iter√°vel pode ser utilizada para criar um frozenset

permissions.union({"user"})  # novos conjuntos imut√°veis podem ser criados √† partir do original, mas o mesmo n√£o pode ser modificado

permissions.intersection({"user", "member"})  # retorna um conjunto resultante da intersec√ß√£o dos conjuntos

permissions.difference({"user"})  # retorna a diferen√ßa entre os dois conjuntos


* Dicion√°rios (dict)
Estrutura que associa uma chave a um determinado valor. √â a representa√ß√£o do t√£o famoso objeto que utilizamos em JavaScript.

EX:

people_by_id = {1: "Maria", 2: "Fernanda", 3: "Felipe"}  # elementos no formato "chave: valor" separados por v√≠rgula, envolvidos por chaves

people_by_name = {"Maria": 1, "Fernanda": 2, "Felipe": 3}  # outro exemplo, dessa vez usando strings como chaves. As aspas s√£o necess√°rias para que o Python n√£o ache que `Maria`, `Fernanda` e `Felipe` sejam vari√°veis.


people_by_id[1]  # sa√≠da: Maria
# elementos s√£o acessados por suas chaves

del people_by_id[1]  # elementos podem ser removidos com a palavra chave del

people_by_id.items()  # dict_items([(2, "Fernanda"), (3, "Felipe")])
# √© retornada uma cole√ß√£o iter√°vel de tuplas contendo chaves e valores


* Range (range)

Estrutura capaz de gerar uma sequ√™ncia num√©rica de um valor inicial at√© um valor final, modificando seu valor de acordo com o passo (step) definido. Pode ser declarado como range( [start], [stop], [step] ), em que start e step podem ser omitidos, possuindo valores iniciais iguais a 0 e 1 respectivamente.

Anota a√≠ ‚úèÔ∏è: O stop n√£o √© inclu√≠do na sequ√™ncia, portanto, caso queira uma sequ√™ncia de 1 at√© 10 a chamada dever√° ser range(1, 11)

Seus valores s√£o criados √† medida que esta sequ√™ncia √© percorrida.

EX:

# vamos converter o range em uma lista para ajudar na visualiza√ß√£o

# definimos somente o valor de parada
list(range(5))  # sa√≠da: [0, 1, 2, 3, 4]

# definimos o valor inicial e o de parada
list(range(1, 6))  # sa√≠da: [1, 2, 3, 4, 5]

# definimos valor inicial, de parada e modificamos o passo para 2
list(range(1, 11, 2))  # sa√≠da: [1, 3, 5, 7, 9]

# podemos utilizar valores negativos para as entradas tamb√©m
list(range(10, 0, -1))  # sa√≠da: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]


* Al√©m dos tipos b√°sicos, temos outros como datas, tuplas nomeadas, arrays, enumera√ß√µes e outros, mas estes t√™m de ser importados de seus respectivos m√≥dulos.


* Estruturas condicionais

Vamos imaginar a seguinte situa√ß√£o: em uma an√°lise de dados sobre pessoas desenvolvedoras, temos uma base de dados que cont√©m o sal√°rio delas, mas n√£o mostra a informa√ß√£o sobre sua senioridade.

Para fazer um agrupamento por essa classifica√ß√£o de n√≠vel de experi√™ncia, precisamos criar uma nova coluna que ser√° baseada no sal√°rio:

Menor que R$2.000,00, pessoa desenvolvedora estagi√°ria;

Entre R$2.000,00 e R$5.800,00, pessoa desenvolvedora j√∫nior;

Entre R$5.800,00 e R$7.500,00, pessoa desenvolvedora pleno;

Entre R$7.500,00 e R$10.500,00, pessoa desenvolvedora s√™nior;

Qualquer valor acima do que j√° foi mencionado a pessoa desenvolvedora √© considerada lideran√ßa.

EX:

position = ""
if salary <= 2000:
    position = "estagi√°rio"
elif 2000 < salary <= 5800:
    position = "j√∫nior"
elif 5800 < salary <= 7500:
    position = "pleno"
elif 7500 < salary <= 10500:
    position = "senior"
else:
    position = "l√≠der"
    
A indenta√ß√£o do c√≥digo deve ser feita com 4 espa√ßos em vez de tabs.

Voc√™ pode estar se perguntando: ‚ÄúN√£o est√° faltando alguma coisa nessa estrutura?‚Äùü§î

Resposta: Note que if e elif s√£o seguidos de uma express√£o que se avaliada como verdadeira, o trecho de c√≥digo ser√° executado. Um outro detalhe √© a aus√™ncia de chaves para definir o bloco. Utilizamos o caractere : para indicar abertura de um bloco e somente indenta√ß√£o para indicar o t√©rmino.

O bloco else ser√° executado se nenhuma das condi√ß√µes anteriores for satisfeita.

Agora que escrevemos mais linhas, notamos tamb√©m a aus√™ncia do caractere ;. Pois bem, a filosofia da linguagem Python nos diz: ‚ÄúLegibilidade conta‚Ä¶‚Äù, ent√£o, com isso, n√£o precisamos mais desse caractere.

Com a senioridade em m√£os, podemos criar uma nova coluna em nossa base dados com essa informa√ß√£o e realizar o agrupamento por cargo, desenhando lindos gr√°ficos.

Voc√™ pode estar se perguntando: ‚ÄúPosso modificar para uma estrutura switch?‚Äù Resposta: A estrutura condicional if e seu aninhamento com elif e else √© t√£o simples e leg√≠vel que n√£o precisamos da estrutura switch.

‚ÄùSimples √© melhor do que complexo‚Äù - Zen do python

* Em alguns casos, em que n√£o seja prejudicada a legibilidade, podemos criar estruturas de mapeamento (dicts) para simplificar o aninhamento de condicionais. Como o exemplo a seguir:

EX:

key = "id"
from_to = {
    "id": "identifier",
    "mail": "email",
    "lastName": "last_name",
}
from_to[key]


* Estruturas de repeti√ß√£o

*for

Imagine um sistema que fa√ßa a listagem de restaurantes. Estes restaurantes possuem uma nota proveniente da avalia√ß√£o dos seus clientes.

EX:

restaurants = [
    {"name": "Restaurante A", "nota": 4.5},
    {"name": "Restaurante B", "nota": 3.0},
    {"name": "Restaurante C", "nota": 4.2},
    {"name": "Restaurante D", "nota": 2.3},
]

Quando um cliente pede a listagem de restaurantes, ele pode escolher filtrar o resultado de acordo com a nota. Essa filtragem pode ocorrer percorrendo a lista de restaurantes ou criando uma nova lista com somente aqueles que atendem ao filtro, assim como mostra o exemplo abaixo:

EX:

filtered_restaurants = []
min_rating = 3.0
for restaurant in restaurants:
    if restaurant["nota"] > min_rating:
        filtered_restaurants.append(restaurant)
print(filtered_restaurants)  # imprime a lista de restaurantes, sem o B e D

Dado que a maior parte do tempo estamos percorrendo estruturas, os criadores do Python decidiram que o for each seria o la√ßo de repeti√ß√£o principal na linguagem.

Para cada repeti√ß√£o do nosso la√ßo, um novo elemento da estrutura iter√°vel √© atribu√≠do a vari√°vel de itera√ß√£o. No exemplo acima, vemos que a cada itera√ß√£o um novo restaurante √© colocado na vari√°vel restaurant.

* Em alguns casos, podemos ainda querer percorrer uma sequ√™ncia num√©rica, e para isto iteramos sobre a estrutura de dados range.

EX:

for index in range(5):
    print(index)
    
Al√©m de listas, v√°rias outras estruturas s√£o iter√°veis, como strings (str), tuplas (tuple), conjuntos (set), dicion√°rios (dict) e at√© mesmo arquivos.


* Compreens√£o de lista (list comprehension)

A compreens√£o de listas em Python possui uma sintaxe f√°cil e compacta para cria√ß√£o de listas, seja a partir de uma string ou de outra lista. √â uma maneira concisa de cria√ß√£o que executa uma opera√ß√£o em cada item da lista j√° existente.

Quando uma nova lista √© criada como resultado de uma itera√ß√£o, podemos simplificar utilizando compreens√£o de listas.

EX:

min_rating = 3.0
filtered_restaurants = [
    restaurant
    for restaurant in restaurants
    if restaurant["nota"] > min_rating
]
print(filtered_restaurants)  # imprime a lista de restaurantes, sem o B e D

A compreens√£o de listas √© declarada da mesma maneira que uma lista comum, por√©m no lugar dos elementos n√≥s colocamos a itera√ß√£o que vai gerar os elementos da nova lista.

√â poss√≠vel filtrar esses elementos utilizando o if.

Poder√≠amos listar tamb√©m somente o nome dos restaurantes, veja o exemplo abaixo:

EX:

# min_rating = 3.0
filtered_restaurants = [restaurant["name"]]  # aqui pedimos somente o nome do restaurante
#                        for restaurant in restaurants
#                        if restaurant["nota"] > min_rating]
# print(filtered_restaurants)  # imprime a lista de restaurantes, sem o B e D

Convers√£o de loop for em compreens√£o de listas
Convers√£o de loop for em compreens√£o de listas

* A compreens√£o de listas tamb√©m funciona com listas de strings. A seguinte cria uma nova lista de strings com os nomes que cont√©m a letra ‚Äòa‚Äô.

EX:

names_list = ['Duda', 'Rafa', 'Cris', 'Yuri']
new_names_list = [name for name in names_list if 'a' in name]

# Aqui o for percorre cada nome em "names_list", verifica se existe a letra "a" nele,
# o adiciona √† vari√°vel "name", e ent√£o gera nossa nova lista "new_names_list"
print(new_names_list)

# Sa√≠da
['Duda', 'Rafa']

* O exemplo a seguir usa uma compreens√£o de listas para criar uma lista com o quadrado dos n√∫meros entre 1 e 10.

EX:

quadrados = [x*x for x in range(11)]
print(quadrados)

# Sa√≠da
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

Isto √© equivalente √†s opera√ß√µes de map e filter em JavaScript.


* while

Com o while n√≥s podemos executar um conjunto de declara√ß√µes enquanto a condi√ß√£o for verdadeira.

No c√≥digo abaixo mostramos uma implementa√ß√£o da Sequ√™ncia de Fibonacci, presente em diversas formas na natureza. Ela √© uma sequ√™ncia num√©rica come√ßando por 0 e 1, e cada termo subsequente corresponde √† soma dos dois anteriores.

Podemos escrever esta sequ√™ncia da seguinte maneira:

EX:

n = 10
last, next = 0, 1
while last < n:
    print(last)
    last, next = next, last + next
    
O la√ßo de repeti√ß√£o while acontecer√° enquanto a condi√ß√£o for satisfeita.

Tenha cuidado ao manipular a vari√°vel presente na condicional ou entrar√° em uma repeti√ß√£o infinita.

No exemplo anterior, estamos imprimindo os elementos da sequ√™ncia at√© que atinja o valor 10. Neste caso, foi utilizado um truque chamado atribui√ß√£o m√∫ltipla. Isto √©, atribui√ß√£o de v√°rios valores a m√∫ltiplas vari√°veis ao mesmo tempo.

De olho na dicaüëÄ: Este truque pode ser utilizado tamb√©m para fazer a troca de valores entre vari√°veis: a, b = b, a.


* enumerate

Em Python, um loop for geralmente √© escrito como um loop sobre um objeto iter√°vel. Isso significa que voc√™ n√£o precisa de uma vari√°vel de contagem para acessar itens no iter√°vel.

Por√©m, √†s vezes, pode acontecer de voc√™ querer uma vari√°vel que muda em cada itera√ß√£o do loop. Em vez de criar e incrementar uma vari√°vel voc√™ mesmo, voc√™ pode usar enumerate() do Python para obter um contador e o valor do iter√°vel ao mesmo tempo!

EX:

languages = ['Python', 'Java', 'JavaScript']

enumerate_prime = enumerate(languages)

# converte um objeto enumerate em uma lista
print(list(enumerate_prime))

# Sa√≠da: [(0, 'Python'), (1, 'Java'), (2, 'JavaScript')]

* Voc√™ tamb√©m pode desestruturar (unpack) os itens da lista ou tupla:

EX:

languages = ['Python', 'Java', 'JavaScript']

for index, language in enumerate(['Python', 'Java']):
    print(f'{index} - {language}')
# Sa√≠da:
0 - Python
1 - Java

De olho na dica: na linha 4 voc√™ deve ter reparado algo diferente neste c√≥digo print(f'{index} - {language}'). A letra f usada dentro do print √© chamada de f-string. Ela fornece uma maneira de incorporar express√µes dentro de strings literais, usando uma sintaxe m√≠nima. Lembre-se de ler a documenta√ß√£o em caso de d√∫vidas.

