* M√≥dulos:

Um m√≥dulo √© um arquivo que cont√©m defini√ß√µes e instru√ß√µes em Python. O nome do arquivo √© um nome acrescido de .py. Voc√™ pode importar um m√≥dulo dentro de um outro arquivo Python e ter acesso √†s suas fun√ß√µes, classes, etc.

Em linhas gerais, todo arquivo que √© escrito com a linguagem Python e com a extens√£o .py √© considerado um m√≥dulo.

Observe o arquivo my_math.py abaixo:

EX:

def sum(a, b):
  return a + b


def pot(a, b):
  return a ** b


print(sum(2, 2))
print(pot(2, 3))

Este arquivo √© um m√≥dulo Python, que pode ser executado como script com o comando python3 my_math.py. Se isso ocorrer, os retornos ser√£o 4 e 8, respectivamente, devido √†s chamadas das fun√ß√µes dentro dos m√©todos print().

Entretanto, as fun√ß√µes que criamos neste arquivo podem ser reaproveitadas por outros m√≥dulos atrav√©s da declara√ß√£o import.

√Ä medida que fomos avan√ßando, esses conceitos ficar√£o cada vez mais n√≠tidos.


* Pacotes:

Pacotes s√£o m√≥dulos Python que cont√™m outros m√≥dulos e/ou pacotes, comumente separados por responsabilidades similares. Na pr√°tica, um pacote √© um diret√≥rio que pode conter v√°rios m√≥dulos (arquivos de extens√£o .py) e/ou outros pacotes.

Exemplo de tipos diferentes de imports de pacotes:

EX:

import http  # importa o pacote http como um m√≥dulo

from http import client  # importa o m√≥dulo client do pacote http


from http.client import HTTP_PORT  # importa a constante HTTP_PORT do m√≥dulo client do pacote http


* Ambiente Virtual

Imagine que, em uma m√°quina, h√° um projeto Python que cont√©m alguns pacotes de terceiros instalados e, dentre eles, h√° uma biblioteca na vers√£o 1.4. Imagine tamb√©m que, na mesma m√°quina, √© iniciado um novo projeto que precisa da mesma biblioteca, mas dessa vez na vers√£o 2.0. O que fazer? As vers√µes s√£o compat√≠veis? Se eu atualizar o sistema, a vers√£o antiga vai continuar funcionando?

O venv entra como resposta para essas perguntas! Ele √© um m√≥dulo j√° embutido na linguagem, e serve para isolar ambientes de projetos. Ou seja, eu consigo ter dois projetos rodando em dois ambientes diferentes, que podem ter vers√µes diferentes de uma mesma biblioteca.

Na pr√°tica, vamos instalar as bibliotecas em um diret√≥rio que est√° relacionado ao projeto. Assim, cada projeto pode ter suas pr√≥prias bibliotecas na vers√£o que quiser. A ideia √© a mesma do npm que voc√™s j√° v√™m usando.

O comando para cria√ß√£o deste ambiente isolado √© python3 -m venv .venv, sendo que .venv √© o nome do ambiente isolado. Este comando deve ser executado na raiz do projeto.

Caso o venv n√£o esteja instalado, utilize o comando sudo apt install python3-venv.

Este ambiente isolado ser√° visto como um diret√≥rio criado na raiz do projeto. O ponto na frente do nome faz com que o diret√≥rio fique oculto.

Depois de criado, temos que ativar este ambiente para us√°-lo. Isto √© importante pois sempre que decidirmos trabalhar neste projeto devemos repetir este passo.

EX:

source .venv/bin/activate

Cria√ß√£o de um ambiente virtual.

Voc√™ pode conferir se o comando de ativa√ß√£o do ambiente virtual deu certo com o seguinte comando:

EX:

which python3

O resultado ser√° o caminho para a pasta onde voc√™ criou seu ambiente virtual (pwd), acrescido de .venv/bin/python3.

Pronto! Agora nosso ambiente est√° preparado para a instala√ß√£o das bibliotecas que precisaremos nos nossos projetos.


* Entrada

Uma das maneiras que existem de receber valores em nossos programas √© utilizando o m√≥dulo sys. Quando executamos um script e adicionamos par√¢metros, os mesmos estar√£o dispon√≠veis atrav√©s de uma vari√°vel chamada sys.argv, que √© preenchida sem que precisemos fazer nada. Na pr√°tica, podemos escrever o conte√∫do abaixo em um arquivo e passar alguns par√¢metros ao execut√°-lo.

EX:

import sys


if __name__ == "__main__":
    for argument in sys.argv:
        print("Received -> ", argument)
        
* Podemos executar o c√≥digo usando os par√¢metros atrav√©s do comando abaixo:

EX:

python3 arquivo.py 2 4 "teste"

A sa√≠da ser√°:

Received ->  arquivo.py
Received ->  2
Received ->  4
Received ->  teste

Tamb√©m √© poss√≠vel coletar dados do terminal atrav√©s da fun√ß√£o input, que vem embutida na pr√≥pria linguagem. Esta fun√ß√£o est√° vinculada √† entrada padr√£o do sistema operacional e tem como par√¢metro opcional o prompt que, caso seja fornecido, exibir√° a mensagem passada para ele em tela. O valor recebido atrav√©s da fun√ß√£o ser√° do tipo texto (str):

EX:

user_input = input("Digite uma mensagem: ")
print('O valor recebido foi:', user_input)

* Como j√° visto, a fun√ß√£o print ‚Äî que j√° vem embutida na linguagem ‚Äî √© a principal fun√ß√£o para imprimirmos um valor em ‚Äútela‚Äù. Normalmente esta fun√ß√£o escreve na sa√≠da padr√£o do sistema operacional, mas veremos que √© poss√≠vel modificar este e outros comportamentos.

* Esta fun√ß√£o recebe par√¢metros de forma vari√°vel, ou seja, pode receber nenhum, um, dois ou n par√¢metros durante sua invoca√ß√£o.

EX:

print("O resultado √©", 42)  # sa√≠da: O resultado √© 42
print("Os resultados s√£o", 6, 23, 42)  # sa√≠da: Os resultados s√£o 6 23 42

* O separador padr√£o dos argumentos √© um espa√ßo em branco, que pode ser alterado.

EX:

print("Maria", "Jo√£o", "Miguel", "Ana")  # sa√≠da: Maria Jo√£o Miguel Ana
print("Maria", "Jo√£o", "Miguel", "Ana", sep=", ")  # sa√≠da: Maria, Jo√£o, Miguel, Ana

* Al√©m do separador, podemos tamb√©m alterar o caractere de fim de linha que, por regra, √© uma quebra de linha:

EX:

print("Em duas ")
print("linhas.")

Sa√≠da:
Em duas
linhas.

* Alterando o padr√£o:

EX:

print("Na mesma", end=" ")
print("linha.")

Sa√≠da:
Na mesma linha.
J√° sabemos que erros podem acontecer e o sistema operacional normalmente espera que um programa escreva seus erros na sa√≠da de erros.

* Existe um par√¢metro que nos permite modificar a sa√≠da padr√£o para a sa√≠da de erros:

EX:

import sys

err = "Arquivo n√£o encontrado"
print(f"Erro aconteceu: {err}", file=sys.stderr)

üí° Em Python, podemos fazer interpola√ß√£o de vari√°veis e express√µes utilizando f-string. Adicionamos um f antes das aspas e o valor de sa√≠da entre chaves. Essa dica √© importante, pois √© a maneira mais eficiente de formatar strings.
