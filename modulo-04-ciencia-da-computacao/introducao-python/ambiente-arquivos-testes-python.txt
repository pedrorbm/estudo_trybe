* M√≥dulos:

Um m√≥dulo √© um arquivo que cont√©m defini√ß√µes e instru√ß√µes em Python. O nome do arquivo √© um nome acrescido de .py. Voc√™ pode importar um m√≥dulo dentro de um outro arquivo Python e ter acesso √†s suas fun√ß√µes, classes, etc.

Em linhas gerais, todo arquivo que √© escrito com a linguagem Python e com a extens√£o .py √© considerado um m√≥dulo.

Observe o arquivo my_math.py abaixo:

EX:

def sum(a, b):
  return a + b


def pot(a, b):
  return a ** b


print(sum(2, 2))
print(pot(2, 3))

Este arquivo √© um m√≥dulo Python, que pode ser executado como script com o comando python3 my_math.py. Se isso ocorrer, os retornos ser√£o 4 e 8, respectivamente, devido √†s chamadas das fun√ß√µes dentro dos m√©todos print().

Entretanto, as fun√ß√µes que criamos neste arquivo podem ser reaproveitadas por outros m√≥dulos atrav√©s da declara√ß√£o import.

√Ä medida que fomos avan√ßando, esses conceitos ficar√£o cada vez mais n√≠tidos.


* Pacotes:

Pacotes s√£o m√≥dulos Python que cont√™m outros m√≥dulos e/ou pacotes, comumente separados por responsabilidades similares. Na pr√°tica, um pacote √© um diret√≥rio que pode conter v√°rios m√≥dulos (arquivos de extens√£o .py) e/ou outros pacotes.

Exemplo de tipos diferentes de imports de pacotes:

EX:

import http  # importa o pacote http como um m√≥dulo

from http import client  # importa o m√≥dulo client do pacote http


from http.client import HTTP_PORT  # importa a constante HTTP_PORT do m√≥dulo client do pacote http


* Ambiente Virtual

Imagine que, em uma m√°quina, h√° um projeto Python que cont√©m alguns pacotes de terceiros instalados e, dentre eles, h√° uma biblioteca na vers√£o 1.4. Imagine tamb√©m que, na mesma m√°quina, √© iniciado um novo projeto que precisa da mesma biblioteca, mas dessa vez na vers√£o 2.0. O que fazer? As vers√µes s√£o compat√≠veis? Se eu atualizar o sistema, a vers√£o antiga vai continuar funcionando?

O venv entra como resposta para essas perguntas! Ele √© um m√≥dulo j√° embutido na linguagem, e serve para isolar ambientes de projetos. Ou seja, eu consigo ter dois projetos rodando em dois ambientes diferentes, que podem ter vers√µes diferentes de uma mesma biblioteca.

Na pr√°tica, vamos instalar as bibliotecas em um diret√≥rio que est√° relacionado ao projeto. Assim, cada projeto pode ter suas pr√≥prias bibliotecas na vers√£o que quiser. A ideia √© a mesma do npm que voc√™s j√° v√™m usando.

O comando para cria√ß√£o deste ambiente isolado √© python3 -m venv .venv, sendo que .venv √© o nome do ambiente isolado. Este comando deve ser executado na raiz do projeto.

Caso o venv n√£o esteja instalado, utilize o comando sudo apt install python3-venv.

Este ambiente isolado ser√° visto como um diret√≥rio criado na raiz do projeto. O ponto na frente do nome faz com que o diret√≥rio fique oculto.

Depois de criado, temos que ativar este ambiente para us√°-lo. Isto √© importante pois sempre que decidirmos trabalhar neste projeto devemos repetir este passo.

EX:

source .venv/bin/activate

Cria√ß√£o de um ambiente virtual.

Voc√™ pode conferir se o comando de ativa√ß√£o do ambiente virtual deu certo com o seguinte comando:

EX:

which python3

O resultado ser√° o caminho para a pasta onde voc√™ criou seu ambiente virtual (pwd), acrescido de .venv/bin/python3.

Pronto! Agora nosso ambiente est√° preparado para a instala√ß√£o das bibliotecas que precisaremos nos nossos projetos.


* Entrada

Uma das maneiras que existem de receber valores em nossos programas √© utilizando o m√≥dulo sys. Quando executamos um script e adicionamos par√¢metros, os mesmos estar√£o dispon√≠veis atrav√©s de uma vari√°vel chamada sys.argv, que √© preenchida sem que precisemos fazer nada. Na pr√°tica, podemos escrever o conte√∫do abaixo em um arquivo e passar alguns par√¢metros ao execut√°-lo.

EX:

import sys


if __name__ == "__main__":
    for argument in sys.argv:
        print("Received -> ", argument)
        
* Podemos executar o c√≥digo usando os par√¢metros atrav√©s do comando abaixo:

EX:

python3 arquivo.py 2 4 "teste"

A sa√≠da ser√°:

Received ->  arquivo.py
Received ->  2
Received ->  4
Received ->  teste

Tamb√©m √© poss√≠vel coletar dados do terminal atrav√©s da fun√ß√£o input, que vem embutida na pr√≥pria linguagem. Esta fun√ß√£o est√° vinculada √† entrada padr√£o do sistema operacional e tem como par√¢metro opcional o prompt que, caso seja fornecido, exibir√° a mensagem passada para ele em tela. O valor recebido atrav√©s da fun√ß√£o ser√° do tipo texto (str):

EX:

user_input = input("Digite uma mensagem: ")
print('O valor recebido foi:', user_input)

* Como j√° visto, a fun√ß√£o print ‚Äî que j√° vem embutida na linguagem ‚Äî √© a principal fun√ß√£o para imprimirmos um valor em ‚Äútela‚Äù. Normalmente esta fun√ß√£o escreve na sa√≠da padr√£o do sistema operacional, mas veremos que √© poss√≠vel modificar este e outros comportamentos.

* Esta fun√ß√£o recebe par√¢metros de forma vari√°vel, ou seja, pode receber nenhum, um, dois ou n par√¢metros durante sua invoca√ß√£o.

EX:

print("O resultado √©", 42)  # sa√≠da: O resultado √© 42
print("Os resultados s√£o", 6, 23, 42)  # sa√≠da: Os resultados s√£o 6 23 42

* O separador padr√£o dos argumentos √© um espa√ßo em branco, que pode ser alterado.

EX:

print("Maria", "Jo√£o", "Miguel", "Ana")  # sa√≠da: Maria Jo√£o Miguel Ana
print("Maria", "Jo√£o", "Miguel", "Ana", sep=", ")  # sa√≠da: Maria, Jo√£o, Miguel, Ana

* Al√©m do separador, podemos tamb√©m alterar o caractere de fim de linha que, por regra, √© uma quebra de linha:

EX:

print("Em duas ")
print("linhas.")

Sa√≠da:
Em duas
linhas.

* Alterando o padr√£o:

EX:

print("Na mesma", end=" ")
print("linha.")

Sa√≠da:
Na mesma linha.
J√° sabemos que erros podem acontecer e o sistema operacional normalmente espera que um programa escreva seus erros na sa√≠da de erros.

* Existe um par√¢metro que nos permite modificar a sa√≠da padr√£o para a sa√≠da de erros:

EX:

import sys

err = "Arquivo n√£o encontrado"
print(f"Erro aconteceu: {err}", file=sys.stderr)

üí° Em Python, podemos fazer interpola√ß√£o de vari√°veis e express√µes utilizando f-string. Adicionamos um f antes das aspas e o valor de sa√≠da entre chaves. Essa dica √© importante, pois √© a maneira mais eficiente de formatar strings.


# leitura e escrita de arquivos:

* A fun√ß√£o open √© a respons√°vel por abrir um arquivo, tornando poss√≠vel sua manipula√ß√£o. Seu √∫nico par√¢metro obrigat√≥rio √© o nome do arquivo. Por padr√£o, arquivos s√£o abertos somente para leitura, mas podemos modificar isto passando o modo com que vamos abrir o arquivo. No exemplo abaixo, estamos utilizando mode="w", ou seja, estamos abrindo o arquivo para escrita:

EX:

file = open("arquivo.txt", mode="w")  

ao abrir um arquivo para escrita, um novo arquivo √© criado mesmo que ele j√° exista, sobrescrevendo o antigo.
O objeto especial file gerado no c√≥digo anterior ser√° usado para fazermos leituras e escritas no arquivo, como veremos a seguir. Depois de realizarmos todas as opera√ß√µes desejadas, √© imprescind√≠vel que o comando file.close() seja executado pois existe uma quantidade limite de arquivos que podemos abrir de uma s√≥ vez. Caso o limite seja excedido, o Sistema Operacional levantar√° um OSError.

* Para ter um melhor controle da abertura de fechamento de arquivos, devemos utilizar os gerenciadores de contexto do Python. Essa funcionalidade √© comum tamb√©m em outros recursos que devemos utilizar e liberar ao final (conex√µes de bancos de dados, por exemplo).

O with √© a palavra reservada para gerenciamento de contexto no Python. Este gerenciamento (with) √© utilizado para encapsular a utiliza√ß√£o de um recurso, garantindo que certas a√ß√µes sejam tomadas independentemente se ocorreu ou n√£o um erro naquele contexto.

A fun√ß√£o open retorna um objeto que se comporta como um gerenciador de contexto de arquivo que ser√° respons√°vel por abrir e fechar o mesmo. Isto significa que o arquivo possui mecanismos especiais que, quando invocados utilizando with, alocam um determinado recurso ‚Äî um arquivo ‚Äî e o liberam quando o bloco for finalizado.

EX:

# Criamos um contexto, limitando o escopo onde o arquivo est√° aberto.
# O uso do "as" aqui √© somente para atribuir o valor utilizado no contexto √† vari√°vel file
with open("arquivo.txt", "w") as file:
    # como estamos DENTRO do contexto, verificamos que o arquivo est√° ABERTO
    # atrav√©s do atributo booleano 'closed' (file.closed = False)
    print(file.closed)
# como estamos FORA do contexto, o arquivo est√° FECHADO (file.closed = True)
print(file.closed)

‚ö†Ô∏è A partir de agora, faremos todas as leituras e escritas de arquivo utilizando o gerenciador de contexto do Python.

* Para escrevermos um conte√∫do em um arquivo utilizamos a fun√ß√£o write:

EX:

# with open("arquivo.txt", "w") as file:
    # file.write("nome idade\n")

    file.write("Maria 45\n")
    file.write("Miguel 33\n")
    
üí° S√≥ √© poss√≠vel escrever em um arquivo ap√≥s abri-lo em um modo que permita escrita.

* Assim como podemos redirecionar a sa√≠da do nosso programa para a sa√≠da de erros, podemos redirecionar o conte√∫do digitado dentro de print para um arquivo. Ou seja, tamb√©m podemos escrever em um arquivo atrav√©s do print.

EX:

# with open("arquivo.txt", "w") as file:
#     file.write("Miguel 33\n")


    # N√£o precisa da quebra de linha, pois esse √© um comportamento padr√£o do print
    print("T√∫lio 22", file=file)
    
* Para escrever m√∫ltiplas linhas podemos utilizar a fun√ß√£o writelines. Repare que a fun√ß√£o espera que cada linha tenha seu pr√≥prio caractere de separa√ß√£o (\n):

EX:

# with open("arquivo.txt", "w") as file:
#   ...

    LINES = ["Alberto 35\n", "Betina 22\n", "Jo√£o 42\n", "Victor 19\n"]
    file.writelines(LINES)
    
* A leitura do conte√∫do de um arquivo pode ser feita utilizando a fun√ß√£o read. Para experimentar, vamos escrever em um arquivo e l√™-lo logo em seguida!

EX:

# escrita
with open("arquivo.txt", "w") as file:
    file.write("Trybe S2")

# leitura
with open("arquivo.txt", "r") as file:
    content = file.read()
    print(content)
    
* Um arquivo √© tamb√©m um iter√°vel, ou seja, pode ser percorrido em um la√ßo de repeti√ß√£o. A cada itera√ß√£o, uma nova linha √© retornada. Vamos fazer igual ao exemplo anterior, por√©m dessa vez vamos escrever mais de uma linha!

EX:

# escrita
with open("arquivo.txt", "w") as file:
    LINES = ["Ol√°\n", "mundo\n", "belo\n", "do\n", "Python\n"]
    file.writelines(LINES)

# leitura
with open("arquivo.txt", "r") as file:
    for line in file:
        print(line)  # n√£o esque√ßa que a quebra de linha tamb√©m √© um caractere da linha
        
        
# Erros de Sintaxe:

Erros de sintaxe ocorrem quando o c√≥digo utiliza recursos inexistentes da linguagem que n√£o consegue interpret√°-los. √â como executar print{"Ol√°, mundo!"} em vez de print("Ol√°, mundo!").


# Exce√ß√µes:

J√° as exce√ß√µes ocorrem durante a execu√ß√£o e resultam em mensagem de erro. Veja exemplos de exce√ß√µes:

EX:

print(10 * (1 / 0))
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# ZeroDivisionError: division by zero
print(4 + spam * 3)
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# NameError: name 'spam' is not defined
print('2' + 2)
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: can only concatenate str (not "int") to str

Observe que, apenas no exemplo acima, podemos observar tr√™s exce√ß√µes: ZeroDivisionError, NameError e TypeError. A lista completa de exce√ß√µes j√° embutidas na linguagem pode ser vista aqui.

* Tratamento de exce√ß√µes

Para tratar exce√ß√µes utilizamos o conjunto de instru√ß√µes try, com as palavras reservadas try e except. O funcionamento dessa cl√°usula ocorre da seguinte forma:

Se nenhuma exce√ß√£o ocorrer, a cl√°usula except √© ignorada e a execu√ß√£o da instru√ß√£o try √© finalizada.
Se ocorrer uma exce√ß√£o durante a execu√ß√£o da cl√°usula try, as instru√ß√µes remanescentes na cl√°usula s√£o ignoradas. Se o tipo da exce√ß√£o ocorrida tiver sido previsto em algum except, ent√£o essa cl√°usula ser√° executada.
Se n√£o existir nenhum tratador previsto para tal exce√ß√£o, trata-se de uma exce√ß√£o n√£o tratada e a execu√ß√£o do programa termina com uma mensagem de erro.

Vamos agora ver um exemplo de tratamento de exce√ß√µes:

EX:

while True:
    try:
        x = int(input("Por favor digite um n√∫mero inteiro: "))
        break
    except ValueError:
        # 'ValueError' √© a exce√ß√£o que ocorre quando a fun√ß√£o int() recebe um
        # valor que n√£o pode ser traduzido para n√∫mero inteiro
        print("Oops! Esse n√£o era um n√∫mero inteiro. Tente novamente...")

* Lidando com exce√ß√µes enquanto manipulamos arquivos

Vamos ver agora como podemos nos prevenir de poss√≠veis erros que ocorrem quando manipulamos arquivos. Sempre devemos fechar um arquivo e podemos, em um bloco try, fazer isso utilizando a instru√ß√£o finally ou else. O finally √© uma outra cl√°usula do conjunto try, cuja finalidade √© permitir a implementa√ß√£o de a√ß√µes de limpeza, que sempre devem ser executadas independentemente da ocorr√™ncia de a√ß√µes. J√° o else ocorre sempre que todo o try for bem sucedido.

EX:

try:
    with open("arquivo.txt", "r") as file:
        print(file.read())
except FileNotFoundError:
    # ser√° executado caso haja a exce√ß√£o 'FileNotFoundError'
    print("Arquivo inexistente")
else:
    # ser√° executado se tudo ocorrer bem no try
    print("Arquivo manipulado e fechado com sucesso")
finally:
    # ser√° sempre executado, independentemente de erro
    print("Fim da tentativa de ler o arquivo")
    
Como estamos abrindo o arquivo em modo de leitura, uma exce√ß√£o ser√° levantada caso ele n√£o exista, executando as cl√°usulas except e finally. Entretanto, se alterarmos o modo para escrita, o arquivo ser√° criado mesmo se inexistente, executando as cl√°usulas else e finally.


# leitura e escrita de arquivos .json:

Seus principais m√©todos para manipula√ß√£o s√£o: load, loads, dump, dumps.

EX:

import json  # json √© um modulo que vem embutido, por√©m precisamos import√°-lo


with open("pokemons.json") as file:
    content = file.read()  # leitura do arquivo
    pokemons = json.loads(content)["results"]  # o conte√∫do √© transformado em estrutura python equivalente, dicion√°rio neste caso.
    # acessamos a chave results que √© onde cont√©m nossa lista de pokemons

print(pokemons[0])  # imprime o primeiro pokemon da lista

* A leitura pode ser feita diretamente do arquivo, utilizando o m√©todo load ao inv√©s de loads. O loads carrega o JSON a partir de um texto e o load carrega o JSON a partir de um arquivo.

EX:

import json


with open("pokemons.json") as file:
    pokemons = json.load(file)["results"]

print(pokemons[0])  # imprime o primeiro pokemon da lista

* A escrita de arquivos no formato JSON √© similar √† escrita de arquivos comuns, por√©m temos que transformar os dados primeiro.

EX:

import json

# Leitura de todos os pokemons
with open("pokemons.json") as file:
    pokemons = json.load(file)["results"]

# Separamos somente os do tipo grama
grass_type_pokemons = [
    pokemon for pokemon in pokemons if "Grass" in pokemon["type"]
]

# Abre o arquivo para escrevermos apenas o pokemons do tipo grama
with open("grass_pokemons.json", "w") as file:
    json_to_write = json.dumps(
        grass_type_pokemons
    )  # convers√£o de Python para o formato json (str)
    file.write(json_to_write)
    
    
* Assim como a desserializa√ß√£o, que faz a transforma√ß√£o de texto em formato JSON para Python, a serializa√ß√£o (caminho inverso) possui um m√©todo equivalente para escrever em arquivos de forma direta.

EX:

import json

# leitura de todos os pokemons
with open("pokemons.json") as file:
    pokemons = json.load(file)["results"]

# separamos somente os do tipo grama
grass_type_pokemons = [
    pokemon for pokemon in pokemons if "Grass" in pokemon["type"]
]

# abre o arquivo para escrita
with open("grass_pokemons.json", "w") as file:
    # escreve no arquivo j√° transformando em formato json a estrutura
    json.dump(grass_type_pokemons, file)
    
üí° Arquivos JSON n√£o seguem a nomenclatura habitual de leitura e escrita (write e read), pois s√£o considerados formatos de serializa√ß√£o de dados. Seguem ent√£o as mesmas nomenclaturas utilizadas em m√≥dulos como marshal e pickle, que tamb√©m s√£o formatos de serializa√ß√£o.


# leitura e escrita em arquivos .csv:

O m√≥dulo csv, cont√©m duas principais fun√ß√µes:

Um leitor (reader) que nos ajuda a ler o conte√∫do, j√° fazendo as transforma√ß√µes dos valores para Python;

E um escritor (writer) para facilitar a escrita nesse formato.

EX:

import csv

with open("graduacao_unb.csv", encoding = "utf-8") as file:
    # Os valores padr√£o de 'delimiter' e 'quotechar' s√£o os mesmos utilizados 
    # abaixo. Voc√™ pode remov√™-los ou alter√°-los conforme necessidade
    graduacao_reader = csv.reader(file, delimiter=",", quotechar='"')

    # Usando o conceito de desempacotamento
    header, *data = graduacao_reader

print(data)

Al√©m do arquivo file, o leitor recebe par√¢metros opcionais como os listados aqui.

* Um leitor de .csv pode ser percorrido utilizando o la√ßo de repeti√ß√£o for e, a cada itera√ß√£o, retorna uma nova linha j√° transformada em uma lista Python com seus respectivos valores.

Podemos fazer uma an√°lise e verificar quantos cursos s√£o ofertados por departamento. Em seguida salvamos o resultado tamb√©m no formato .csv:

EX:

import csv

with open("graduacao_unb.csv", encoding="utf8") as file:
    graduacao_reader = csv.reader(file, delimiter=",", quotechar='"')
    # Usando o conceito de desempacotamento
    header, *data = graduacao_reader

group_by_department = {}
for row in data:
    department = row[15]
    if department not in group_by_department:
        group_by_department[department] = 0
    group_by_department[department] += 1

# Escreve o relat√≥rio em .csv
# Abre um arquivo para escrita
with open("department_report.csv", "w", encoding = "utf-8") as file:
    writer = csv.writer(file)

    # Escreve o cabe√ßalho
    headers = [
        "Departamento",
        "Total de Cursos",
    ]
    writer.writerow(headers)

    # Escreve as linhas de dados
    # Desempacotamento de valores
    for department, grades in group_by_department.items():
        # Agrupa o dado com o turno
        row = [
            department,
            grades,
        ]
        writer.writerow(row)
        
        
* Existem ainda o leitor e o escritor baseados em dicion√°rios. A principal vantagem √© que n√£o precisamos manipular os √≠ndices para acessar os dados das colunas. A desvantagem √© o espa√ßo ocupado em mem√≥ria (que √© maior que o comum), devido √† estrutura de dados utilizada.

EX:

import csv

# l√™ os dados
with open("graduacao_unb.csv", encoding = "utf-8") as file:
    graduacao_reader = csv.DictReader(file, delimiter=",", quotechar='"')

    # A linha de cabe√ßalhos √© utilizada como chave do dicion√°rio
    # agrupa cursos por departamento
    group_by_department = {}
    for row in graduacao_reader:
        department = row["unidade_responsavel"]
        if department not in group_by_department:
            group_by_department[department] = 0
        group_by_department[department] += 1
        
üí° Ainda que a manipula√ß√£o de arquivos seja algo trivial, caso precise fazer an√°lises de dados, leve em considera√ß√£o bibliotecas como Pandas. Elas foram constru√≠das e s√£o mantidas justamente para atender e facilitar este objetivo.


# Testes automatizados

Quem nunca arrumou um problema em um c√≥digo e acabou atrapalhando o funcionamento dele em outro cen√°rio? Ou ficou horas testando as mais diversas condi√ß√µes para um algoritmo e no meio do caminho teve de mexer no c√≥digo e recome√ßar tudo novamente.

Atrav√©s de testes automatizados, a pessoa desenvolvedora √© capaz de identificar mais facilmente um bug ou verificar que altera√ß√µes do c√≥digo n√£o afetaram o comportamento esperado do sistema.

Em nosso curso utilizaremos a biblioteca pytest, um framework que facilita a escrita de testes simples, mas capazes de testar funcionalidades complexas em aplica√ß√µes e bibliotecas.

‚ö†Ô∏è Lembre-se de instalar a biblioteca somente no ambiente virtual do seu projeto.

* A instala√ß√£o √© feita atrav√©s do pip utilizando o comando:

EX:

python3 -m pip install pytest

* E podemos verificar utilizando o comando:

EX:

python3 -m pytest --version

A sa√≠da esperada √© similar √† apresentada abaixo.

This is pytest version 5.3.0, imported from /home/cassiobotaro/projects/gerenciador-tarefas/.venv/lib/python3.8/site-packages/pytest.py

* Que tal vermos um exemplo?

codigo.py

EX:

def is_odd(number):
    'Retorna True se um n√∫mero √© √≠mpar, sen√£o False.'
    return number % 2 != 0
    
test_codigo.py

EX:

from codigo import is_odd


def test_is_odd_when_number_is_odd_returns_true():
    'Para um n√∫mero √≠mpar a fun√ß√£o deve retornar o valor True'
    assert is_odd(3) is True


def test_is_odd_when_number_is_even_returns_false():
    'Para um n√∫mero par a fun√ß√£o deve retornar o valor False'
    assert is_odd(2) is False
    
Notem que o nome do arquivo de testes possui o prefixo test_, assim como a defini√ß√£o das fun√ß√µes de teste. Isto √© necess√°rio para que seus testes sejam descobertos pela ferramenta.

Uma fun√ß√£o de teste √© similar a qualquer outra, por√©m tem o prop√≥sito de verificar se o resultado obtido foi o mesmo do esperado. No c√≥digo, isto pode ser visto atrav√©s da utiliza√ß√£o da palavra reservada assert.

O comando assert funciona da seguinte maneira: caso a express√£o recebida seja verdadeira (avaliada como True), nada acontece. Por√©m, caso seja falsa (avaliada como False), uma exce√ß√£o do tipo AssertionError √© lan√ßada. A pytest captura este erro e tenta apresentar uma compara√ß√£o entre o esperado e o recebido da melhor maneira poss√≠vel.

Vamos rodar nossos testes e ver o resultado? Vamos utilizar o comando:

EX:

python3 -m pytest


# Testando falhas:

Erros acontecem e nem sempre s√£o inesperados. O Python utiliza exce√ß√µes para sinalizar que ocorreram erros durante a execu√ß√£o de um c√≥digo e que nem sempre s√£o fatais.

Podemos escrever testes que verificam que um erro deve ocorrer a partir de uma determinada entrada.

Um exemplo pode ser visto abaixo:

codigo.py

EX:

# ...

def divide(a_number, other_number):
    "Retorna a divis√£o de a_number por other_number"
    return a_number / other_number
test_codigo.py

EX:

import pytest
from codigo import is_odd, divide

# ...

def test_divide_when_other_number_is_zero_raises_an_exception():
    with pytest.raises(ZeroDivisionError, match="division by zero"):
        divide(2, 0)
        
Utilizamos a fun√ß√£o raises da pytest para verificar se a exce√ß√£o ocorreu. Caso contr√°rio, ela lan√ßa um AssertionError, indicando que o teste n√£o passou. Podemos verificar tamb√©m se o texto retornado na exce√ß√£o √© o esperado atrav√©s do par√¢metro match, que pode receber uma express√£o regular. No exemplo, temos uma divis√£o por zero, que lan√ßa a exce√ß√£o esperada e o teste passa com sucesso.

* Evoluindo nossos testes

O ecossistema de testes do Python √© extremamente poderoso e ainda nos fornece diversas outras ferramentas interessantes:

pytest.fixtures: s√£o fun√ß√µes que podemos criar e ser√£o executadas antes e/ou depois dos nossos testes. Podemos us√°-las para inicializar ou limpar um banco de dados, criar valores de mock reutiliz√°veis, capturar logs do terminal e muito mais! Se quiser aprofundar, veja a documenta√ß√£o oficial.

unittest.mock: √© uma biblioteca nativa que oferece diversas formas de simular comportamentos que queremos testar. S√£o √∫teis quando estamos fazendo testes unit√°rios e n√£o queremos depender do funcionamento de outras partes da aplica√ß√£o (como testar um Service sem depender de sua Model). Para aprofundar, veja a documenta√ß√£o oficial!

hypothesis e faker: s√£o 2 exemplos de bibliotecas externas (precisam ser instaladas com o pip) que nos ajudam a criar diversos valores de teste. A biblioteca hypothesis (documenta√ß√£o aqui) nos ajuda executando um teste para diversos valores a partir de uma regra como ‚Äún√∫meros pares‚Äú ou ‚Äúdicion√°rios com a chave ‚Äòname‚Äô sendo uma string‚Äú. J√° a faker (documenta√ß√£o aqui) possui diversos geradores mais complexos (ex: email, telefone, endere√ßo, CPF, cart√£o de cr√©dito, etc.), e tudo isso com poucas linhas de c√≥digo!




