# INTRODU√á√ÉO A PYTHON.

* atualmente a vers√£o atual do python √© python 3.

* para acessar o terminal usando o linux que j√° vem integrado ao sistema, assim como mac. Basta digitar o seguinte comando:

EX:

python3  = comando digitado no terminal.

* operadores b√°sicos:

EX:

2 + 2  = soma.
2 - 2  = subtra√ß√£o.
2 * 2  = multiplica√ß√£o.
2 / 2  = divis√£o retornando o resto, ou seja retornando a divis√£o completa com v√≠rgula.
2 // 2  = divis√£o retornando apenas o inteiro, ou seja apenas os n√∫meros antes da v√≠rgula.
2 > 3  = compra√ß√£o de maior, retorn aum boolean.
2 < 3  = compara√ß√£o de menor, retorna um boolean.
2 >= 3  = compra√ß√£o de maior ou igual, retorn aum boolean.
2 <= 3  = compara√ß√£o de menor ou igual, retorna um boolean.
2 < 4 < 6  = para saber se o n√∫mero do meio est√° entre o intervalo estabelecido.
count = 2  = definindo uma vari√°vel, n√£o precisa usar var, let ou const.
count += 2  = incrementa mais 2 ao valor de count.
count -= 2  = diminui 2 ao valor de count.
count = count + 2  = incrementa 2, mas √© uma forma menos simplificada.
1 < count < 5  = saber se o valor de count est√° entre 1 e 5.
or  = tem o valor de ou, mesma coisa de "||" no javascript.
and  = valor de e, mesma coisa do "&&" no javascript.
True  = √© verdadeiro lembrando que come√ßa com a letra mai√∫scula.
False  = √© falso lembrando que come√ßa com a letra min√∫scula.

# tipos de dados:


* Booleanos (bool)
Os valores booleanos True e False pertencem ao tipo embutido bool.


* N√∫meros inteiros (int)
O primeiro dos tipos num√©ricos √© o int, ele representa um n√∫mero inteiro, ou seja, √© escrito sem parte fracion√°ria.


* Inicialize uma vari√°vel a = 5, digite o comando type(a) e observe o retorno.

O m√©todo type(operando) corresponde ao operador typeof operando do JavaScript.


* Assim como qualquer linguagem de programa√ß√£o, Python tamb√©m possui uma grande quantidade de comandos que precisamos aprender. Para nos ajudar nessa tarefa, podemos digitar help() dentro da linha de comandos do Python que ele nos dar√° detalhes do comando passado por par√¢metro.

EX:

help(list)
O comando help() tamb√©m pode ser utilizado em cl√°usulas if ou for, desde que colocado entre aspas e para sair de dentro do comando, basta apertar a tecla q.

help("if")
N√∫meros fracion√°rios (float)
O segundo tipo num√©rico √© o float, tamb√©m conhecido por ponto flutuante, ele representa um n√∫mero decimal ou fracion√°rio.

Inicialize uma vari√°vel a = 5.0, digite o comando type(a) e observe o retorno.


* Strings (str)
Al√©m dos tipos num√©ricos, temos o tipo de sequ√™ncia de texto str. Ele representa uma cadeia de caracteres ou, como popularmente conhecida, uma string. As strings s√£o definidas envolvendo um valor com aspas simples ou duplas. Exemplo: a = "Ol√°"


* Temos ainda estruturas do tipo:

sequ√™ncia(list, tuple, range);
conjuntos(set, frozenset);
mapeamento(dict);
sequ√™ncias bin√°rias(bytes, bytearray, memoryview).


* Listas (list)

Anota a√≠ ‚úèÔ∏è: uma lista √© uma sequ√™ncia mut√°vel e ordenada de elementos. Ela pode armazenar elementos heterog√™neos, ter seu tamanho vari√°vel e crescer √† medida que itens s√£o adicionados.

EX:

fruits = ["laranja", "ma√ß√£", "uva", "abacaxi"]  # elementos s√£o definidos separados por v√≠rgula, envolvidos por colchetes

fruits[0]  # o acesso √© feito por √≠ndices iniciados em 0

fruits[-1]  # o acesso tamb√©m pode ser negativo

fruits.append("banana")  # adicionando uma nova fruta

fruits.remove("abacaxi")  # removendo uma fruta

fruits.extend(["pera", "mel√£o", "kiwi"])  # acrescenta uma lista de frutas a lista original

fruits.index("ma√ß√£")  # retorna o √≠ndice onde a fruta est√° localizada, neste caso, 1

fruits.sort()  # ordena a lista de frutas
Vamos continuar com os exerc√≠cios! üí™


* Tuplas (tuple)

S√£o similares a listas, por√©m n√£o podem ser modificados durante a execu√ß√£o do programa.

EX:

user = ("Will", "Marcondes", 42)  # elementos s√£o definidos separados por v√≠rgula, envolvidos por par√™nteses

user[0]  # acesso tamb√©m por √≠ndices


* Conjuntos (set)

Um conjunto √© uma cole√ß√£o de elementos √∫nicos e n√£o ordenados. Conjuntos implementam opera√ß√µes de uni√£o, intersec√ß√£o e outras.

EX:

permissions = {"member", "group"}  # elementos separados por v√≠rgula, envolvidos por chaves

permissions.add("root")  # adiciona um novo elemento ao conjunto

permissions.add("member")  # como o elemento j√° existe, nenhum novo item √© adicionado ao conjunto

permissions.union({"user"})  # retorna um conjunto resultado da uni√£o

permissions.intersection({"user", "member"})  # retorna um conjunto resultante da intersec√ß√£o dos conjuntos

permissions.difference({"user"})  # retorna a diferen√ßa entre os dois conjuntos


* Conjuntos imut√°veis (frozenset)

√â uma varia√ß√£o do set, por√©m imut√°vel, ou seja, seus elementos n√£o podem ser modificados durante a execu√ß√£o do programa.

EX:

permissions = frozenset(["member", "group"])  # assim como o set, qualquer estrutura iter√°vel pode ser utilizada para criar um frozenset

permissions.union({"user"})  # novos conjuntos imut√°veis podem ser criados √† partir do original, mas o mesmo n√£o pode ser modificado

permissions.intersection({"user", "member"})  # retorna um conjunto resultante da intersec√ß√£o dos conjuntos

permissions.difference({"user"})  # retorna a diferen√ßa entre os dois conjuntos


* Dicion√°rios (dict)
Estrutura que associa uma chave a um determinado valor. √â a representa√ß√£o do t√£o famoso objeto que utilizamos em JavaScript.

EX:

people_by_id = {1: "Maria", 2: "Fernanda", 3: "Felipe"}  # elementos no formato "chave: valor" separados por v√≠rgula, envolvidos por chaves

people_by_name = {"Maria": 1, "Fernanda": 2, "Felipe": 3}  # outro exemplo, dessa vez usando strings como chaves. As aspas s√£o necess√°rias para que o Python n√£o ache que `Maria`, `Fernanda` e `Felipe` sejam vari√°veis.


people_by_id[1]  # sa√≠da: Maria
# elementos s√£o acessados por suas chaves

del people_by_id[1]  # elementos podem ser removidos com a palavra chave del

people_by_id.items()  # dict_items([(2, "Fernanda"), (3, "Felipe")])
# √© retornada uma cole√ß√£o iter√°vel de tuplas contendo chaves e valores


* Range (range)

Estrutura capaz de gerar uma sequ√™ncia num√©rica de um valor inicial at√© um valor final, modificando seu valor de acordo com o passo (step) definido. Pode ser declarado como range( [start], [stop], [step] ), em que start e step podem ser omitidos, possuindo valores iniciais iguais a 0 e 1 respectivamente.

Anota a√≠ ‚úèÔ∏è: O stop n√£o √© inclu√≠do na sequ√™ncia, portanto, caso queira uma sequ√™ncia de 1 at√© 10 a chamada dever√° ser range(1, 11)

Seus valores s√£o criados √† medida que esta sequ√™ncia √© percorrida.

EX:

# vamos converter o range em uma lista para ajudar na visualiza√ß√£o

# definimos somente o valor de parada
list(range(5))  # sa√≠da: [0, 1, 2, 3, 4]

# definimos o valor inicial e o de parada
list(range(1, 6))  # sa√≠da: [1, 2, 3, 4, 5]

# definimos valor inicial, de parada e modificamos o passo para 2
list(range(1, 11, 2))  # sa√≠da: [1, 3, 5, 7, 9]

# podemos utilizar valores negativos para as entradas tamb√©m
list(range(10, 0, -1))  # sa√≠da: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]


* Al√©m dos tipos b√°sicos, temos outros como datas, tuplas nomeadas, arrays, enumera√ß√µes e outros, mas estes t√™m de ser importados de seus respectivos m√≥dulos.

