# DEBUG NO VSCODE:


* Com o arquivo aberto no VSCode, voc√™ pode executar o debugger de 2 formas diferentes:

Apertando a tecla F5;
Acessando a aba Run and Debug(Executar e Depurar) no menu lateral esquerdo e clicando no bot√£o Run and Debug (como na imagem a seguir).
VScode Run debug
Op√ß√µes de ‚ÄúRun and Debug‚Äù do VS Code

Em seguida, voc√™ deve escolher qual configura√ß√£o usar para o debug. Para os primeiros exemplos, vamos usar a op√ß√£o Python File (Arquivo Python):

VScode debug: Python File

Op√ß√£o ‚ÄúPython File‚Äù como configura√ß√£o para debug no VS Code

Pronto! Seu c√≥digo executou e‚Ä¶ nada de especial aconteceu! üòÖ

Esse √© o comportamento padr√£o quando nenhum breakpoint (ponto de parada) √© adicionado. Os breakpoints s√£o informa√ß√µes essenciais ao debugger, e vamos ver agora como utiliz√°-los ao nosso favor.

* Como debugar no VS Code?

Para come√ßar a debugar de verdade, coloque um breakpoint em seu c√≥digo.

Anota a√≠ üìù: Um breakpoint √© um ponto em seu c√≥digo onde a execu√ß√£o ir√° pausar.

Para colocar um breakpoint, clique na linha de c√≥digo onde voc√™ quer pausar a execu√ß√£o e pressione F9.

Outra forma de adicionar um breakpoint na linha √© clicar na bolinha vermelha üî¥ √† esquerda do n√∫mero das linhas que desejar.

Depois de colocar o breakpoint, execute seu c√≥digo em modo debug como foi ensinado: apertando F5 ou pela aba Run and Debug.

Agora sim! Voc√™ pode usar os comandos de debug para continuar a execu√ß√£o, passo a passo, ou examinar as vari√°veis em seu c√≥digo. Os principais comandos ficam no topo da janela, com bot√µes como mostramos na imagem a seguir:

* VScode debug: comandos

Veja qual a fun√ß√£o de cada um dos bot√µes/comandos, e seus respectivos atalhos no teclado:

1 - Continue (continuar): avan√ßa com a execu√ß√£o em modo debug at√© o pr√≥ximo breakpoint (atalho F5)
2 - Step over (contornar): executa a linha atual do c√≥digo sem entrar em fun√ß√µes (atalho F10)
3 - Step into (intervir): executa a linha atual do c√≥digo e entra em fun√ß√µes (atalho F11)
4 - Step out (sair): sai da fun√ß√£o atual e continua a execu√ß√£o (atalho Shift + F11)
5 - Restart (reiniciar): recome√ßa a execu√ß√£o do debugger (atalho depende do seu Sistema Operacional)
6 - Stop (interromper): encerra a execu√ß√£o do debugger (atalho depende do seu Sistema Operacional)


# Visualizando dados da depura√ß√£o:

Enquanto estamos usando o debugger, o VS Code nos apresenta algumas janelas extras na lateral esquerda que ser√£o muito √∫teis na investiga√ß√£o de nossos bugs:

VARIABLES (vari√°veis)
CALL STACK (pilha de chamadas)
WATCH (inspe√ß√£o)
BREAKPOINTS (pontos de parada)

Al√©m disso, tamb√©m ser√° poss√≠vel utilizar o DEBUG CONSOLE, como veremos em breve! üòâ

* Janela VARIABLES (vari√°veis)

Nessa janela poderemos ver todas as vari√°veis e os seus valores no contexto atual da aplica√ß√£o.

No nosso exemplo, n√£o vemos nenhum valor inicialmente, pois o breakpoint est√° na fun√ß√£o main() e, no momento do breakpoint, nenhuma vari√°vel foi criada ainda.

Assim que decidimos executar a linha atual (com F10 ou F11), a vari√°vel input_list aparecer√° na janela VARIABLES com seu valor: [1, 2, 3, 4, 5]. Ela fica dentro de Locals pois √© uma vari√°vel do escopo da fun√ß√£o atual.

Dentro de Globals n√£o h√° nada aparente porque n√£o criamos nenhuma vari√°vel no escopo global, mas se expandirmos function variables poderemos ver as fun√ß√µes que declaramos (e importamos) no nosso arquivo e seus respectivos metadados como __name__, __doc__ e __annotations__.

Para ver mais detalhes sobre a vari√°vel, clique no s√≠mbolo de > √† esquerda do nome. Como estamos olhando para uma lista do Python, √© mostrado o valor armazenado em cada √≠ndice e tamb√©m seu tamanho (representado em len()). Incr√≠vel, n√©?! ü§©

Dentro de special variables ficam os m√©todos e atributos ‚Äúm√°gicos‚Äù (magic methods ou dunder methods) daquele objeto, como __str__, __class__ e __contains__.

Dentro de function variables, veremos os m√©todos padr√µes daquele objeto, como append, remove e count.


* Janela CALL STACK (pilha de chamadas)

Aqui podemos ver, no ponto da execu√ß√£o do debug, qual √© a pilha de chamadas da nossa aplica√ß√£o. Em outras palavras, essa janela mostra quais fun√ß√µes/m√©todos/m√≥dulos foram chamados para que a execu√ß√£o chegasse at√© a linha atual.

No momento atual do nosso exemplo, temos a seguinte pilha:

main . . . . . . . . example.py [15:1]
<module> . . . . . . example.py [19:1]

A forma de ler isso √©:

A execu√ß√£o come√ßou no arquivo example.py no escopo global <module> e seguiu at√© a linha 19 desse arquivo. A fun√ß√£o main no arquivo example.py foi chamada e seguiu at√© a linha 15 desse arquivo.

Agora, vamos observar o que acontece quando avan√ßamos com execu√ß√£o avan√ßando para a pr√≥xima chamada de fun√ß√£o. Para isso, utilize o ‚Äústep into‚Äú (ou intervir - atalho F11) para que o debugger entre na fun√ß√£o map_factorial.

Opa! üëÄ

A fun√ß√£o map_factorial foi empilhada na nossa pilha de chamadas, e agora temos:

map_factorial . . . example.py [5:1]
main . . . . . . . . example.py [15:1]
<module> . . . . . . example.py [19:1]

Juntando tudo, podemos interpretar que:

A execu√ß√£o come√ßou no arquivo example.py no escopo global <module> e seguiu at√© a linha 19 desse arquivo. A fun√ß√£o main no arquivo example.py foi chamada e seguiu at√© a linha 15 desse arquivo. A fun√ß√£o map_factorial no arquivo example.py foi chamada e seguiu at√© a linha 5 desse arquivo.

Ah, repare que a janela VARIABLES tamb√©m mudou! Agora j√° n√£o vemos mais a vari√°vel input_list, e temos o valor de numbers (par√¢metro recebido pela fun√ß√£o map_factorial).


* Janela WATCH (inspe√ß√£o)

Essa janela mostra resultados de qualquer express√£o em Python que desejarmos ‚Äúvigiar‚Äù!

Por exemplo, podemos inspecionar o resultado de sum(result). Assim, para cada avan√ßo do debugger a janela WATCH nos mostrar√° a soma de todos os elementos dentro da vari√°vel result. Para isso, basta clicar no sinal de ‚ûï no cabe√ßalho da janela e definir as express√µes que desejar (como na imagem a seguir)

Repare que, para o nosso exemplo, a vari√°vel result ainda n√£o foi definida ent√£o o resultado da express√£o sum(result) √© um NameError.

Se avan√ßarmos na execu√ß√£o com ‚Äústep into‚Äú (atalho F11), veremos que o valor da express√£o ser√° atualizado a medida que o conte√∫do de result √© alterado quando passamos pela linha result.append(factorial(num)). Os valores que veremos s√£o: 0, 1, 3, 9, 33 e por fim 153.

Viu que a janela VARIABLES foi alterando seus valores? A medida que avan√ßamos, result teve seu valor preenchido e a vari√°vel num (auxiliar do for) foi sendo alterada a cada itera√ß√£o!

Quando a fun√ß√£o map_factorial retornar, sum(result) ter√° novamente um NameError pois a vari√°vel result deixa de existir no escopo da execu√ß√£o.


# Breakpoints condicionais:

Como o pr√≥prio nome sugere, os breakpoints condicionais s√£o breakpoints que s√≥ param a execu√ß√£o do programa quando uma condi√ß√£o espec√≠fica √© satisfeita. Vamos analisar o c√≥digo do exemplo para entender como isso funciona.

Imagine que voc√™ est√° debugando o c√≥digo do Insertion Sort e quer saber o valor da vari√°vel array ao final do loop while quando o valor da vari√°vel i for maior ou igual a 5.

Para fazer isso, voc√™ pode colocar um breakpoint na linha de c√≥digo ap√≥s o loop while e configur√°-lo para parar a execu√ß√£o somente quando o valor da vari√°vel i for igual a 5.

Para fazer isso, basta clicar com o bot√£o direito do mouse na bolinha vermelha üî¥ do breakpoint e selecionar a op√ß√£o ‚ÄúEdit Breakpoint‚Ä¶‚Äù:

Na janela que se abre, voc√™ pode digitar a condi√ß√£o que precisar√° ser satisfeita para o breakpoint interromper a execu√ß√£o do programa, nesse caso i >= 5, e apertar Enter para definir esse breakpoint condicional:

Relembrando üß†: Neste caso, o breakpoint s√≥ vai parar a execu√ß√£o do programa quando o valor da vari√°vel i for maior ou igual a 5.

Avance a execu√ß√£o do programa at√© que o breakpoint seja atingido!


* VS Code Debug Console

Nesse caso, infelizmente a janela VARIABLES n√£o nos mostra o valor completo da vari√°vel array. O valor ap√≥s 234 fica oculto üò¢

EX:

[1, 8, 23, 54, 423, 980, 45, 768, 34, 55, 88, 99, 100, 234, ...]

Mas n√£o se preocupe, o VS Code tem uma ferramenta que nos permite inspecionar o valor de vari√°veis e express√µes durante a execu√ß√£o do programa: o VS Code Debug Console (console de Debug do VS Code).

Para abrir o VS Code Debug Console, clique no √≠cone do VS Code Debug Console na barra de ferramentas do VS Code.

Na janela que se abre, voc√™ pode realizar qualquer opera√ß√£o (como se fosse o pr√≥prio terminal do Python) e inspecionar o valor de vari√°veis e express√µes durante a execu√ß√£o do programa. Para o nosso exemplo, vamos imprimir o valor da vari√°vel array:

EX:

print(array)

Agora sim, podemos ver o valor completo da vari√°vel array:

EX:

[1, 8, 23, 54, 423, 980, 45, 768, 34, 55, 88, 99, 100, 234, 567]

Al√©m disso, podemos extrapolar e realizar opera√ß√µes como somar todos os elementos do array e remover o √∫ltimo elemento do array:

EX:

sum(array)
# 3479

array.pop()
# 567



